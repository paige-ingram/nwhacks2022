'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var communicationCommon = require('@azure/communication-common');
var reselect = require('reselect');
var communicationCalling = require('@azure/communication-calling');
var memoizeOne = require('memoize-one');
var React = require('react');
var react = require('@fluentui/react');
var reactNorthstar = require('@fluentui/react-northstar');
var reactIcons = require('@fluentui/react-icons');
var reactAriaLive = require('react-aria-live');
var htmlToReact = require('html-to-react');
var Linkify = require('react-linkify');
var uuid = require('uuid');
var copy = require('copy-to-clipboard');
var EventEmitter = require('events');
var produce = require('immer');
var communicationChat = require('@azure/communication-chat');
var nanoid = require('nanoid');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var reselect__namespace = /*#__PURE__*/_interopNamespace(reselect);
var memoizeOne__default = /*#__PURE__*/_interopDefaultLegacy(memoizeOne);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var Linkify__default = /*#__PURE__*/_interopDefaultLegacy(Linkify);
var copy__default = /*#__PURE__*/_interopDefaultLegacy(copy);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);
var produce__default = /*#__PURE__*/_interopDefaultLegacy(produce);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const argsCmp = (args1, args2, objCmp) => {
    return args1.length === args2.length && args1.every((arg1, index) => objCmp(args2[index], arg1));
};
/**
 * The function memoize a series of function calls in a single pass,
 * it memoizes all the args and return in a single run of the callback function, and read it in the next round of execution
 * note: this is a memory opimized function which will only memoize one round of bulk calls
 * @param  fnToMemoize - the function needs to be bulk memorized and a key key paramter needs to be provided as cache id
 * @param  shouldCacheUpdate - the validate function for comparing 2 argument, return true when 2 args are equal
 * @returns callback function includes a series calls of memoizedFn, and each call will get cache result if args are the same(according to shouldCacheUpdate fn)
 * @example
 * ```ts
 * const items = [{id:1, value:3}];
 * const heavyFn = (_key, value) => { // key is not used in the function, but it is a cache id
 *   // assume this is a heavy caculation
 *   return value+1;
 * }
 *
 * const memoizeHeavyFnAll = memoizeFnAll(heavyFn);
 * const generateValueArray = (memoizedHeavyFn) => (
 *   items.map(item => {
 *     memoizedHeavyFn(item.id, item.value);
 *   })
 * );
 *
 * const result = memoizeHeavyFnAll(generateValueArray); // Cache: {}, nextCache: {1: 4 *new}, heavyFn call times: 1
 *
 * // Argument changed
 * items[0].value = 2
 * const result0 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 4}, nextCache: {1: 3 *new}, heavyFn call times: 1
 *
 * // Cache added
 * items.push({id:3, value:4});
 * const result1 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 3 *hit}, nextCache: {1: 3, 3: 5 *new}, heavyFn call times: 1
 *
 * // Cache removed
 * delete items[0];
 * const result2 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 3, 3: 5 *hit}, nextCache: {3: 5}, heavyFn call times: 0
 * ```
 *
 * @public
 */
const memoizeFnAll = (fnToMemoize, shouldCacheUpdate = Object.is) => {
    let cache = new Map();
    let nextCache = new Map();
    return (callback) => {
        const memoizedFn = (key, ...args) => {
            const value = cache.get(key);
            if (value) {
                const [preArgs, ret] = value;
                if (argsCmp(preArgs, args, shouldCacheUpdate)) {
                    nextCache.set(key, [args, ret]);
                    return ret;
                }
            }
            const ret = fnToMemoize(key, ...args);
            nextCache.set(key, [args, ret]);
            return ret;
        };
        const retValue = callback(memoizedFn);
        cache = nextCache;
        nextCache = new Map();
        return retValue;
    };
};

// Copyright (c) Microsoft Corporation.
const COMMUNICATION_USER_PREFIX = '8:acs:';
const PHONE_NUMBER_PREFIX = '4:';
const TEAMS_DOD_PREFIX = '8:dod:';
const TEAMS_GCCH_PREFIX = '8:gcch:';
const TEAMS_USER_PREFIX = '8:origid:';
const TEAMS_VISITOR_PREFIX = '8:teamsvisitor:';
/**
 * A string representation of a {@link @azure/communication-common#CommunicationIdentifier}.
 *
 * This string representation of CommunicationIdentifier is guaranteed to be stable for
 * a unique Communication user. Thus,
 * - it can be used to persist a user's identity in external databases.
 * - it can be used as keys into a Map to store data for the user.
 *
 * @public
 */
const toFlatCommunicationIdentifier = (identifier) => {
    if (communicationCommon.isCommunicationUserIdentifier(identifier)) {
        return identifier.communicationUserId;
    }
    if (communicationCommon.isMicrosoftTeamsUserIdentifier(identifier)) {
        if (identifier.isAnonymous) {
            return TEAMS_VISITOR_PREFIX + identifier.microsoftTeamsUserId;
        }
        if (identifier.cloud == 'dod') {
            return TEAMS_DOD_PREFIX + identifier.microsoftTeamsUserId;
        }
        if (identifier.cloud == 'gcch') {
            return TEAMS_GCCH_PREFIX + identifier.microsoftTeamsUserId;
        }
        return TEAMS_USER_PREFIX + identifier.microsoftTeamsUserId;
    }
    if (communicationCommon.isPhoneNumberIdentifier(identifier)) {
        return PHONE_NUMBER_PREFIX + identifier.phoneNumber;
    }
    return identifier.id;
};
/**
 * Reverse operation of {@link toFlatCommunicationIdentifier}.
 *
 * @public
 */
const fromFlatCommunicationIdentifier = (id) => {
    if (id.startsWith(COMMUNICATION_USER_PREFIX)) {
        // The prefix is preserved for this variant of the identifier.
        return { communicationUserId: id };
    }
    if (id.startsWith(PHONE_NUMBER_PREFIX)) {
        return { phoneNumber: id.substr(PHONE_NUMBER_PREFIX.length) };
    }
    if (id.startsWith(TEAMS_USER_PREFIX)) {
        return { microsoftTeamsUserId: id.substr(TEAMS_USER_PREFIX.length) };
    }
    if (id.startsWith(TEAMS_DOD_PREFIX)) {
        return { microsoftTeamsUserId: id.substr(TEAMS_DOD_PREFIX.length), cloud: 'dod' };
    }
    if (id.startsWith(TEAMS_GCCH_PREFIX)) {
        return { microsoftTeamsUserId: id.substr(TEAMS_GCCH_PREFIX.length), cloud: 'gcch' };
    }
    if (id.startsWith(TEAMS_VISITOR_PREFIX)) {
        return { microsoftTeamsUserId: id.substr(TEAMS_VISITOR_PREFIX.length), isAnonymous: true };
    }
    return { id };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// GENERATED FILE. DO NOT EDIT MANUALLY.
var telemetryVersion = '1.0.0';

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
// Removes long suffixes that don't fit the constraints for telemetry application ID.
// e.g., the build suffix is dropped for alpha package versions.
const sanitize = (version) => {
    const alphaIndex = version.search(/alpha/);
    if (alphaIndex >= 0) {
        return version.substring(0, alphaIndex + 5);
    }
    return version;
};
/**
 * Application ID to be included in telemetry data from the UI library.
 *
 * @internal
 */
const _getApplicationId = () => {
    const version = telemetryVersion;
    return sanitize(`acr/${version}`);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 *
 * Replace the pattern "\{\}" in str with the values passed in as vars
 *
 * @example
 * ```ts
 *   _formatString("hello {name}. '{name}' is a rare name.", {name: "Foo"});
 *   // returns "hello Foo. 'Foo' is a rare name."
 * ```
 * @param str - The string to be formatted
 * @param variables - Variables to use to format the string
 * @returns a formatted string
 */
const _formatString = (str, vars) => {
    if (!str) {
        return '';
    }
    if (!vars) {
        return str;
    }
    // regex to search for the pattern "\{\}"
    const placeholdersRegex = /{(\w+)}/g;
    return str.replace(placeholdersRegex, (_, k) => vars[k] || `{${k}}`);
};

/**
 * @private
 */
const getDeviceManager$1 = (state) => state.deviceManager;
/**
 * @private
 */
const getCallExists = (state, props) => !!state.calls[props.callId];
/**
 * @private
 */
const getDominantSpeakers = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.dominantSpeakers; };
/**
 * @private
 */
const getRemoteParticipants = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.remoteParticipants; };
/**
 * @private
 */
const getIsScreenSharingOn = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn; };
/**
 * @private
 */
const getIsMuted = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.isMuted; };
/**
 * @private
 */
const getLocalVideoStreams$1 = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.localVideoStreams; };
/**
 * @private
 */
const getScreenShareRemoteParticipant = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.screenShareRemoteParticipant; };
/**
 * @private
 */
const getDisplayName$1 = (state) => { var _a; return (_a = state.callAgent) === null || _a === void 0 ? void 0 : _a.displayName; };
/**
 * @private
 */
const getIdentifier = (state) => toFlatCommunicationIdentifier(state.userId);
/**
 * @private
 */
const getLatestErrors$1 = (state) => state.latestErrors;
/**
 * @private
 */
const getDiagnostics = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.diagnostics; };

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$l = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Check if the call state represents being in the call
 *
 * @internal
 */
const _isInCall = (callStatus) => !!callStatus && !['None', 'Disconnected', 'Connecting'].includes(callStatus);
/**
 * Check if the call state represents being in the lobby or waiting to be admitted.
 *
 * @internal
 */
const _isInLobbyOrConnecting = (callStatus) => !!callStatus && ['Connecting', 'Ringing', 'InLobby'].includes(callStatus);
/**
 * Check if the device manager local video is on when not part of a call
 * i.e. do unparented views exist.
 *
 * @internal
 */
const _isPreviewOn = (deviceManager) => {
    // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
    // handle cases where 'Preview' view is in progress and not necessary completed.
    return deviceManager.unparentedViews.length > 0 && deviceManager.unparentedViews[0].view !== undefined;
};
/**
 * Dispose of all preview views
 * We assume all unparented views are local preview views.
 *
 * @private
 */
const disposeAllLocalPreviewViews = (callClient) => __awaiter$l(void 0, void 0, void 0, function* () {
    const unparentedViews = callClient.getState().deviceManager.unparentedViews;
    for (const view of unparentedViews) {
        yield callClient.disposeView(undefined, undefined, view);
    }
});

// Copyright (c) Microsoft Corporation.
/**
 * Selector for {@link MicrophoneButton} component.
 *
 * @public
 */
const microphoneButtonSelector = reselect__namespace.createSelector([getCallExists, getIsMuted, getDeviceManager$1], (callExists, isMuted, deviceManager) => {
    const permission = deviceManager.deviceAccess ? deviceManager.deviceAccess.audio : true;
    return {
        disabled: !callExists || !permission,
        checked: callExists ? !isMuted : false
    };
});
/**
 * Selector for {@link CameraButton} component.
 *
 * @public
 */
const cameraButtonSelector = reselect__namespace.createSelector([getLocalVideoStreams$1, getDeviceManager$1], (localVideoStreams, deviceManager) => {
    const previewOn = _isPreviewOn(deviceManager);
    const localVideoFromCall = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find((stream) => stream.mediaStreamType === 'Video');
    const permission = deviceManager.deviceAccess ? deviceManager.deviceAccess.video : true;
    return {
        disabled: !deviceManager.selectedCamera || !permission,
        checked: localVideoStreams !== undefined && localVideoStreams.length > 0 ? !!localVideoFromCall : previewOn
    };
});
/**
 * Selector for {@link ScreenShareButton} component.
 *
 * @public
 */
const screenShareButtonSelector = reselect__namespace.createSelector([getIsScreenSharingOn], (isScreenSharingOn) => {
    return {
        checked: isScreenSharingOn
    };
});
/**
 * Selector for {@link DevicesButton} component.
 *
 * @public
 */
const devicesButtonSelector = reselect__namespace.createSelector([getDeviceManager$1], (deviceManager) => {
    return {
        microphones: deviceManager.microphones,
        speakers: deviceManager.speakers,
        cameras: deviceManager.cameras,
        selectedMicrophone: deviceManager.selectedMicrophone,
        selectedSpeaker: deviceManager.selectedSpeaker,
        selectedCamera: deviceManager.selectedCamera
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$k = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const areStreamsEqual = (prevStream, newStream) => {
    return !!prevStream && !!newStream && prevStream.source.id === newStream.source.id;
};
/**
 * Create the default implementation of {@link CallingHandlers}.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const createDefaultCallingHandlers = memoizeOne__default['default']((callClient, callAgent, deviceManager, call) => {
    const onStartLocalVideo = () => __awaiter$k(void 0, void 0, void 0, function* () {
        // Before the call object creates a stream, dispose of any local preview streams.
        // @TODO: is there any way to parent the unparented view to the call object instead
        // of disposing and creating a new stream?
        yield onDisposeLocalStreamView();
        const callId = call === null || call === void 0 ? void 0 : call.id;
        let videoDeviceInfo = callClient.getState().deviceManager.selectedCamera;
        if (!videoDeviceInfo) {
            const cameras = yield (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.getCameras());
            videoDeviceInfo = cameras && cameras.length > 0 ? cameras[0] : undefined;
            videoDeviceInfo && (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.selectCamera(videoDeviceInfo));
        }
        if (!callId || !videoDeviceInfo) {
            return;
        }
        const stream = new communicationCalling.LocalVideoStream(videoDeviceInfo);
        if (call && !call.localVideoStreams.find((s) => areStreamsEqual(s, stream))) {
            yield call.startVideo(stream);
        }
    });
    const onStopLocalVideo = (stream) => __awaiter$k(void 0, void 0, void 0, function* () {
        const callId = call === null || call === void 0 ? void 0 : call.id;
        if (!callId) {
            return;
        }
        if (call && call.localVideoStreams.find((s) => areStreamsEqual(s, stream))) {
            yield call.stopVideo(stream);
            yield callClient.disposeView(callId, undefined, {
                source: stream.source,
                mediaStreamType: stream.mediaStreamType
            });
        }
    });
    const onToggleCamera = (options) => __awaiter$k(void 0, void 0, void 0, function* () {
        if (call && _isInCall(call.state)) {
            const stream = call.localVideoStreams.find((stream) => stream.mediaStreamType === 'Video');
            if (stream) {
                yield onStopLocalVideo(stream);
            }
            else {
                yield onStartLocalVideo();
            }
        }
        else {
            const selectedCamera = callClient.getState().deviceManager.selectedCamera;
            if (selectedCamera) {
                const previewOn = _isPreviewOn(callClient.getState().deviceManager);
                if (previewOn) {
                    yield onDisposeLocalStreamView();
                }
                else {
                    yield callClient.createView(undefined, undefined, {
                        source: selectedCamera,
                        mediaStreamType: 'Video'
                    }, options);
                }
            }
        }
    });
    // FIXME: onStartCall API should use string, not the underlying SDK types.
    const onStartCall = (participants, options) => {
        return callAgent ? callAgent.startCall(participants, options) : undefined;
    };
    const onSelectMicrophone = (device) => __awaiter$k(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        return deviceManager.selectMicrophone(device);
    });
    const onSelectSpeaker = (device) => __awaiter$k(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        return deviceManager.selectSpeaker(device);
    });
    const onSelectCamera = (device, options) => __awaiter$k(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        if (call && _isInCall(call.state)) {
            deviceManager.selectCamera(device);
            const stream = call.localVideoStreams.find((stream) => stream.mediaStreamType === 'Video');
            return stream === null || stream === void 0 ? void 0 : stream.switchSource(device);
        }
        else {
            const previewOn = _isPreviewOn(callClient.getState().deviceManager);
            if (!previewOn) {
                deviceManager.selectCamera(device);
                return;
            }
            yield onDisposeLocalStreamView();
            deviceManager.selectCamera(device);
            yield callClient.createView(undefined, undefined, {
                source: device,
                mediaStreamType: 'Video'
            }, options);
        }
    });
    const onToggleMicrophone = () => __awaiter$k(void 0, void 0, void 0, function* () {
        if (!call || !_isInCall(call.state)) {
            throw new Error(`Please invoke onToggleMicrophone after call is started`);
        }
        return call.isMuted ? yield call.unmute() : yield call.mute();
    });
    const onStartScreenShare = () => __awaiter$k(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.startScreenSharing()); });
    const onStopScreenShare = () => __awaiter$k(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.stopScreenSharing()); });
    const onToggleScreenShare = () => __awaiter$k(void 0, void 0, void 0, function* () { return (call === null || call === void 0 ? void 0 : call.isScreenSharingOn) ? yield onStopScreenShare() : yield onStartScreenShare(); });
    const onHangUp = () => __awaiter$k(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.hangUp()); });
    const onCreateLocalStreamView = (options) => __awaiter$k(void 0, void 0, void 0, function* () {
        if (!call || call.localVideoStreams.length === 0) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            return;
        }
        const localStream = callState.localVideoStreams.find((item) => item.mediaStreamType === 'Video');
        if (!localStream) {
            return;
        }
        return callClient.createView(call.id, undefined, localStream, options);
    });
    const onCreateRemoteStreamView = (userId, options = { scalingMode: 'Crop' }) => __awaiter$k(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find((participant) => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        const remoteVideoStream = Object.values(participant.videoStreams).find((i) => i.mediaStreamType === 'Video');
        const screenShareStream = Object.values(participant.videoStreams).find((i) => i.mediaStreamType === 'ScreenSharing');
        if (remoteVideoStream && remoteVideoStream.isAvailable && !remoteVideoStream.view) {
            callClient.createView(call.id, participant.identifier, remoteVideoStream, options);
        }
        if (screenShareStream && screenShareStream.isAvailable && !screenShareStream.view) {
            // Hardcoded `scalingMode` since it is highly unlikely that CONTOSO would ever want to use a different scaling mode for screenshare.
            // Using `Crop` would crop the contents of screenshare and `Stretch` would warp it.
            // `Fit` is the only mode that maintains the integrity of the screen being shared.
            callClient.createView(call.id, participant.identifier, screenShareStream, { scalingMode: 'Fit' });
        }
    });
    const onDisposeRemoteStreamView = (userId) => __awaiter$k(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find((participant) => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        const remoteVideoStream = Object.values(participant.videoStreams).find((i) => i.mediaStreamType === 'Video');
        const screenShareStream = Object.values(participant.videoStreams).find((i) => i.mediaStreamType === 'ScreenSharing');
        if (remoteVideoStream && remoteVideoStream.view) {
            callClient.disposeView(call.id, participant.identifier, remoteVideoStream);
        }
        if (screenShareStream && screenShareStream.view) {
            callClient.disposeView(call.id, participant.identifier, screenShareStream);
        }
    });
    const onDisposeLocalStreamView = () => __awaiter$k(void 0, void 0, void 0, function* () {
        // TODO: we need to remember which LocalVideoStream was used for LocalPreview and dispose that one. For now
        // assume any unparented view is a LocalPreview and stop all since those are only used for LocalPreview
        // currently.
        yield disposeAllLocalPreviewViews(callClient);
    });
    const onRemoveParticipant = (userId) => __awaiter$k(void 0, void 0, void 0, function* () {
        yield (call === null || call === void 0 ? void 0 : call.removeParticipant(fromFlatCommunicationIdentifier(userId)));
    });
    return {
        onHangUp,
        onSelectCamera,
        onSelectMicrophone,
        onSelectSpeaker,
        onStartCall,
        onStartScreenShare,
        onStopScreenShare,
        onToggleCamera,
        onToggleMicrophone,
        onToggleScreenShare,
        onCreateLocalStreamView,
        onCreateRemoteStreamView,
        onRemoveParticipant,
        onStartLocalVideo,
        onDisposeRemoteStreamView,
        onDisposeLocalStreamView
    };
});
/**
 * Create a set of default handlers for given component. Memoization is applied to the result. Multiple invocations with
 * the same arguments will return the same handler instances. DeclarativeCallAgent, DeclarativeDeviceManager, and
 * DeclarativeCall may be undefined. If undefined, their associated handlers will not be created and returned.
 *
 * @param callClient - StatefulCallClient returned from
 *   {@link @azure/communication-react#createStatefulCallClient}.
 * @param callAgent - Instance of {@link @azure/communication-calling#CallClient}.
 * @param deviceManager - Instance of {@link @azure/communication-calling#DeviceManager}.
 * @param call - Instance of {@link @azure/communication-calling#Call}.
 * @param _ - React component that you want to generate handlers for.
 *
 * @public
 */
const createDefaultCallingHandlersForComponent = (callClient, callAgent, deviceManager, call, _Component) => {
    return createDefaultCallingHandlers(callClient, callAgent, deviceManager, call);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallAgentContext = React.createContext(undefined);
const CallAgentProviderBase = (props) => {
    const { callAgent } = props;
    const initialState = {
        callAgent
    };
    return React__default['default'].createElement(CallAgentContext.Provider, { value: initialState }, props.children);
};
/**
 * A {@link React.Context} that stores a {@link @azure/communication-calling#CallAgent}.
 *
 * Calling components from this package must be wrapped with a {@link CallAgentProvider}.
 *
 * @public
 */
const CallAgentProvider = (props) => React__default['default'].createElement(CallAgentProviderBase, Object.assign({}, props));
/**
 * Hook to obtain {@link @azure/communication-calling#CallAgent} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useCallAgent = () => { var _a; return (_a = React.useContext(CallAgentContext)) === null || _a === void 0 ? void 0 : _a.callAgent; };

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallClientContext = React.createContext(undefined);
/**
 * @private
 */
const CallClientProviderBase = (props) => {
    const { callClient } = props;
    const [deviceManager, setDeviceManager] = React.useState(undefined);
    /**
     * Initialize the DeviceManager inside CallClientState
     */
    React.useEffect(() => {
        callClient
            .getDeviceManager()
            .then((manager) => {
            manager.getCameras();
            manager.getMicrophones();
            manager.getSpeakers();
            setDeviceManager(manager);
        })
            .catch((error) => {
            throw new Error(error);
        });
    }, [callClient]);
    const initialState = {
        callClient,
        deviceManager
    };
    return React__default['default'].createElement(CallClientContext.Provider, { value: initialState }, props.children);
};
/**
 * A {@link React.Context} that stores a {@link StatefulCallClient}.
 *
 * Calling components from this package must be wrapped with a {@link CallClientProvider}.
 *
 * @public
 */
const CallClientProvider = (props) => (React__default['default'].createElement(CallClientProviderBase, Object.assign({}, props)));
/**
 * Hook to obtain {@link StatefulCallClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useCallClient = () => {
    const context = React.useContext(CallClientContext);
    if (context === undefined) {
        throw new Error('CallClient Context is undefined');
    }
    return context.callClient;
};
/**
 * Hook to obtain {@link StatefulDeviceManager} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useDeviceManager = () => {
    var _a;
    return (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.deviceManager;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallContext$2 = React.createContext(undefined);
/**
 * @private
 */
const CallProviderBase = (props) => {
    const { children, call } = props;
    const initialState = {
        call
    };
    return React__default['default'].createElement(CallContext$2.Provider, { value: initialState }, children);
};
/**
 * A {@link React.Context} that stores a {@link @azure/communication-calling#Call}.
 *
 * Calling components from this package must be wrapped with a {@link CallProvider}.
 *
 * @public
 */
const CallProvider = (props) => React__default['default'].createElement(CallProviderBase, Object.assign({}, props));
/**
 * Hook to obtain {@link @azure/communication-calling#Call} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useCall = () => {
    var _a;
    return (_a = React.useContext(CallContext$2)) === null || _a === void 0 ? void 0 : _a.call;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const typingIndicatorContainerStyle = react.mergeStyles({
    minHeight: '2.125rem'
});
/**
 * @private
 */
const typingIndicatorStringStyle = react.mergeStyles({
    fontWeight: 400,
    width: '100%',
    alignSelf: 'center',
    wordBreak: 'break-word'
});

var participantItem$d={isMeText:"(you)",menuTitle:"More Options",removeButtonLabel:"Remove",sharingIconLabel:"Sharing",mutedIconLabel:"Muted"};var typingIndicator$d={singleUser:"{user} is typing ...",multipleUsers:"{users} are typing ...",multipleUsersAbbreviateOne:"{users} and 1 other are typing ...",multipleUsersAbbreviateMany:"{users} and {numOthers} others are typing ...",delimiter:", "};var sendBox$d={placeholderText:"Enter a message",textTooLong:"Your message length is over the maximum limit."};var messageStatusIndicator$d={deliveredTooltipText:"Sent",seenTooltipText:"Seen",sendingTooltipText:"Sending",failedToSendTooltipText:"Failed to send"};var endCallButton$d={label:"Leave",tooltipContent:"Leave Call"};var cameraButton$d={onLabel:"Turn off",offLabel:"Turn on",tooltipDisabledContent:"Camera is disabled",tooltipOnContent:"Turn off camera",tooltipOffContent:"Turn on camera"};var microphoneButton$d={onLabel:"Mute",offLabel:"Unmute",tooltipDisabledContent:"Microphone is disabled",tooltipOnContent:"Mute microphone",tooltipOffContent:"Unmute microphone"};var devicesButton$d={label:"Devices",tooltipContent:"Manage devices",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose Camera",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose Microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose Speaker"};var participantsButton$d={label:"People",tooltipContent:"Show Participants",menuHeader:"In this call",participantsListButtonLabel:"{numParticipants} people",muteAllButtonLabel:"Mute all",copyInviteLinkButtonLabel:"Copy invite link"};var screenShareButton$d={onLabel:"Stop sharing",offLabel:"Share",tooltipDisabledContent:"Screen sharing is disabled",tooltipOnContent:"Stop sharing your screen",tooltipOffContent:"Share your screen"};var messageThread$d={yesterday:"Yesterday",sunday:"Sunday",monday:"Monday",tuesday:"Tuesday",wednesday:"Wednesday",thursday:"Thursday",friday:"Friday",saturday:"Saturday",participantJoined:"joined the chat.",participantLeft:"left the chat.",editMessage:"Edit",removeMessage:"Remove",editedTag:"Edited",liveAuthorIntro:"{author} says",editBoxTextLimit:"Your message is over the limit of {limitNumber} characters",editBoxPlaceholderText:"Edit your message",newMessagesIndicator:"New messages",noDisplayNameSub:"No name",editBoxCancelButton:"Cancel",editBoxSubmitButton:"Submit"};var errorBar$d={unableToReachChatService:"You are offline",accessDenied:"Unable to access chat services - please check the user credentials provided",userNotInChatThread:"You are no longer in this chat thread",sendMessageNotInChatThread:"Failed to send message because you are no longer in this chat thread",sendMessageGeneric:"Failed to send message",callingNetworkFailure:"Troubling connecting call - you seem to be offline",startVideoGeneric:"Failed to start video",stopVideoGeneric:"Failed to stop video",muteGeneric:"Failed to mute microphone",unmuteGeneric:"Failed to unmute microphone",speakingWhileMuted:"Your microphone is muted",startScreenShareGeneric:"Failed to start screen sharing",stopScreenShareGeneric:"Failed to stop screen sharing",callNetworkQualityLow:"Network quality is low.",callNoSpeakerFound:"No speakers or headphones found. Connect an audio device to hear the call.",callNoMicrophoneFound:"No microphones found. Connect an audio input device.",callMicrophoneAccessDenied:"Unable to access microphone. Click the lock in the address bar to grant permission to this webpage.",callMicrophoneMutedBySystem:"You are muted by your system.",callMacOsMicrophoneAccessDenied:"Unable to access microphone. Grant microphone permission in your macOS privacy settings.",callLocalVideoFreeze:"Network bandwidth is poor. Your video may appear paused for others on the call.",callCameraAccessDenied:"Unable to access camera. Click the lock in the address bar to grant permission to this webpage.",callCameraAlreadyInUse:"Unable to access camera. It may already be in use by another application.",callMacOsCameraAccessDenied:"MacOS is blocking access to your camera. Update your privacy settings to allow this browser to access your camera.",callMacOsScreenShareAccessDenied:"MacOS is blocking screen sharing. Update your privacy settings to allow this browser to record your screen."};var videoGallery$d={screenIsBeingSharedMessage:"You are sharing your screen",screenShareLoadingMessage:"Loading {participant}'s screen",localVideoLabel:"You"};var en_US$1 = {participantItem:participantItem$d,typingIndicator:typingIndicator$d,sendBox:sendBox$d,messageStatusIndicator:messageStatusIndicator$d,endCallButton:endCallButton$d,cameraButton:cameraButton$d,microphoneButton:microphoneButton$d,devicesButton:devicesButton$d,participantsButton:participantsButton$d,screenShareButton:screenShareButton$d,messageThread:messageThread$d,errorBar:errorBar$d,videoGallery:videoGallery$d};

var participantItem$c={isMeText:"(you)",menuTitle:"More Options",removeButtonLabel:"Remove",sharingIconLabel:"Sharing",mutedIconLabel:"Muted"};var typingIndicator$c={singleUser:"{user} is typing ...",multipleUsers:"{users} are typing ...",multipleUsersAbbreviateOne:"{users} and 1 other are typing ...",multipleUsersAbbreviateMany:"{users} and {numOthers} others are typing ...",delimiter:", "};var sendBox$c={placeholderText:"Enter a message",textTooLong:"Your message length is over the maximum limit."};var messageStatusIndicator$c={deliveredTooltipText:"Sent",seenTooltipText:"Seen",sendingTooltipText:"Sending",failedToSendTooltipText:"Failed to send"};var endCallButton$c={label:"Leave",tooltipContent:"Leave Call"};var cameraButton$c={onLabel:"Turn off",offLabel:"Turn on",tooltipDisabledContent:"Camera is disabled",tooltipOnContent:"Turn off camera",tooltipOffContent:"Turn on camera"};var microphoneButton$c={onLabel:"Mute",offLabel:"Unmute",tooltipDisabledContent:"Microphone is disabled",tooltipOnContent:"Mute microphone",tooltipOffContent:"Unmute microphone"};var devicesButton$c={label:"Devices",tooltipContent:"Manage devices",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose Camera",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose Microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose Speaker"};var participantsButton$c={label:"People",tooltipContent:"Show Participants",menuHeader:"In this call",participantsListButtonLabel:"{numParticipants} people",muteAllButtonLabel:"Mute all",copyInviteLinkButtonLabel:"Copy invite link"};var screenShareButton$c={onLabel:"Stop sharing",offLabel:"Share",tooltipDisabledContent:"Screen sharing is disabled",tooltipOnContent:"Stop sharing your screen",tooltipOffContent:"Share your screen"};var messageThread$c={yesterday:"Yesterday",sunday:"Sunday",monday:"Monday",tuesday:"Tuesday",wednesday:"Wednesday",thursday:"Thursday",friday:"Friday",saturday:"Saturday",participantJoined:"joined the chat.",participantLeft:"left the chat.",editMessage:"Edit",removeMessage:"Remove",editedTag:"Edited",liveAuthorIntro:"{author} says",editBoxTextLimit:"Your message is over the limit of {limitNumber} characters",editBoxPlaceholderText:"Edit your message",newMessagesIndicator:"New messages",noDisplayNameSub:"No name",editBoxCancelButton:"Cancel",editBoxSubmitButton:"Submit"};var errorBar$c={unableToReachChatService:"You are offline",accessDenied:"Unable to access chat services - please check the user credentials provided",userNotInChatThread:"You are no longer in this chat thread",sendMessageNotInChatThread:"Failed to send message because you are no longer in this chat thread",sendMessageGeneric:"Failed to send message",callingNetworkFailure:"Troubling connecting call - you seem to be offline",startVideoGeneric:"Failed to start video",stopVideoGeneric:"Failed to stop video",muteGeneric:"Failed to mute microphone",unmuteGeneric:"Failed to unmute microphone",speakingWhileMuted:"Your microphone is muted",startScreenShareGeneric:"Failed to start screen sharing",stopScreenShareGeneric:"Failed to stop screen sharing",callNetworkQualityLow:"Network quality is low.",callNoSpeakerFound:"No speakers or headphones found. Connect an audio device to hear the call.",callNoMicrophoneFound:"No microphones found. Connect an audio input device.",callMicrophoneAccessDenied:"Unable to access microphone. Click the lock in the address bar to grant permission to this webpage.",callMicrophoneMutedBySystem:"You are muted by your system.",callMacOsMicrophoneAccessDenied:"Unable to access microphone. Grant microphone permission in your macOS privacy settings.",callLocalVideoFreeze:"Network bandwidth is poor. Your video may appear paused for others on the call.",callCameraAccessDenied:"Unable to access camera. Click the lock in the address bar to grant permission to this webpage.",callCameraAlreadyInUse:"Unable to access camera. It may already be in use by another application.",callMacOsCameraAccessDenied:"MacOS is blocking access to your camera. Update your privacy settings to allow this browser to access your camera.",callMacOsScreenShareAccessDenied:"MacOS is blocking screen sharing. Update your privacy settings to allow this browser to record your screen."};var videoGallery$c={screenIsBeingSharedMessage:"You are sharing your screen",screenShareLoadingMessage:"Loading {participant}'s screen",localVideoLabel:"You"};var en_GB$1 = {participantItem:participantItem$c,typingIndicator:typingIndicator$c,sendBox:sendBox$c,messageStatusIndicator:messageStatusIndicator$c,endCallButton:endCallButton$c,cameraButton:cameraButton$c,microphoneButton:microphoneButton$c,devicesButton:devicesButton$c,participantsButton:participantsButton$c,screenShareButton:screenShareButton$c,messageThread:messageThread$c,errorBar:errorBar$c,videoGallery:videoGallery$c};

var participantItem$b={isMeText:"(Sie)",menuTitle:"Weitere Optionen",removeButtonLabel:"Entfernen",sharingIconLabel:"Teilen",mutedIconLabel:"Stumm geschaltet"};var typingIndicator$b={singleUser:"{user} schreibt ...",multipleUsers:"{users} schreiben ...",multipleUsersAbbreviateOne:"{users} und 1 andere Person schreiben ...",multipleUsersAbbreviateMany:"{users} und {numOthers} andere schreiben ...",delimiter:", "};var sendBox$b={placeholderText:"Nachricht eingeben",textTooLong:"Ihre Nachrichtenlänge überschreitet den maximalen Grenzwert."};var messageStatusIndicator$b={deliveredTooltipText:"Gesendet",seenTooltipText:"Gesehen",sendingTooltipText:"Wird gesendet",failedToSendTooltipText:"Fehler beim Senden"};var endCallButton$b={label:"Verlassen",tooltipContent:"Anruf verlassen"};var cameraButton$b={onLabel:"Deaktivieren",offLabel:"Aktivieren",tooltipDisabledContent:"Kamera ist deaktiviert",tooltipOnContent:"Kamera ausschalten",tooltipOffContent:"Kamera einschalten"};var microphoneButton$b={onLabel:"Stumm schalten",offLabel:"Stummschaltung aufheben",tooltipDisabledContent:"Mikrofon ist deaktiviert",tooltipOnContent:"Mikrofon stummschalten",tooltipOffContent:"Mikrofonstummschaltung aufheben"};var devicesButton$b={label:"Geräte",tooltipContent:"Geräte verwalten",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera auswählen",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon auswählen",speakerMenuTitle:"Lautsprecher",speakerMenuTooltip:"Lautsprecher auswählen"};var participantsButton$b={label:"Personen",tooltipContent:"Teilnehmer anzeigen",menuHeader:"In diesem Anruf",participantsListButtonLabel:"{numParticipants} Personen",muteAllButtonLabel:"Alle stumm schalten",copyInviteLinkButtonLabel:"Einladungslink kopieren"};var screenShareButton$b={onLabel:"Nicht mehr teilen",offLabel:"Teilen",tooltipDisabledContent:"Bildschirmfreigabe ist deaktiviert",tooltipOnContent:"Freigabe Ihres Bildschirms beenden",tooltipOffContent:"Ihren Bildschirm freigeben"};var messageThread$b={yesterday:"Gestern",sunday:"Sonntag",monday:"Montag",tuesday:"Dienstag",wednesday:"Mittwoch",thursday:"Donnerstag",friday:"Freitag",saturday:"Samstag",participantJoined:"ist dem Chat beigetreten.",participantLeft:"hat den Chat verlassen.",editMessage:"Bearbeiten",removeMessage:"Entfernen",editedTag:"Bearbeitet",liveAuthorIntro:"{author} sagt",editBoxTextLimit:"Ihre Nachricht überschreitet das Limit von {limitNumber} Zeichen.",editBoxPlaceholderText:"Bearbeiten Sie Ihre Nachricht",newMessagesIndicator:"Neue Nachrichten",noDisplayNameSub:"Kein Name",editBoxCancelButton:"Abbrechen",editBoxSubmitButton:"Übermitteln"};var errorBar$b={unableToReachChatService:"Sie sind offline.",accessDenied:"Auf die Chatdienste kann nicht zugegriffen werden. Überprüfen Sie die angegebenen Benutzeranmeldeinformationen.",userNotInChatThread:"Sie sind nicht mehr in diesem Chatthread vertreten.",sendMessageNotInChatThread:"Fehler beim Senden der Nachricht, weil Sie sich nicht mehr in diesem Chatthread befinden.",sendMessageGeneric:"Fehler beim Senden der Nachricht",callingNetworkFailure:"Problematische Anrufverbindung – Sie scheinen offline zu sein",startVideoGeneric:"Video konnte nicht gestartet werden",stopVideoGeneric:"Video konnte nicht beendet werden",muteGeneric:"Mikrofon konnte nicht stummgeschaltet werden",unmuteGeneric:"Stummschaltung des Mikrofons konnte nicht beendet werden",speakingWhileMuted:"Ihr Mikrofon ist stummgeschaltet",startScreenShareGeneric:"Bildschirmfreigabe konnte nicht gestartet werden",stopScreenShareGeneric:"Bildschirmfreigabe konnte nicht beendet werden",callNetworkQualityLow:"Die Netzwerkqualität ist niedrig.",callNoSpeakerFound:"Keine Lautsprecher oder Kopfhörer gefunden. Schließen Sie ein Audiogerät an, um den Anruf zu hören.",callNoMicrophoneFound:"Es wurden keine Mikrofone gefunden. Schließen Sie ein Audioeingabegerät an.",callMicrophoneAccessDenied:"Auf das Mikrofon kann nicht zugegriffen werden. Klicken Sie auf die Sperre in der Adressleiste, um dieser Webseite Berechtigungen zu erteilen.",callMicrophoneMutedBySystem:"Sie werden von Ihrem System stummgeschaltet.",callMacOsMicrophoneAccessDenied:"Auf das Mikrofon kann nicht zugegriffen werden. Erteilen Sie die Mikrofonberechtigung in Ihren macOS-Datenschutzeinstellungen.",callLocalVideoFreeze:"Die Netzwerkbandbreite ist schlecht. Ihr Video wird möglicherweise für andere Personen während des Anrufs angehalten angezeigt.",callCameraAccessDenied:"Auf die Kamera kann nicht zugegriffen werden. Klicken Sie auf die Sperre in der Adressleiste, um dieser Webseite Berechtigungen zu erteilen.",callCameraAlreadyInUse:"Auf die Kamera kann nicht zugegriffen werden. Sie wird möglicherweise bereits von einer anderen Anwendung verwendet.",callMacOsCameraAccessDenied:"MacOS blockiert den Zugriff auf Ihre Kamera. Aktualisieren Sie Ihre Datenschutzeinstellungen, damit dieser Browser auf Ihre Kamera zugreifen kann.",callMacOsScreenShareAccessDenied:"MacOS blockiert die Bildschirmfreigabe. Aktualisieren Sie Ihre Datenschutzeinstellungen, damit dieser Browser Ihren Bildschirm aufzeichnen kann."};var videoGallery$b={screenIsBeingSharedMessage:"Sie teilen Ihren Bildschirm",screenShareLoadingMessage:"Der Bildschirm von {participant} wird geladen",localVideoLabel:"Sie"};var de_DE$1 = {participantItem:participantItem$b,typingIndicator:typingIndicator$b,sendBox:sendBox$b,messageStatusIndicator:messageStatusIndicator$b,endCallButton:endCallButton$b,cameraButton:cameraButton$b,microphoneButton:microphoneButton$b,devicesButton:devicesButton$b,participantsButton:participantsButton$b,screenShareButton:screenShareButton$b,messageThread:messageThread$b,errorBar:errorBar$b,videoGallery:videoGallery$b};

var participantItem$a={isMeText:"(tú)",menuTitle:"Más opciones",removeButtonLabel:"Quitar",sharingIconLabel:"Compartiendo",mutedIconLabel:"Silenciado"};var typingIndicator$a={singleUser:"{user} está escribiendo...",multipleUsers:"{users} están escribiendo...",multipleUsersAbbreviateOne:"{users} y 1 usuario más están escribiendo...",multipleUsersAbbreviateMany:"{users} y {numOthers} usuarios más están escribiendo...",delimiter:", "};var sendBox$a={placeholderText:"Escribir un mensaje",textTooLong:"La longitud del mensaje supera el límite máximo."};var messageStatusIndicator$a={deliveredTooltipText:"Enviado",seenTooltipText:"Visto",sendingTooltipText:"Enviando",failedToSendTooltipText:"Error al enviar"};var endCallButton$a={label:"Baja",tooltipContent:"Abandonar llamada"};var cameraButton$a={onLabel:"Desactivar",offLabel:"Activar",tooltipDisabledContent:"La cámara está deshabilitada",tooltipOnContent:"Desconectar la cámara",tooltipOffContent:"Activar la cámara"};var microphoneButton$a={onLabel:"Silenciar",offLabel:"Reactivar audio",tooltipDisabledContent:"El micrófono está deshabilitado",tooltipOnContent:"Silenciar micrófono",tooltipOffContent:"Reactivar micrófono"};var devicesButton$a={label:"Dispositivos",tooltipContent:"Administrar dispositivos",cameraMenuTitle:"Cámara",cameraMenuTooltip:"Elegir cámara",microphoneMenuTitle:"Micrófono",microphoneMenuTooltip:"Elegir micrófono",speakerMenuTitle:"Altavoz",speakerMenuTooltip:"Elegir altavoz"};var participantsButton$a={label:"Contactos",tooltipContent:"Mostrar participantes",menuHeader:"En esta llamada",participantsListButtonLabel:"{numParticipants} personas",muteAllButtonLabel:"Silenciar a todos",copyInviteLinkButtonLabel:"Copiar vínculo de invitación"};var screenShareButton$a={onLabel:"Dejar de compartir",offLabel:"Compartir",tooltipDisabledContent:"El uso compartido de pantalla está deshabilitado",tooltipOnContent:"Dejar de compartir la pantalla",tooltipOffContent:"Compartir la pantalla"};var messageThread$a={yesterday:"Ayer",sunday:"Domingo",monday:"Lunes",tuesday:"Martes",wednesday:"Miércoles",thursday:"Jueves",friday:"Viernes",saturday:"Sábado",participantJoined:"se unió al chat.",participantLeft:"abandonó el chat.",editMessage:"Editar",removeMessage:"Quitar",editedTag:"Editado",liveAuthorIntro:"{author} dice",editBoxTextLimit:"El mensaje supera el límite de {limitNumber} caracteres",editBoxPlaceholderText:"Editar el mensaje",newMessagesIndicator:"Mensajes nuevos",noDisplayNameSub:"Sin nombre",editBoxCancelButton:"Cancelar",editBoxSubmitButton:"Enviar"};var errorBar$a={unableToReachChatService:"Sin conexión",accessDenied:"No se puede acceder a los servicios de chat. Compruebe las credenciales de usuario proporcionadas.",userNotInChatThread:"Ya no está en este hilo de chat",sendMessageNotInChatThread:"No se pudo enviar el mensaje porque ya no está en este hilo de chat",sendMessageGeneric:"Error al enviar el mensaje",callingNetworkFailure:"Problema al conectar la llamada; parece que no hay conexión",startVideoGeneric:"No se pudo iniciar el vídeo",stopVideoGeneric:"No se pudo detener el vídeo",muteGeneric:"No se pudo silenciar el micrófono",unmuteGeneric:"No se pudo reactivar el micrófono",speakingWhileMuted:"El micrófono está desactivado",startScreenShareGeneric:"No se pudo iniciar la pantalla compartida",stopScreenShareGeneric:"No se pudo detener la pantalla compartida",callNetworkQualityLow:"La calidad de la red es baja.",callNoSpeakerFound:"No se encontraron altavoces ni auriculares. Conecta un dispositivo de audio para escuchar la llamada.",callNoMicrophoneFound:"No se encontraron micrófonos. Conecta un dispositivo de entrada de audio.",callMicrophoneAccessDenied:"No se puede acceder al micrófono. Haga clic en el bloqueo de la barra de direcciones para conceder permiso a esta página web.",callMicrophoneMutedBySystem:"Su sistema ha silenciado su audio.",callMacOsMicrophoneAccessDenied:"No se puede acceder al micrófono. Conceda permiso al micrófono en la configuración de privacidad de macOS.",callLocalVideoFreeze:"El ancho de banda de red es deficiente. Es posible que el vídeo aparezca pausado para otros usuarios en la llamada.",callCameraAccessDenied:"No se puede acceder a la cámara. Haga clic en el bloqueo de la barra de direcciones para conceder permiso a esta página web.",callCameraAlreadyInUse:"No se puede acceder a la cámara. Puede que ya la esté usando otra aplicación.",callMacOsCameraAccessDenied:"MacOS está bloqueando el acceso a la cámara. Actualiza la configuración de privacidad para permitir que este explorador acceda a la cámara.",callMacOsScreenShareAccessDenied:"MacOS está bloqueando el uso compartido de la pantalla. Actualice la configuración de privacidad para permitir que este explorador grabe la pantalla."};var videoGallery$a={screenIsBeingSharedMessage:"Está compartiendo su pantalla",screenShareLoadingMessage:"Cargando la pantalla de {participant}",localVideoLabel:"Tú"};var es_ES$1 = {participantItem:participantItem$a,typingIndicator:typingIndicator$a,sendBox:sendBox$a,messageStatusIndicator:messageStatusIndicator$a,endCallButton:endCallButton$a,cameraButton:cameraButton$a,microphoneButton:microphoneButton$a,devicesButton:devicesButton$a,participantsButton:participantsButton$a,screenShareButton:screenShareButton$a,messageThread:messageThread$a,errorBar:errorBar$a,videoGallery:videoGallery$a};

var participantItem$9={isMeText:"(vous)",menuTitle:"Plus d’options",removeButtonLabel:"Supprimer",sharingIconLabel:"Partage",mutedIconLabel:"Muet activé"};var typingIndicator$9={singleUser:"{user} en train d’écrire...",multipleUsers:"{users} sont en train d'écrire...",multipleUsersAbbreviateOne:"{users} et 1 autre en train d'écrire...",multipleUsersAbbreviateMany:"{users} et {numOthers} autres en train d’écrire...",delimiter:", "};var sendBox$9={placeholderText:"Saisir un message",textTooLong:"La longueur de votre message dépasse la limite maximale."};var messageStatusIndicator$9={deliveredTooltipText:"Envoyé",seenTooltipText:"Vu",sendingTooltipText:"Envoi",failedToSendTooltipText:"Échec de l'envoi"};var endCallButton$9={label:"Quitter",tooltipContent:"Quitter l’appel"};var cameraButton$9={onLabel:"Désactiver",offLabel:"Activer",tooltipDisabledContent:"La caméra est désactivée.",tooltipOnContent:"Désactiver la caméra",tooltipOffContent:"Activer la caméra"};var microphoneButton$9={onLabel:"Désactiver le son",offLabel:"Réactiver le son",tooltipDisabledContent:"Le microphone est désactivé.",tooltipOnContent:"Désactiver le micro",tooltipOffContent:"Activer le micro"};var devicesButton$9={label:"Appareils",tooltipContent:"Gérer les appareils",cameraMenuTitle:"Appareil photo",cameraMenuTooltip:"Choisir une caméra",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choisir le micro",speakerMenuTitle:"Haut-parleur",speakerMenuTooltip:"Choisir une enceinte"};var participantsButton$9={label:"Personnes",tooltipContent:"Afficher les participants",menuHeader:"Pendant cet appel",participantsListButtonLabel:"{numParticipants} contacts",muteAllButtonLabel:"Désactiver tous les micros",copyInviteLinkButtonLabel:"Copier le lien d'invitation"};var screenShareButton$9={onLabel:"Arrêter le partage",offLabel:"Partager",tooltipDisabledContent:"Le partage de vidéo est désactivé.",tooltipOnContent:"Cesser le partage de votre écran",tooltipOffContent:"Partager votre écran"};var messageThread$9={yesterday:"Hier",sunday:"Dimanche",monday:"Lundi",tuesday:"Mardi",wednesday:"Mercredi",thursday:"Jeudi",friday:"Vendredi",saturday:"Samedi",participantJoined:"a rejoint la conversation.",participantLeft:"a quitté le conversation.",editMessage:"Modifier",removeMessage:"Supprimer",editedTag:"Modifié",liveAuthorIntro:"{author} dit",editBoxTextLimit:"Votre message dépasse la limite de {limitNumber} caractères",editBoxPlaceholderText:"Modifier votre message",newMessagesIndicator:"Nouveaux messages",noDisplayNameSub:"Sans nom",editBoxCancelButton:"Annuler",editBoxSubmitButton:"Envoyer"};var errorBar$9={unableToReachChatService:"Vous êtes hors connexion",accessDenied:"Impossible d’accéder aux services de conversation. Vérifiez les informations d’identification de l’utilisateur fournies",userNotInChatThread:"Vous n’est plus dans ce thread de conversation",sendMessageNotInChatThread:"Échec de l’envoi du message car vous n’êtes plus dans ce thread de conversation",sendMessageGeneric:"Échec de l’envoi du message",callingNetworkFailure:"Perturbation de l’appel de connexion : vous semblez être hors connexion",startVideoGeneric:"Échec du démarrage de la vidéo",stopVideoGeneric:"Échec de l’arrêt de la vidéo",muteGeneric:"Échec de la désactivation du son du microphone",unmuteGeneric:"Échec de l’activation du son du microphone",speakingWhileMuted:"Votre micro est désactivé",startScreenShareGeneric:"Échec du démarrage du partage d’écran",stopScreenShareGeneric:"Échec de l’arrêt du partage d’écran",callNetworkQualityLow:"La qualité de réseau est faible.",callNoSpeakerFound:"Aucun haut-parleur ou casque n’a été trouvé. Connectez un périphérique audio pour entendre l’appel.",callNoMicrophoneFound:"Aucun micro n’a été trouvé. Connectez un périphérique d’entrée audio.",callMicrophoneAccessDenied:"Impossible d’accéder au microphone. Cliquez sur le verrou dans la barre d’adresses pour accorder l’autorisation à cette page Web.",callMicrophoneMutedBySystem:"Votre micro est désactivé par votre système.",callMacOsMicrophoneAccessDenied:"Impossible d’accéder au microphone. Accordez l’autorisation de microphone dans vos paramètres de confidentialité macOS.",callLocalVideoFreeze:"La bande passante réseau est médiocre. Votre vidéo peut apparaître suspendue pour les autres participants à l’appel.",callCameraAccessDenied:"Impossible d’accéder à la caméra. Cliquez sur le verrou dans la barre d’adresses pour accorder l’autorisation à cette page Web.",callCameraAlreadyInUse:"Impossible d’accéder à la caméra. Il est peut-être déjà utilisé par une autre application.",callMacOsCameraAccessDenied:"MacOS bloque l’accès à votre caméra. Mettez à jour vos paramètres de confidentialité pour autoriser ce navigateur à accéder à votre caméra.",callMacOsScreenShareAccessDenied:"MacOS bloque le partage d’écran. Mettez à jour vos paramètres de confidentialité pour permettre à ce navigateur d’enregistrer votre écran."};var videoGallery$9={screenIsBeingSharedMessage:"Vous partagez votre écran.",screenShareLoadingMessage:"Chargement de l’écran de {participant}",localVideoLabel:"Vous"};var fr_FR$1 = {participantItem:participantItem$9,typingIndicator:typingIndicator$9,sendBox:sendBox$9,messageStatusIndicator:messageStatusIndicator$9,endCallButton:endCallButton$9,cameraButton:cameraButton$9,microphoneButton:microphoneButton$9,devicesButton:devicesButton$9,participantsButton:participantsButton$9,screenShareButton:screenShareButton$9,messageThread:messageThread$9,errorBar:errorBar$9,videoGallery:videoGallery$9};

var participantItem$8={isMeText:"(tu)",menuTitle:"Altre opzioni",removeButtonLabel:"Rimuovi",sharingIconLabel:"Condivisione",mutedIconLabel:"Disattivato"};var typingIndicator$8={singleUser:"{user} sta scrivendo ...",multipleUsers:"{users} stanno scrivendo ...",multipleUsersAbbreviateOne:"{users} e 1 altro stanno scrivendo ...",multipleUsersAbbreviateMany:"{users} e {numOthers} altri stanno scrivendo ...",delimiter:", "};var sendBox$8={placeholderText:"Immetti un messaggio",textTooLong:"La lunghezza del messaggio supera il limite massimo."};var messageStatusIndicator$8={deliveredTooltipText:"Inviato",seenTooltipText:"Visualizzato",sendingTooltipText:"Invio in corso",failedToSendTooltipText:"Invio non riuscito"};var endCallButton$8={label:"Permesso",tooltipContent:"Abbandona chiamata"};var cameraButton$8={onLabel:"Disabilita",offLabel:"Abilita",tooltipDisabledContent:"La videocamera è disabilitata",tooltipOnContent:"Spegni la videocamera",tooltipOffContent:"Accendi la videocamera"};var microphoneButton$8={onLabel:"Disattiva audio",offLabel:"Riattiva audio",tooltipDisabledContent:"Il microfono è disabilitato",tooltipOnContent:"Disattiva microfono",tooltipOffContent:"Riattiva microfono"};var devicesButton$8={label:"Dispositivi",tooltipContent:"Gestisci dispositivi",cameraMenuTitle:"Fotocamera",cameraMenuTooltip:"Scegli la fotocamera",microphoneMenuTitle:"Microfono",microphoneMenuTooltip:"Scegli il microfono",speakerMenuTitle:"Altoparlante",speakerMenuTooltip:"Scegli l’altoparlante"};var participantsButton$8={label:"Persone",tooltipContent:"Mostra partecipanti",menuHeader:"In questa chiamata",participantsListButtonLabel:"{numParticipants} persone",muteAllButtonLabel:"Disattiva l'audio di tutti",copyInviteLinkButtonLabel:"Copia il collegamento dell’invito"};var screenShareButton$8={onLabel:"Interrompi condivisione",offLabel:"Condividi",tooltipDisabledContent:"La condivisione del video è disabilitata",tooltipOnContent:"Interrompi condivisione dello schermo",tooltipOffContent:"Condividi lo schermo"};var messageThread$8={yesterday:"Ieri",sunday:"Domenica",monday:"Lunedì",tuesday:"Martedì",wednesday:"Mercoledì",thursday:"Giovedì",friday:"Venerdì",saturday:"Sabato",participantJoined:"si è unito alla chat.",participantLeft:"ha abbandonato la chat.",editMessage:"Modifica",removeMessage:"Rimuovi",editedTag:"Modificato",liveAuthorIntro:"{author} dice",editBoxTextLimit:"Il messaggio ha superato il limite di caratteri {limitNumber}",editBoxPlaceholderText:"Modifica il messaggio",newMessagesIndicator:"Nuovi messaggi",noDisplayNameSub:"Nessun nome",editBoxCancelButton:"Annulla",editBoxSubmitButton:"Invia"};var errorBar$8={unableToReachChatService:"Sei offline",accessDenied:"Non è possibile accedere ai servizi di chat. Controllare le credenziali utente specificate",userNotInChatThread:"Non fai più parte di questo thread di chat",sendMessageNotInChatThread:"Non è stato possibile inviare il messaggio perché non sei più in questo thread di chat",sendMessageGeneric:"Impossibile inviare il messaggio",callingNetworkFailure:"Problema di connessione della chiamata: sembra che tu sia offline",startVideoGeneric:"Non è stato possibile avviare il video",stopVideoGeneric:"Non è stato possibile arrestare il video",muteGeneric:"Non è stato possibile disattivare l'audio del microfono",unmuteGeneric:"Non è stato possibile riattivare l'audio del microfono",speakingWhileMuted:"Il microfono è disattivato",startScreenShareGeneric:"Non è stato possibile avviare la condivisione dello schermo",stopScreenShareGeneric:"Non è stato possibile arrestare la condivisione dello schermo",callNetworkQualityLow:"La qualità della rete è bassa.",callNoSpeakerFound:"Non sono stati trovati altoparlanti o cuffie. Connetti un dispositivo audio per ascoltare la chiamata.",callNoMicrophoneFound:"Nessun microfono trovato. Connetti un dispositivo di input audio.",callMicrophoneAccessDenied:"Impossibile accedere al microfono. Fare clic sul blocco nella barra degli indirizzi per concedere l'autorizzazione a questa pagina Web.",callMicrophoneMutedBySystem:"Il sistema disattiva l'audio.",callMacOsMicrophoneAccessDenied:"Impossibile accedere al microfono. Concedi l'autorizzazione al microfono nelle impostazioni di privacy di macOS.",callLocalVideoFreeze:"Larghezza di banda di rete insufficiente. Il video potrebbe essere sospeso per gli altri partecipanti alla chiamata.",callCameraAccessDenied:"Non è possibile accedere alla fotocamera. Fare clic sul blocco nella barra degli indirizzi per concedere l'autorizzazione a questa pagina Web.",callCameraAlreadyInUse:"Non è possibile accedere alla fotocamera. Potrebbe essere già in uso da un'altra applicazione.",callMacOsCameraAccessDenied:"MacOS sta bloccando l'accesso alla fotocamera. Aggiorna le impostazioni di privacy per consentire a questo browser di accedere alla fotocamera.",callMacOsScreenShareAccessDenied:"MacOS sta bloccando la condivisione dello schermo. Aggiorna le impostazioni di privacy per consentire a questo browser di registrare lo schermo."};var videoGallery$8={screenIsBeingSharedMessage:"Stai condividendo lo schermo",screenShareLoadingMessage:"Caricamento dello schermo di {participant}",localVideoLabel:"Tu"};var it_IT$1 = {participantItem:participantItem$8,typingIndicator:typingIndicator$8,sendBox:sendBox$8,messageStatusIndicator:messageStatusIndicator$8,endCallButton:endCallButton$8,cameraButton:cameraButton$8,microphoneButton:microphoneButton$8,devicesButton:devicesButton$8,participantsButton:participantsButton$8,screenShareButton:screenShareButton$8,messageThread:messageThread$8,errorBar:errorBar$8,videoGallery:videoGallery$8};

var participantItem$7={isMeText:"(自分)",menuTitle:"その他のオプション",removeButtonLabel:"削除",sharingIconLabel:"共有",mutedIconLabel:"ミュート状態"};var typingIndicator$7={singleUser:"{user} さんが入力しています...",multipleUsers:"{users} さんが入力しています...",multipleUsersAbbreviateOne:"{users} さんとその他 1 人が入力しています...",multipleUsersAbbreviateMany:"{users} さんと他 {numOthers} 人が入力しています...",delimiter:","};var sendBox$7={placeholderText:"メッセージを入力",textTooLong:"メッセージの長さが上限を超えています。"};var messageStatusIndicator$7={deliveredTooltipText:"送信しました",seenTooltipText:"既読",sendingTooltipText:"送信中",failedToSendTooltipText:"送信できませんでした"};var endCallButton$7={label:"退出",tooltipContent:"通話から退席"};var cameraButton$7={onLabel:"オフにする",offLabel:"オンにする",tooltipDisabledContent:"カメラが無効になっています",tooltipOnContent:"カメラをオフ",tooltipOffContent:"カメラをオンにする"};var microphoneButton$7={onLabel:"ミュート",offLabel:"ミュート解除",tooltipDisabledContent:"マイクが無効になっています",tooltipOnContent:"マイクをミュートにする",tooltipOffContent:"マイクのミュートを解除する"};var devicesButton$7={label:"デバイス",tooltipContent:"デバイスの管理",cameraMenuTitle:"カメラ",cameraMenuTooltip:"カメラの選択",microphoneMenuTitle:"マイク",microphoneMenuTooltip:"マイクの選択",speakerMenuTitle:"スピーカー",speakerMenuTooltip:"スピーカーの選択"};var participantsButton$7={label:"ユーザー",tooltipContent:"参加者を表示する",menuHeader:"この通話で",participantsListButtonLabel:"{numParticipants} 人",muteAllButtonLabel:"全員をミュート",copyInviteLinkButtonLabel:"招待用のリンクをコピー"};var screenShareButton$7={onLabel:"共有の停止",offLabel:"共有",tooltipDisabledContent:"画面共有が無効になっています",tooltipOnContent:"画面の共有を停止する",tooltipOffContent:"画面を共有します"};var messageThread$7={yesterday:"昨日",sunday:"日曜日",monday:"月曜日",tuesday:"火曜日",wednesday:"水曜日",thursday:"木曜日",friday:"金曜日",saturday:"土曜日",participantJoined:"チャットに参加しました。",participantLeft:"チャットから退出しました。",editMessage:"編集",removeMessage:"削除",editedTag:"編集済み",liveAuthorIntro:"{author} さんの発言",editBoxTextLimit:"メッセージが{limitNumber}文字の制限を超えています",editBoxPlaceholderText:"メッセージを編集する",newMessagesIndicator:"新しいメッセージ",noDisplayNameSub:"名前がありません",editBoxCancelButton:"取り消し",editBoxSubmitButton:"送信"};var errorBar$7={unableToReachChatService:"オフラインです",accessDenied:"チャット サービスにアクセスできません- 指定されたユーザー資格情報をご確認ください",userNotInChatThread:"このチャット スレッドにはもう参加していません",sendMessageNotInChatThread:"このチャット スレッドに参加していないため、メッセージを送信できませんでした",sendMessageGeneric:"メッセージを送信できませんでした。",callingNetworkFailure:"通話の接続中に問題が発生しました。オフラインのようです。",startVideoGeneric:"ビデオを開始できませんでした",stopVideoGeneric:"ビデオを停止できませんでした",muteGeneric:"マイクをミュートできませんでした",unmuteGeneric:"マイクのミュートを解除できませんでした",speakingWhileMuted:"マイクがミュートになっています",startScreenShareGeneric:"画面の共有を開始できませんでした",stopScreenShareGeneric:"画面の共有を停止できませんでした",callNetworkQualityLow:"ネットワークの品質が低くなっています。",callNoSpeakerFound:"スピーカーまたはヘッドフォンが見つかりません。音声デバイスを接続して通話を聞きます。",callNoMicrophoneFound:"マイクが見つかりません。オーディオ入力デバイスを接続します。",callMicrophoneAccessDenied:"マイクにアクセスできません。アドレス バーのロックをクリックして、この Web ページにアクセス許可を付与します。",callMicrophoneMutedBySystem:"システムによってミュートになっています。",callMacOsMicrophoneAccessDenied:"マイクにアクセスできません。macOS のプライバシー設定でマイクへのアクセス許可を付与します。",callLocalVideoFreeze:"ネットワーク帯域幅が不十分です。通話中に他のユーザーのビデオが一時停止している可能性があります。",callCameraAccessDenied:"カメラにアクセスできません。アドレス バーのロックをクリックして、この Web ページにアクセス許可を付与します。",callCameraAlreadyInUse:"カメラにアクセスできません。別のアプリケーションによって既に使用されている可能性があります。",callMacOsCameraAccessDenied:"MacOS がカメラへのアクセスをブロックしています。プライバシー設定を更新して、このブラウザーがカメラにアクセスできるようにします。",callMacOsScreenShareAccessDenied:"MacOS は画面の共有をブロックしています。プライバシー設定を更新して、このブラウザーで画面を録画できるようにします。"};var videoGallery$7={screenIsBeingSharedMessage:"画面を共有しています",screenShareLoadingMessage:"{participant} の画面を読み込んでいます",localVideoLabel:"自分"};var ja_JP$1 = {participantItem:participantItem$7,typingIndicator:typingIndicator$7,sendBox:sendBox$7,messageStatusIndicator:messageStatusIndicator$7,endCallButton:endCallButton$7,cameraButton:cameraButton$7,microphoneButton:microphoneButton$7,devicesButton:devicesButton$7,participantsButton:participantsButton$7,screenShareButton:screenShareButton$7,messageThread:messageThread$7,errorBar:errorBar$7,videoGallery:videoGallery$7};

var participantItem$6={isMeText:"(나)",menuTitle:"추가 옵션",removeButtonLabel:"제거",sharingIconLabel:"공유 중",mutedIconLabel:"음소거됨"};var typingIndicator$6={singleUser:"{user} 님이 입력 중...",multipleUsers:"{users} 님이 입력하는 중...",multipleUsersAbbreviateOne:"{users} 님 외 1명이 입력 중...",multipleUsersAbbreviateMany:"{users} 님 외 {numOthers} 님이 입력하는 중...",delimiter:"닫는 렌즈형 흰색 괄호"};var sendBox$6={placeholderText:"메시지를 입력하세요",textTooLong:"메시지 길이가 최대 제한을 초과했습니다."};var messageStatusIndicator$6={deliveredTooltipText:"보냄",seenTooltipText:"표시됨",sendingTooltipText:"보내는 중",failedToSendTooltipText:"보내기 실패"};var endCallButton$6={label:"휴가",tooltipContent:"통화 종료"};var cameraButton$6={onLabel:"끄기",offLabel:"켜기",tooltipDisabledContent:"카메라가 비활성화되었습니다",tooltipOnContent:"카메라 끄기",tooltipOffContent:"카메라 켜기"};var microphoneButton$6={onLabel:"음소거",offLabel:"음소거 해제",tooltipDisabledContent:"마이크가 비활성화되었습니다",tooltipOnContent:"마이크 음소거",tooltipOffContent:"마이크 음소거 해제"};var devicesButton$6={label:"장치",tooltipContent:"장치 관리",cameraMenuTitle:"카메라",cameraMenuTooltip:"카메라 선택",microphoneMenuTitle:"마이크",microphoneMenuTooltip:"마이크 선택",speakerMenuTitle:"발언자",speakerMenuTooltip:"스피커 선택"};var participantsButton$6={label:"사용자",tooltipContent:"프레젠테이션 표시",menuHeader:"이 통화에서",participantsListButtonLabel:"{numParticipants}명",muteAllButtonLabel:"모두 음소거",copyInviteLinkButtonLabel:"초대 링크 복사"};var screenShareButton$6={onLabel:"공유 중지",offLabel:"공유",tooltipDisabledContent:"화면 공유가 비활성화되었습니다",tooltipOnContent:"화면 공유 중지",tooltipOffContent:"화면 공유"};var messageThread$6={yesterday:"어제",sunday:"일요일",monday:"월요일",tuesday:"화요일",wednesday:"수요일",thursday:"목요일",friday:"금요일",saturday:"토요일",participantJoined:"채팅에 참여했습니다.",participantLeft:"이 채팅을 나갔습니다.",editMessage:"편집",removeMessage:"제거",editedTag:"편집됨",liveAuthorIntro:"{author} 님이 말합니다.",editBoxTextLimit:"메시지가 {limitNumber} 문자 제한을 초과했습니다.",editBoxPlaceholderText:"메시지 편집",newMessagesIndicator:"새 메시지",noDisplayNameSub:"이름 없음",editBoxCancelButton:"취소",editBoxSubmitButton:"제출"};var errorBar$6={unableToReachChatService:"오프라인 상태입니다.",accessDenied:"채팅 서비스에 액세스할 수 없습니다. 제공된 사용자 자격 증명을 확인하세요.",userNotInChatThread:"이 채팅 스레드에 더 이상 없습니다.",sendMessageNotInChatThread:"이 채팅 스레드에 더 이상 존재하지 않으므로 메시지를 보내지 못했습니다.",sendMessageGeneric:"메시지를 보내지 못했습니다",callingNetworkFailure:"통화 연결 중 - 오프라인 상태인 것 같습니다.",startVideoGeneric:"비디오를 시작하지 못함",stopVideoGeneric:"비디오를 중지하지 못함",muteGeneric:"마이크를 음소거하지 못함",unmuteGeneric:"마이크 음소거를 해제하지 못함",speakingWhileMuted:"마이크가 음소거됨",startScreenShareGeneric:"화면 공유를 시작하지 못함",stopScreenShareGeneric:"화면 공유를 중지하지 못함",callNetworkQualityLow:"네트워크 품질이 낮습니다.",callNoSpeakerFound:"스피커 또는 헤드폰을 찾을 수 없습니다. 오디오 장치를 연결하여 통화를 들을 수 있습니다.",callNoMicrophoneFound:"마이크를 찾을 수 없습니다. 오디오 입력 장치를 연결합니다.",callMicrophoneAccessDenied:"마이크에 액세스할 수 없습니다. 주소 표시줄에서 잠금을 클릭하여 이 웹 페이지에 권한을 부여합니다.",callMicrophoneMutedBySystem:"시스템에 의해 음소거되었습니다.",callMacOsMicrophoneAccessDenied:"마이크에 액세스할 수 없습니다. macOS 개인 정보 설정에서 마이크 권한을 부여합니다.",callLocalVideoFreeze:"네트워크 대역폭이 불량합니다. 통화 중에 다른 사람에 대해 비디오가 일시 중지된 것 같습니다.",callCameraAccessDenied:"카메라에 액세스할 수 없습니다. 주소 표시줄에서 잠금을 클릭하여 이 웹 페이지에 권한을 부여합니다.",callCameraAlreadyInUse:"카메라에 액세스할 수 없습니다. 다른 응용 프로그램에서 이미 사용 중일 수 있습니다.",callMacOsCameraAccessDenied:"MacOS에서 카메라에 대한 액세스를 차단하고 있습니다. 이 브라우저에서 카메라에 액세스할 수 있도록 개인 정보 설정을 업데이트합니다.",callMacOsScreenShareAccessDenied:"MacOS에서 화면 공유를 차단하고 있습니다. 이 브라우저에서 화면을 녹화할 수 있도록 개인 정보 설정을 업데이트합니다."};var videoGallery$6={screenIsBeingSharedMessage:"화면을 공유 중입니다.",screenShareLoadingMessage:"{participant} 님의 화면 로드 중",localVideoLabel:"나"};var ko_KR$1 = {participantItem:participantItem$6,typingIndicator:typingIndicator$6,sendBox:sendBox$6,messageStatusIndicator:messageStatusIndicator$6,endCallButton:endCallButton$6,cameraButton:cameraButton$6,microphoneButton:microphoneButton$6,devicesButton:devicesButton$6,participantsButton:participantsButton$6,screenShareButton:screenShareButton$6,messageThread:messageThread$6,errorBar:errorBar$6,videoGallery:videoGallery$6};

var participantItem$5={isMeText:"(jij)",menuTitle:"Meer opties",removeButtonLabel:"Verwijderen",sharingIconLabel:"Delen",mutedIconLabel:"Gedempt"};var typingIndicator$5={singleUser:"{user} typt ...",multipleUsers:"{users} typen ...",multipleUsersAbbreviateOne:"{users} en 1 andere persoon typen ...",multipleUsersAbbreviateMany:"{users} en {numOthers} anderen typen ...",delimiter:", "};var sendBox$5={placeholderText:"Een bericht invoeren",textTooLong:"De lengte van uw bericht overschrijdt de maximumlimiet."};var messageStatusIndicator$5={deliveredTooltipText:"Verzonden",seenTooltipText:"Gezien",sendingTooltipText:"Verzenden",failedToSendTooltipText:"Kan niet verzenden"};var endCallButton$5={label:"Verlaten",tooltipContent:"Gesprek verlaten"};var cameraButton$5={onLabel:"Uitschakelen",offLabel:"Inschakelen",tooltipDisabledContent:"Camera is uitgeschakeld",tooltipOnContent:"Camera uitschakelen",tooltipOffContent:"Camera inschakelen"};var microphoneButton$5={onLabel:"Dempen",offLabel:"Dempen opheffen",tooltipDisabledContent:"Microfoon is uitgeschakeld",tooltipOnContent:"Microfoon uitschakelen",tooltipOffContent:"Microfoon inschakelen"};var devicesButton$5={label:"Apparaten",tooltipContent:"Apparaten beheren",cameraMenuTitle:"Camera",cameraMenuTooltip:"Camera kiezen",microphoneMenuTitle:"Microfoon",microphoneMenuTooltip:"Microfoon kiezen",speakerMenuTitle:"Spreker",speakerMenuTooltip:"Luidspreker kiezen"};var participantsButton$5={label:"Personen",tooltipContent:"Deelnemers weergeven",menuHeader:"In dit gesprek",participantsListButtonLabel:"{numParticipants} personen",muteAllButtonLabel:"Alles dempen",copyInviteLinkButtonLabel:"Uitnodigingskoppeling kopiëren"};var screenShareButton$5={onLabel:"Delen stoppen",offLabel:"Delen",tooltipDisabledContent:"Scherm delen is uitgeschakeld",tooltipOnContent:"Delen van uw scherm stoppen",tooltipOffContent:"Uw scherm delen"};var messageThread$5={yesterday:"Gisteren",sunday:"Zondag",monday:"Maandag",tuesday:"Dinsdag",wednesday:"Woensdag",thursday:"Donderdag",friday:"Vrijdag",saturday:"Zaterdag",participantJoined:"neemt nu deel aan de chat.",participantLeft:"heeft de chat verlaten.",editMessage:"Bewerken",removeMessage:"Verwijderen",editedTag:"Bewerkt",liveAuthorIntro:"{author} zegt",editBoxTextLimit:"Uw bericht heeft de limiet van {limitNumber} tekens overschreden",editBoxPlaceholderText:"Uw bericht bewerken",newMessagesIndicator:"Nieuwe berichten",noDisplayNameSub:"Geen naam",editBoxCancelButton:"Annuleren",editBoxSubmitButton:"Verzenden"};var errorBar$5={unableToReachChatService:"U bent offline",accessDenied:"Kan geen toegang krijgen tot chatservices. Controleer de opgegeven gebruikersreferenties",userNotInChatThread:"U bent niet meer aanwezig in deze chatthread",sendMessageNotInChatThread:"Verzenden van bericht is mislukt omdat u zich niet meer in deze chatthread bevindt",sendMessageGeneric:"Kan bericht niet verzenden",callingNetworkFailure:"Er zijn problemen met het verbinden van een gesprek - Het lijkt erop dat u offline bent",startVideoGeneric:"Kan video niet starten",stopVideoGeneric:"Kan video niet stoppen",muteGeneric:"Kan microfoon niet dempen",unmuteGeneric:"Kan dempen van microfoon niet opheffen",speakingWhileMuted:"De microfoon is gedempt",startScreenShareGeneric:"Kan scherm delen niet starten",stopScreenShareGeneric:"Kan scherm delen niet stoppen",callNetworkQualityLow:"De netwerkkwaliteit is laag.",callNoSpeakerFound:"Geen luidsprekers of hoofdtelefoon gevonden. Sluit een audioapparaat aan om het gesprek te beluisteren.",callNoMicrophoneFound:"Geen microfoons gevonden. Sluit een audio-invoerapparaat aan.",callMicrophoneAccessDenied:"Kan geen toegang krijgen tot de microfoon. Klik op de vergrendeling in de adresbalk om toestemming te verlenen aan deze webpagina.",callMicrophoneMutedBySystem:"U bent gedempt door jouw systeem.",callMacOsMicrophoneAccessDenied:"Kan geen toegang krijgen tot de microfoon. Verleen microfoonmachtiging in de privacyinstellingen voor macOS.",callLocalVideoFreeze:"De netwerkbandbreedte is slecht. Je video wordt mogelijk onderbroken weergegeven voor anderen in het gesprek.",callCameraAccessDenied:"Kan geen toegang krijgen tot de camera. Klik op de vergrendeling in de adresbalk om toestemming te verlenen aan deze webpagina.",callCameraAlreadyInUse:"Kan geen toegang krijgen tot de camera. Het wordt mogelijk al gebruikt door een andere toepassing.",callMacOsCameraAccessDenied:"MacOS blokkeert de toegang tot jouw camera. Werk je privacyinstellingen bij, zodat deze browser toegang heeft tot jouw camera.",callMacOsScreenShareAccessDenied:"MacOS blokkeert scherm delen. Werk je privacyinstellingen bij, zodat deze browser jouw scherm kan opnemen."};var videoGallery$5={screenIsBeingSharedMessage:"U deelt uw scherm",screenShareLoadingMessage:"Scherm van {participant} laden",localVideoLabel:"U"};var nl_NL$1 = {participantItem:participantItem$5,typingIndicator:typingIndicator$5,sendBox:sendBox$5,messageStatusIndicator:messageStatusIndicator$5,endCallButton:endCallButton$5,cameraButton:cameraButton$5,microphoneButton:microphoneButton$5,devicesButton:devicesButton$5,participantsButton:participantsButton$5,screenShareButton:screenShareButton$5,messageThread:messageThread$5,errorBar:errorBar$5,videoGallery:videoGallery$5};

var participantItem$4={isMeText:"(você)",menuTitle:"Mais opções",removeButtonLabel:"Remover",sharingIconLabel:"Compartilhamento",mutedIconLabel:"Silenciado"};var typingIndicator$4={singleUser:"{user} está digitando ...",multipleUsers:"{users} estão digitando ...",multipleUsersAbbreviateOne:"{users} e 1 outro estão digitando...",multipleUsersAbbreviateMany:"{users} e {numOthers} outros estão digitando ...",delimiter:", "};var sendBox$4={placeholderText:"Inserir uma mensagem",textTooLong:"O comprimento da mensagem está acima do limite máximo."};var messageStatusIndicator$4={deliveredTooltipText:"Enviado",seenTooltipText:"Visto",sendingTooltipText:"Enviando",failedToSendTooltipText:"Falha ao enviar"};var endCallButton$4={label:"Sair",tooltipContent:"Sair da Chamada"};var cameraButton$4={onLabel:"Desabilitar",offLabel:"Habilitar",tooltipDisabledContent:"A câmera está desabilitada",tooltipOnContent:"Desabilitar a câmera",tooltipOffContent:"Ligar a câmera"};var microphoneButton$4={onLabel:"Mudo",offLabel:"Desativar mudo",tooltipDisabledContent:"O microfone está desabilitado",tooltipOnContent:"Ativar mudo do microfone",tooltipOffContent:"Desativar mudo do microfone"};var devicesButton$4={label:"Dispositivos",tooltipContent:"Gerenciar dispositivos",cameraMenuTitle:"Câmera",cameraMenuTooltip:"Escolher Câmera",microphoneMenuTitle:"Microfone",microphoneMenuTooltip:"Escolher Microfone",speakerMenuTitle:"Alto-falante",speakerMenuTooltip:"Escolher Alto-falante"};var participantsButton$4={label:"Pessoas",tooltipContent:"Mostrar Participantes",menuHeader:"Nesta chamada",participantsListButtonLabel:"{numParticipants} pessoas",muteAllButtonLabel:"Silenciar todos",copyInviteLinkButtonLabel:"Copiar o link de convite"};var screenShareButton$4={onLabel:"Parar de compartilhar",offLabel:"Compartilhar",tooltipDisabledContent:"O compartilhamento de tela está desabilitado",tooltipOnContent:"Parar de compartilhar sua tela",tooltipOffContent:"Compartilhar sua tela"};var messageThread$4={yesterday:"Ontem",sunday:"Domingo",monday:"Segunda",tuesday:"Terça-feira",wednesday:"Quarta-feira",thursday:"quinta-feira",friday:"Sexta-feira",saturday:"Sábado",participantJoined:"ingressou no chat.",participantLeft:"saiu do chat.",editMessage:"Editar",removeMessage:"Remover",editedTag:"Editado",liveAuthorIntro:"{author} disse",editBoxTextLimit:"Sua mensagem está acima do limite de {limitNumber} caracteres",editBoxPlaceholderText:"Edite sua mensagem",newMessagesIndicator:"Novas mensagens",noDisplayNameSub:"Sem nome",editBoxCancelButton:"Cancelar",editBoxSubmitButton:"Enviar"};var errorBar$4={unableToReachChatService:"Você está offline",accessDenied:"Não é possível acessar os serviços de chat - verifique as credenciais do usuário fornecidas",userNotInChatThread:"Você não está mais neste tópico de chat",sendMessageNotInChatThread:"Falha ao enviar mensagem porque você não está mais neste thread de chat",sendMessageGeneric:"Falha ao enviar mensagem",callingNetworkFailure:"Chamada de conexão desabilitar - parece que você está offline",startVideoGeneric:"Falha ao iniciar o vídeo",stopVideoGeneric:"Falha ao interromper o vídeo",muteGeneric:"Falha ao ativar mudo do microfone",unmuteGeneric:"Falha ao desativar mudo do microfone",speakingWhileMuted:"O microfone está com o mudo ativado",startScreenShareGeneric:"Falha ao iniciar o compartilhamento de tela",stopScreenShareGeneric:"Falha ao interromper o compartilhamento de tela",callNetworkQualityLow:"A qualidade da rede é baixa.",callNoSpeakerFound:"Nenhum alto-falante ou fone de ouvido encontrado. Conecte um dispositivo de áudio para ouvir a chamada.",callNoMicrophoneFound:"Nenhum microfone encontrado. Conecte um dispositivo de entrada de áudio.",callMicrophoneAccessDenied:"Não é possível acessar o microfone. Clique no bloqueio na barra de endereços para conceder permissão a esta página da Web.",callMicrophoneMutedBySystem:"Você está com as notificações desativada pelo sistema.",callMacOsMicrophoneAccessDenied:"Não é possível acessar o microfone. Conceda permissão ao microfone nas configurações de privacidade do macOS.",callLocalVideoFreeze:"A largura de banda da rede é ruim. Seu vídeo pode aparecer em pausa para outras pessoas na chamada.",callCameraAccessDenied:"Não é possível acessar a câmera. Clique no bloqueio na barra de endereços para conceder permissão a esta página da Web.",callCameraAlreadyInUse:"Não é possível acessar a câmera. Talvez ele já esteja em uso por outro aplicativo.",callMacOsCameraAccessDenied:"O MacOS está bloqueando o acesso à sua câmera. Atualize suas configurações de privacidade para permitir que este navegador acesse sua câmera.",callMacOsScreenShareAccessDenied:"O MacOS está bloqueando o compartilhamento de tela. Atualize suas configurações de privacidade para permitir que este navegador grave sua tela."};var videoGallery$4={screenIsBeingSharedMessage:"Você está compartilhando sua tela",screenShareLoadingMessage:"Carregando a tela do {participant}",localVideoLabel:"Você"};var pt_BR$1 = {participantItem:participantItem$4,typingIndicator:typingIndicator$4,sendBox:sendBox$4,messageStatusIndicator:messageStatusIndicator$4,endCallButton:endCallButton$4,cameraButton:cameraButton$4,microphoneButton:microphoneButton$4,devicesButton:devicesButton$4,participantsButton:participantsButton$4,screenShareButton:screenShareButton$4,messageThread:messageThread$4,errorBar:errorBar$4,videoGallery:videoGallery$4};

var participantItem$3={isMeText:"(Вы)",menuTitle:"Дополнительные параметры",removeButtonLabel:"Удалить",sharingIconLabel:"Общий доступ",mutedIconLabel:"Микрофон отключен"};var typingIndicator$3={singleUser:"{user} вводит текст...",multipleUsers:"{users} вводят текст...",multipleUsersAbbreviateOne:"{users} и еще 1 вводят текст...",multipleUsersAbbreviateMany:"{users} и еще {numOthers} вводят текст...",delimiter:"; "};var sendBox$3={placeholderText:"Введите сообщение",textTooLong:"Длина сообщения превышает максимально допустимую."};var messageStatusIndicator$3={deliveredTooltipText:"Отправлено",seenTooltipText:"Просмотрено",sendingTooltipText:"Отправка",failedToSendTooltipText:"Не удалось отправить"};var endCallButton$3={label:"Выйти",tooltipContent:"Покинуть звонок"};var cameraButton$3={onLabel:"Отключить",offLabel:"Включить",tooltipDisabledContent:"Камера отключена",tooltipOnContent:"Выключить камеру",tooltipOffContent:"Включить камеру"};var microphoneButton$3={onLabel:"Отключить звук",offLabel:"Включить звук",tooltipDisabledContent:"Микрофон отключен",tooltipOnContent:"Отключить микрофон",tooltipOffContent:"Включить микрофон"};var devicesButton$3={label:"Устройства",tooltipContent:"Управление устройствами",cameraMenuTitle:"Камера",cameraMenuTooltip:"Выбрать камеру",microphoneMenuTitle:"Микрофон",microphoneMenuTooltip:"Выбрать микрофон",speakerMenuTitle:"Динамик",speakerMenuTooltip:"Выбрать динамик"};var participantsButton$3={label:"Люди",tooltipContent:"Показать участников",menuHeader:"В этом звонке",participantsListButtonLabel:"Пользователей: {numParticipants}",muteAllButtonLabel:"Отключить все микрофоны",copyInviteLinkButtonLabel:"Копировать ссылку с приглашением"};var screenShareButton$3={onLabel:"Отменить общий доступ",offLabel:"Поделиться",tooltipDisabledContent:"Демонстрация экрана отключена.",tooltipOnContent:"Отменить общий доступ к экрану",tooltipOffContent:"Общий доступ к экрану"};var messageThread$3={yesterday:"Вчера",sunday:"Воскресенье",monday:"Понедельник",tuesday:"Вторник",wednesday:"Среда",thursday:"Четверг",friday:"Пятница",saturday:"Суббота",participantJoined:"присоединился к чату.",participantLeft:"покинул чат.",editMessage:"Изменить",removeMessage:"Удалить",editedTag:"Изменено",liveAuthorIntro:"{author} говорит",editBoxTextLimit:"Превышено предельное число символов в {limitNumber} сообщении",editBoxPlaceholderText:"Отредактируйте сообщение",newMessagesIndicator:"Новые сообщения",noDisplayNameSub:"Без имени",editBoxCancelButton:"Отмена",editBoxSubmitButton:"Отправить"};var errorBar$3={unableToReachChatService:"Вы не в сети",accessDenied:"Не удалось получить доступ к службам чата. Проверьте предоставленные учетные данные пользователя",userNotInChatThread:"Вы больше не находитесь в цепочке этого чата",sendMessageNotInChatThread:"Не удалось отправить сообщение, так как вы больше не находитесь в цепочке этого чата",sendMessageGeneric:"Не удалось отправить сообщение",callingNetworkFailure:"Тревожное подключение вызова — кажется, вы не в сети",startVideoGeneric:"Не удалось запустить видео",stopVideoGeneric:"Не удалось остановить видео",muteGeneric:"Не удалось отключить микрофон",unmuteGeneric:"Не удалось включить микрофон",speakingWhileMuted:"Микрофон отключен",startScreenShareGeneric:"Не удалось начать демонстрацию экрана",stopScreenShareGeneric:"Не удалось остановить демонстрацию экрана",callNetworkQualityLow:"Качество работы сети: низкое.",callNoSpeakerFound:"Динамики и наушники не найдены. Подключите звуковое устройство, чтобы услышать звонок.",callNoMicrophoneFound:"Микрофоны не найдены. Подключение звукового устройства ввода.",callMicrophoneAccessDenied:"Не удается получить доступ к микрофону. Щелкните блокировку в адресной строке, чтобы предоставить разрешение на эту веб-страницу.",callMicrophoneMutedBySystem:"Система отключила ваш микрофон.",callMacOsMicrophoneAccessDenied:"Не удается получить доступ к микрофону. Предоставьте разрешение на доступ к микрофону в параметрах конфиденциальности macOS.",callLocalVideoFreeze:"Низкая пропускная способность сети. Ваше видео может отображаться как приостановленное для других участников вызова.",callCameraAccessDenied:"Не удается получить доступ к камере. Щелкните блокировку в адресной строке, чтобы предоставить разрешение на эту веб-страницу.",callCameraAlreadyInUse:"Не удается получить доступ к камере. Возможно, оно уже используется другим приложением.",callMacOsCameraAccessDenied:"MacOS блокирует доступ к камере. Обновите параметры конфиденциальности, чтобы разрешить этому браузеру доступ к камере.",callMacOsScreenShareAccessDenied:"MacOS блокирует демонстрацию экрана. Обновите параметры конфиденциальности, чтобы разрешить этому браузеру записывать ваш экран."};var videoGallery$3={screenIsBeingSharedMessage:"Вы демонстрируете свой экран",screenShareLoadingMessage:"Загрузка экрана пользователя {participant}",localVideoLabel:"Вы"};var ru_RU$1 = {participantItem:participantItem$3,typingIndicator:typingIndicator$3,sendBox:sendBox$3,messageStatusIndicator:messageStatusIndicator$3,endCallButton:endCallButton$3,cameraButton:cameraButton$3,microphoneButton:microphoneButton$3,devicesButton:devicesButton$3,participantsButton:participantsButton$3,screenShareButton:screenShareButton$3,messageThread:messageThread$3,errorBar:errorBar$3,videoGallery:videoGallery$3};

var participantItem$2={isMeText:"(siz)",menuTitle:"Diğer Seçenekler",removeButtonLabel:"Kaldır",sharingIconLabel:"Paylaşım",mutedIconLabel:"Ses kapatıldı"};var typingIndicator$2={singleUser:"{user} yazıyor...",multipleUsers:"{users} yazıyor ...",multipleUsersAbbreviateOne:"{users} ve 1 kişi daha yazıyor...",multipleUsersAbbreviateMany:"{users} ve {numOthers} kişi daha yazıyor...",delimiter:", "};var sendBox$2={placeholderText:"Bir mesaj girin",textTooLong:"İletinizin uzunluğu üst sınırı aşıyor."};var messageStatusIndicator$2={deliveredTooltipText:"Gönderilen",seenTooltipText:"Görüldü",sendingTooltipText:"Gönderiliyor",failedToSendTooltipText:"Gönderilemedi"};var endCallButton$2={label:"Ayrıl",tooltipContent:"Aramadan Ayrıl"};var cameraButton$2={onLabel:"Kapat",offLabel:"Aç",tooltipDisabledContent:"Kamera devre dışı",tooltipOnContent:"Kamerayı kapat",tooltipOffContent:"Kamerayı aç"};var microphoneButton$2={onLabel:"Sesi kapat",offLabel:"Sesi aç",tooltipDisabledContent:"Mikrofon devre dışı",tooltipOnContent:"Mikrofonun sesini kapat",tooltipOffContent:"Mikrofonun sesini aç"};var devicesButton$2={label:"Cihazlar",tooltipContent:"Cihazları yönet",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera Seç",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon Seç",speakerMenuTitle:"Hoparlör",speakerMenuTooltip:"Hoparlör Seç"};var participantsButton$2={label:"Kişiler",tooltipContent:"Katılımcıları Göster",menuHeader:"Bu aramada",participantsListButtonLabel:"{numParticipants} kişiler",muteAllButtonLabel:"Tümünün sesini kapat",copyInviteLinkButtonLabel:"Davet bağlantısını kopyala"};var screenShareButton$2={onLabel:"Paylaşımı durdur",offLabel:"Paylaş",tooltipDisabledContent:"Ekran paylaşımı devre dışı",tooltipOnContent:"Ekranınızı paylaşmayı durdurma",tooltipOffContent:"Ekranınızı paylaşın"};var messageThread$2={yesterday:"Dün",sunday:"Pazar",monday:"Pazartesi",tuesday:"Salı",wednesday:"Çarşamba",thursday:"Perşembe",friday:"Cuma",saturday:"Cumartesi",participantJoined:"sohbete katıldı.",participantLeft:"sohbetten ayrıldı.",editMessage:"Düzenle",removeMessage:"Kaldır",editedTag:"Düzenlendi",liveAuthorIntro:"{author} şöyle diyor:",editBoxTextLimit:"İletiniz en fazla {limitNumber} aşıyor",editBoxPlaceholderText:"İletinizi düzenleyin",newMessagesIndicator:"Yeni iletiler",noDisplayNameSub:"Ad yok",editBoxCancelButton:"İptal",editBoxSubmitButton:"Gönder"};var errorBar$2={unableToReachChatService:"Çevrimdışısınız",accessDenied:"Sohbet hizmetlerine erişilemedi. Lütfen sağlanan kullanıcı kimlik bilgilerini denetleyin",userNotInChatThread:"Artık bu sohbet yazışması içinde değilsiniz",sendMessageNotInChatThread:"Artık bu sohbet yazışması içinde olmadığınız için ileti gönderilemedi",sendMessageGeneric:"İleti gönderilemedi",callingNetworkFailure:"Arama bağlanırken sorun oluştu; çevrimdışı görünüyorsunuz",startVideoGeneric:"Video başlatılamadı",stopVideoGeneric:"Video durdurulamadı",muteGeneric:"Mikrofonun sesi kapatılamadı",unmuteGeneric:"Mikrofonun sesi açılamadı",speakingWhileMuted:"Mikrofonunuzun sesi kapalı",startScreenShareGeneric:"Ekran paylaşımı başlatılamadı",stopScreenShareGeneric:"Ekran paylaşımı durdurulamadı",callNetworkQualityLow:"Ağ kalitesi düşük.",callNoSpeakerFound:"Hoparlör veya kulaklık bulunamadı. Aramayı dinlemek için bir ses aygıtı bağlayın.",callNoMicrophoneFound:"Mikrofon bulunamadı. Ses giriş cihazı bağlan.",callMicrophoneAccessDenied:"Mikrofona erişemiyor. Bu web sayfası için izin vermek için adres çubuğundaki kilidi tıklatın.",callMicrophoneMutedBySystem:"Sisteminiz tarafından sessize alındınız.",callMacOsMicrophoneAccessDenied:"Mikrofona erişilemiyor. macOS gizlilik ayarlarınızda mikrofon izni verin.",callLocalVideoFreeze:"Ağ bant genişliği düşük. Görüntülü aramada başkaları için duraklatılmış görünüyor olabilir.",callCameraAccessDenied:"Kameraya erişemiyor. Bu web sayfası için izin vermek için adres çubuğundaki kilidi tıklatın.",callCameraAlreadyInUse:"Kameraya erişemiyor. Başka bir uygulama tarafından zaten kullanılıyor olabilir.",callMacOsCameraAccessDenied:"MacOS kameranıza erişimi engelliyor. Bu tarayıcının kameranıza erişmesine izin vermek için gizlilik ayarlarınızı güncelleştirin.",callMacOsScreenShareAccessDenied:"MacOS ekran paylaşımını engelliyor. Bu tarayıcının ekranınızı kaydetmesini izin vermek için gizlilik ayarlarınızı güncelleştirin."};var videoGallery$2={screenIsBeingSharedMessage:"Ekranınızı paylaşıyorsunuz.",screenShareLoadingMessage:"{participant} adlı katılımcının ekranını yükleme",localVideoLabel:"Siz"};var tr_TR$1 = {participantItem:participantItem$2,typingIndicator:typingIndicator$2,sendBox:sendBox$2,messageStatusIndicator:messageStatusIndicator$2,endCallButton:endCallButton$2,cameraButton:cameraButton$2,microphoneButton:microphoneButton$2,devicesButton:devicesButton$2,participantsButton:participantsButton$2,screenShareButton:screenShareButton$2,messageThread:messageThread$2,errorBar:errorBar$2,videoGallery:videoGallery$2};

var participantItem$1={isMeText:"(我)",menuTitle:"更多选项",removeButtonLabel:"删除",sharingIconLabel:"共享",mutedIconLabel:"已静音"};var typingIndicator$1={singleUser:"{user} 正在键入...",multipleUsers:"{users} 正在键入...",multipleUsersAbbreviateOne:"{users} 和另外 1 人正在键入...",multipleUsersAbbreviateMany:"{users} 和其他 {numOthers} 人正在键入...",delimiter:"、 "};var sendBox$1={placeholderText:"输入消息",textTooLong:"你的消息长度超过了最大限制。"};var messageStatusIndicator$1={deliveredTooltipText:"已发送",seenTooltipText:"已查看",sendingTooltipText:"正在发送",failedToSendTooltipText:"发送失败"};var endCallButton$1={label:"退出",tooltipContent:"离开会议"};var cameraButton$1={onLabel:"关闭",offLabel:"打开",tooltipDisabledContent:"已禁用照相机",tooltipOnContent:"关闭摄像头",tooltipOffContent:"打开摄像头"};var microphoneButton$1={onLabel:"静音",offLabel:"取消静音",tooltipDisabledContent:"已禁用麦克风",tooltipOnContent:"将麦克风静音",tooltipOffContent:"取消麦克风静音"};var devicesButton$1={label:"设备",tooltipContent:"管理设备",cameraMenuTitle:"相机",cameraMenuTooltip:"选择“相机”",microphoneMenuTitle:"麦克风",microphoneMenuTooltip:"选择麦克风",speakerMenuTitle:"免提",speakerMenuTooltip:"选择扬声器"};var participantsButton$1={label:"人员",tooltipContent:"显示参与者",menuHeader:"在此通话中",participantsListButtonLabel:"{numParticipants} 人",muteAllButtonLabel:"全部静音",copyInviteLinkButtonLabel:"复制邀请链接"};var screenShareButton$1={onLabel:"停止共享",offLabel:"共享",tooltipDisabledContent:"已禁用屏幕共享",tooltipOnContent:"停止共享屏幕",tooltipOffContent:"共享屏幕"};var messageThread$1={yesterday:"昨天",sunday:"星期日",monday:"星期一",tuesday:"星期二",wednesday:"星期三",thursday:"星期四",friday:"星期五",saturday:"星期六",participantJoined:"已加入聊天。",participantLeft:"已退出聊天。",editMessage:"编辑",removeMessage:"删除",editedTag:"已编辑",liveAuthorIntro:"{author} 说",editBoxTextLimit:"你的消息超过了{limitNumber}个字符的限制",editBoxPlaceholderText:"编辑消息",newMessagesIndicator:"新消息",noDisplayNameSub:"无名称",editBoxCancelButton:"取消",editBoxSubmitButton:"提交"};var errorBar$1={unableToReachChatService:"你已脱机",accessDenied:"无法访问聊天服务 - 请检查提供的用户凭据",userNotInChatThread:"你不再处于此聊天会话中",sendMessageNotInChatThread:"无法发送消息，因为你不再在此聊天会话中",sendMessageGeneric:"未能发送消息",callingNetworkFailure:"正在连接呼叫 - 你似乎处于脱机状态",startVideoGeneric:"无法启动视频",stopVideoGeneric:"无法停止视频",muteGeneric:"无法静音麦克风",unmuteGeneric:"无法取消麦克风静音",speakingWhileMuted:"你的麦克风已静音",startScreenShareGeneric:"无法启动屏幕共享",stopScreenShareGeneric:"无法停止屏幕共享",callNetworkQualityLow:"网络质量低。",callNoSpeakerFound:"找不到扬声器或耳机。连接音频设备以收听呼叫。",callNoMicrophoneFound:"找不到麦克风。连接音频输入设备。",callMicrophoneAccessDenied:"无法访问麦克风。单击地址栏中的锁定以授予对此网页的权限。",callMicrophoneMutedBySystem:"系统已将你设为静音。",callMacOsMicrophoneAccessDenied:"无法访问麦克风。在 macOS 隐私设置中授予麦克风权限。",callLocalVideoFreeze:"网络带宽较差。你的视频可能会在通话中为其他人暂停。",callCameraAccessDenied:"无法访问照相机。单击地址栏中的锁定以授予对此网页的权限。",callCameraAlreadyInUse:"无法访问照相机。它可能已被其他应用程序使用。",callMacOsCameraAccessDenied:"MacOS 正在阻止访问你的相机。更新你的隐私设置以允许此浏览器访问你的相机。",callMacOsScreenShareAccessDenied:"MacOS 正在阻止屏幕共享。更新你的隐私设置以允许此浏览器录制你的屏幕。"};var videoGallery$1={screenIsBeingSharedMessage:"你正在共享你的屏幕",screenShareLoadingMessage:"正在加载 {participant} 的屏幕",localVideoLabel:"你"};var zh_CN$1 = {participantItem:participantItem$1,typingIndicator:typingIndicator$1,sendBox:sendBox$1,messageStatusIndicator:messageStatusIndicator$1,endCallButton:endCallButton$1,cameraButton:cameraButton$1,microphoneButton:microphoneButton$1,devicesButton:devicesButton$1,participantsButton:participantsButton$1,screenShareButton:screenShareButton$1,messageThread:messageThread$1,errorBar:errorBar$1,videoGallery:videoGallery$1};

var participantItem={isMeText:"(您)",menuTitle:"更多選項",removeButtonLabel:"移除",sharingIconLabel:"分享",mutedIconLabel:"已靜音"};var typingIndicator={singleUser:"{user} 正在輸入...",multipleUsers:"{users} 正在輸入...",multipleUsersAbbreviateOne:"{users} 和其他 1 人正在輸入...",multipleUsersAbbreviateMany:"{users} 和其他 {numOthers} 人正在輸入...",delimiter:"， "};var sendBox={placeholderText:"輸入訊息",textTooLong:"您的訊息長度超過上限。"};var messageStatusIndicator={deliveredTooltipText:"已傳送",seenTooltipText:"已讀",sendingTooltipText:"正在傳送",failedToSendTooltipText:"無法傳送"};var endCallButton={label:"離開",tooltipContent:"離開通話"};var cameraButton={onLabel:"關閉",offLabel:"開啟",tooltipDisabledContent:"相機已停用",tooltipOnContent:"關閉攝影機",tooltipOffContent:"開啟相機"};var microphoneButton={onLabel:"靜音",offLabel:"取消靜音",tooltipDisabledContent:"麥克風已停用",tooltipOnContent:"將麥克風設為靜音",tooltipOffContent:"取消麥克風靜音"};var devicesButton={label:"裝置",tooltipContent:"管理裝置",cameraMenuTitle:"攝影機",cameraMenuTooltip:"選擇攝影機",microphoneMenuTitle:"麥克風",microphoneMenuTooltip:"選擇麥克風",speakerMenuTitle:"演講者",speakerMenuTooltip:"選擇講者"};var participantsButton={label:"人員",tooltipContent:"顯示參與者",menuHeader:"在此通話中",participantsListButtonLabel:"{numParticipants} 人員",muteAllButtonLabel:"將所有人設為靜音",copyInviteLinkButtonLabel:"複製邀請連結"};var screenShareButton={onLabel:"停止分享",offLabel:"分享",tooltipDisabledContent:"視訊分享已停用",tooltipOnContent:"停止螢幕畫面分享",tooltipOffContent:"共用您的螢幕"};var messageThread={yesterday:"昨天",sunday:"星期日",monday:"星期一",tuesday:"星期二",wednesday:"星期三",thursday:"星期四",friday:"星期五",saturday:"星期六",participantJoined:"已加入聊天。",participantLeft:"已離開聊天。",editMessage:"編輯",removeMessage:"移除",editedTag:"已編輯",liveAuthorIntro:"{author} 說",editBoxTextLimit:"您的訊息超過 {limitNumber} 個字元的限制",editBoxPlaceholderText:"編輯您的訊息",newMessagesIndicator:"新訊息",noDisplayNameSub:"沒有名稱",editBoxCancelButton:"取消",editBoxSubmitButton:"提交"};var errorBar={unableToReachChatService:"您處於離線狀態",accessDenied:"無法存取聊天服務 - 請檢查提供的使用者認證",userNotInChatThread:"您已不在此聊天對話中",sendMessageNotInChatThread:"無法傳送訊息，因為您已不在此聊天對話中",sendMessageGeneric:"無法傳送訊息",callingNetworkFailure:"連線通話發生錯誤 - 您似乎已離線",startVideoGeneric:"無法啟動影片",stopVideoGeneric:"無法停止影片",muteGeneric:"無法將麥克風設為靜音",unmuteGeneric:"無法將麥克風取消靜音",speakingWhileMuted:"您的麥克風已設為靜音",startScreenShareGeneric:"無法開始螢幕畫面分享",stopScreenShareGeneric:"無法停止螢幕畫面分享",callNetworkQualityLow:"您的網路品質不佳。",callNoSpeakerFound:"找不到喇叭或耳機。請連接音訊裝置以聆聽通話。",callNoMicrophoneFound:"找不到麥克風。請連接音訊輸入裝置。",callMicrophoneAccessDenied:"無法存取麥克風。按一下網址列中的鎖定以授與此網頁的許可權。",callMicrophoneMutedBySystem:"系統已將您設為靜音。",callMacOsMicrophoneAccessDenied:"無法存取麥克風。請在您的 MacOS 隱私權設定中授與麥克風權限。",callLocalVideoFreeze:"網路頻寬不佳。通話中的其他人可能會暫停您的視訊。",callCameraAccessDenied:"無法存取相機。按一下網址列中的鎖定以授與此網頁的許可權。",callCameraAlreadyInUse:"無法存取相機。其他應用程式可能已在使用它。",callMacOsCameraAccessDenied:"MacOS 已封鎖您的相機存取權限。請更新您的隱私權設定，允許此瀏覽器存取您的相機。",callMacOsScreenShareAccessDenied:"MacOS 正在封鎖螢幕畫面分享。更新您的隱私權設定，以允許此瀏覽器錄製您的螢幕。"};var videoGallery={screenIsBeingSharedMessage:"您現在正在分享螢幕畫面。",screenShareLoadingMessage:"正在載入 {participant} 的螢幕畫面",localVideoLabel:"您"};var zh_TW$1 = {participantItem:participantItem,typingIndicator:typingIndicator,sendBox:sendBox,messageStatusIndicator:messageStatusIndicator,endCallButton:endCallButton,cameraButton:cameraButton,microphoneButton:microphoneButton,devicesButton:devicesButton,participantsButton:participantsButton,screenShareButton:screenShareButton,messageThread:messageThread,errorBar:errorBar,videoGallery:videoGallery};

// Copyright (c) Microsoft Corporation.
const createComponentStrings = (localizedStrings) => {
    const strings = Object.assign({}, en_US$1);
    Object.keys(localizedStrings).forEach((key) => {
        strings[key] = Object.assign(Object.assign({}, strings[key]), localizedStrings[key]);
    });
    return strings;
};
/**
 * Locale for English (US).
 *
 * @public
 */
const COMPONENT_LOCALE_EN_US = { strings: en_US$1 };
/**
 * Locale for English (GB).
 *
 * @public
 */
const COMPONENT_LOCALE_EN_GB = { strings: createComponentStrings(en_GB$1) };
/**
 * Locale for  German (Germany).
 *
 * @public
 */
const COMPONENT_LOCALE_DE_DE = { strings: createComponentStrings(de_DE$1) };
/**
 * Locale for Spanish (Spain).
 *
 * @public
 */
const COMPONENT_LOCALE_ES_ES = { strings: createComponentStrings(es_ES$1) };
/**
 * Locale for French (France).
 *
 * @public
 */
const COMPONENT_LOCALE_FR_FR = { strings: createComponentStrings(fr_FR$1) };
/**
 * Locale for Italian (Italy).
 *
 * @public
 */
const COMPONENT_LOCALE_IT_IT = { strings: createComponentStrings(it_IT$1) };
/**
 * Locale for Japanese (Japan).
 *
 * @public
 */
const COMPONENT_LOCALE_JA_JP = { strings: createComponentStrings(ja_JP$1) };
/**
 * Locale for Korean (South Korea).
 *
 * @public
 */
const COMPONENT_LOCALE_KO_KR = { strings: createComponentStrings(ko_KR$1) };
/**
 * Locale for Dutch (Netherlands).
 *
 * @public
 */
const COMPONENT_LOCALE_NL_NL = { strings: createComponentStrings(nl_NL$1) };
/**
 * Locale for Portuguese (Brazil).
 *
 * @public
 */
const COMPONENT_LOCALE_PT_BR = { strings: createComponentStrings(pt_BR$1) };
/**
 * Locale for Russian (Russia).
 *
 * @public
 */
const COMPONENT_LOCALE_RU_RU = { strings: createComponentStrings(ru_RU$1) };
/**
 * Locale for Turkish (Turkey).
 *
 * @public
 */
const COMPONENT_LOCALE_TR_TR = { strings: createComponentStrings(tr_TR$1) };
/**
 * Locale for Chinese (Mainland China).
 *
 * @public
 */
const COMPONENT_LOCALE_ZH_CN = { strings: createComponentStrings(zh_CN$1) };
/**
 * Locale for Chinese (Taiwan).
 *
 * @public
 */
const COMPONENT_LOCALE_ZH_TW = { strings: createComponentStrings(zh_TW$1) };

// Copyright (c) Microsoft Corporation.
/**
 * Context for providing localized strings to components exported from this library.
 *
 * @public
 */
const LocaleContext$1 = React.createContext(COMPONENT_LOCALE_EN_US);
/**
 * Provider to provide localized strings for this library's react components.
 *
 * @remarks Components will be provided localized strings in English (US) by default if this
 * provider is not used.
 *
 * @public
 */
const LocalizationProvider$1 = (props) => {
    const { locale, children } = props;
    return React__default['default'].createElement(LocaleContext$1.Provider, { value: locale }, children);
};
/** React hook to access locale */
const useLocale$1 = () => React.useContext(LocaleContext$1);

// Copyright (c) Microsoft Corporation.
const defaultIdentifiers = {
    sendboxTextField: 'sendbox-textfield',
    participantButtonPeopleMenuItem: 'participant-button-people-menu-item',
    participantItemMenuButton: 'participant-item-menu-button',
    participantList: 'participant-list',
    participantListPeopleButton: 'participant-list-people-button',
    participantListRemoveParticipantButton: 'participant-list-remove-participant-button',
    messageContent: 'message-content',
    messageTimestamp: 'message-timestamp',
    typingIndicator: 'typing-indicator',
    videoGallery: 'video-gallery',
    videoTile: 'video-tile'
};
/**
 * @private
 */
const IdentifierContext = React.createContext(defaultIdentifiers);
/**
 * React Context provider for {@link _Identifiers}.
 *
 * @experimental
 *
 * See documentation for {@link _Identifiers}.
 *
 * @internal
 */
const _IdentifierProvider = (props) => {
    const { identifiers, children } = props;
    return React__default['default'].createElement(IdentifierContext.Provider, { value: identifiers !== null && identifiers !== void 0 ? identifiers : defaultIdentifiers }, children);
};
/**
 * @private
 */
const useIdentifiers = () => React.useContext(IdentifierContext);

// Copyright (c) Microsoft Corporation.
const MAXIMUM_LENGTH_OF_TYPING_USERS = 35;
/**
 * Helper function to create element wrapping all typing users
 * @param typingUsers typing users
 * @param delimiter string to separate typing users
 * @param onRenderUser optional callback to render each typing user
 * @param userDisplayNameStyles optional additional IStyle to apply to each element containing users name
 * @returns element wrapping all typing users
 */
const getUsersElement = (typingUsers, delimiter, onRenderUser, userDisplayNameStyles) => {
    const userElements = [];
    typingUsers.forEach((user, index) => {
        userElements.push(onRenderUser ? (onRenderUser(user)) : (React__default['default'].createElement(react.Text, { className: react.mergeStyles(userDisplayNameStyles), key: `user-${index}` }, user.displayName)));
        userElements.push(React__default['default'].createElement(react.Text, { key: `comma-${index}` }, `${delimiter}`));
    });
    // pop last comma
    userElements.pop();
    return React__default['default'].createElement(React__default['default'].Fragment, null, userElements);
};
/**
 * Helper function to get a string of all typing users
 * @param typingUsers typing users
 * @param delimiter string to separate typing users
 * @returns string of all typing users
 */
const getNamesString = (typingUsers, delimiter) => {
    const userNames = [];
    typingUsers.forEach((user) => {
        if (user.displayName) {
            userNames.push(user.displayName);
        }
    });
    return userNames.join(delimiter);
};
/**
 * Helper function to create span elements making up the typing indicator string
 * @param strings TypingIndicatorStrings containing strings to create span elements
 * @param usersElement JSX.Element containing all typing users
 * @param numTypingUsers number of total typing users
 * @param numUserNotMentioned number of typing users abbreviated
 * @returns array of span elements making up the typing indicator string
 */
const getSpanElements = (strings, usersElement, numTypingUsers, numTypingUsersAbbreviated) => {
    let variables = {};
    let typingString = '';
    if (numTypingUsers === 1) {
        typingString = strings.singleUser;
        variables = {
            user: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated === 0) {
        typingString = strings.multipleUsers;
        variables = {
            users: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated === 1) {
        typingString = strings.multipleUsersAbbreviateOne;
        variables = {
            users: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated > 1) {
        typingString = strings.multipleUsersAbbreviateMany;
        variables = {
            users: usersElement,
            numOthers: React__default['default'].createElement(React__default['default'].Fragment, null, numTypingUsersAbbreviated)
        };
    }
    return formatInlineElements(typingString, variables);
};
/**
 * Helper function to get the string making up the typing indicator string
 * @param strings TypingIndicatorStrings containing strings to create span elements
 * @param namesString string of all typing users
 * @param numTypingUsers number of total typing users
 * @param numUserNotMentioned number of typing users abbreviated
 * @returns typing indicator string
 */
const getIndicatorString = (strings, namesString, numTypingUsers, numTypingUsersAbbreviated) => {
    if (numTypingUsers === 1) {
        return strings.singleUser.replace('{user}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated === 0) {
        return strings.multipleUsers.replace('{users}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated === 1) {
        return strings.multipleUsersAbbreviateOne.replace('{users}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated > 1) {
        return strings.multipleUsersAbbreviateMany
            .replace('{users}', namesString)
            .replace('{numOthers}', `${numTypingUsersAbbreviated}`);
    }
    return undefined;
};
const IndicatorComponent = (typingUsers, strings, onRenderUser, styles) => {
    const typingUsersMentioned = [];
    let totalCharacterCount = 0;
    const ids = useIdentifiers();
    for (const typingUser of typingUsers) {
        if (!typingUser.displayName) {
            continue;
        }
        let additionalCharCount = typingUser.displayName.length;
        // The typing users will be separated by the delimiter. We account for that additional length when we generate the final string.
        if (typingUsersMentioned.length > 0) {
            additionalCharCount += strings.delimiter.length;
        }
        if (totalCharacterCount + additionalCharCount <= MAXIMUM_LENGTH_OF_TYPING_USERS ||
            typingUsersMentioned.length === 0) {
            typingUsersMentioned.push(typingUser);
            totalCharacterCount += additionalCharCount;
        }
        else {
            break;
        }
    }
    const usersElement = getUsersElement(typingUsersMentioned, strings.delimiter, onRenderUser, styles === null || styles === void 0 ? void 0 : styles.typingUserDisplayName);
    const numUserNotMentioned = typingUsers.length - typingUsersMentioned.length;
    const spanElements = getSpanElements(strings, usersElement, typingUsersMentioned.length, numUserNotMentioned);
    const labelString = getIndicatorString(strings, getNamesString(typingUsersMentioned, strings.delimiter), typingUsersMentioned.length, numUserNotMentioned);
    return (React__default['default'].createElement("div", { "data-ui-id": ids.typingIndicator, className: react.mergeStyles(typingIndicatorStringStyle, styles === null || styles === void 0 ? void 0 : styles.typingString), key: "typingStringKey", role: "status", "aria-label": labelString }, spanElements));
};
/**
 * Component to notify local user when one or more participants in the chat thread are typing.
 *
 * @public
 */
const TypingIndicator = (props) => {
    const { typingUsers, onRenderUser, styles } = props;
    const { strings } = useLocale$1();
    const typingUsersToRender = typingUsers.filter((typingUser) => typingUser.displayName !== undefined);
    const indicatorComponent = IndicatorComponent(typingUsersToRender, Object.assign(Object.assign({}, strings.typingIndicator), props.strings), onRenderUser, styles);
    return React__default['default'].createElement(react.Stack, { className: react.mergeStyles(typingIndicatorContainerStyle, styles === null || styles === void 0 ? void 0 : styles.root) }, indicatorComponent);
};
/**
 * Create an array of span elements by replacing the pattern "\{\}" in str with the elements
 * passed in as vars and creating inline elements from the rest
 *
 * @param str - The string to be formatted
 * @param vars - Variables to use to format the string
 * @returns formatted JSX elements
 */
const formatInlineElements = (str, vars) => {
    if (!str) {
        return [];
    }
    if (!vars) {
        return [];
    }
    const elements = [];
    // regex to search for the pattern "{}"
    const placeholdersRegex = /{(\w+)}/g;
    const regex = RegExp(placeholdersRegex);
    let array = regex.exec(str);
    let prev = 0;
    while (array !== null) {
        if (prev !== array.index) {
            elements.push(React__default['default'].createElement(react.Text, { key: elements.length }, str.substring(prev, array.index)));
        }
        elements.push(React__default['default'].createElement(react.Text, { key: elements.length }, vars[array[0].substring(1, array[0].length - 1)]));
        prev = regex.lastIndex;
        array = regex.exec(str);
    }
    elements.push(React__default['default'].createElement(react.Text, { key: elements.length }, str.substring(prev)));
    return elements;
};

// Copyright (c) Microsoft Corporation.
/**
 * A component to show error messages on the UI.
 * All strings that can be shown are accepted as the {@link ErrorBarProps.strings} so that they can be localized.
 * Active errors are selected by {@link ErrorBarProps.activeErrorMessages}.
 *
 * This component internally tracks dismissed by the user.
 *   * Errors that have an associated timestamp: The error is shown on the UI again if it occurs after being dismissed.
 *   * Errors that do not have a timestamp: The error is dismissed until it disappears from the props.
 *         If the error recurs, it is shown in the UI.
 *
 * Uses {@link @fluentui/react#MessageBar} UI element.
 *
 * @public
 */
const ErrorBar = (props) => {
    var _a;
    const localeStrings = useLocale$1().strings.errorBar;
    const strings = (_a = props.strings) !== null && _a !== void 0 ? _a : localeStrings;
    const [dismissedErrors, setDismissedErrors] = React.useState([]);
    // dropDismissalsForInactiveErrors only returns a new object if `dismissedErrors` actually changes.
    // Without this behaviour, this `useEffect` block would cause a render loop.
    React.useEffect(() => setDismissedErrors(dropDismissalsForInactiveErrors(props.activeErrorMessages, dismissedErrors)), [props.activeErrorMessages, dismissedErrors]);
    const toShow = errorsToShow(props.activeErrorMessages, dismissedErrors);
    return (React__default['default'].createElement(react.Stack, null, toShow.map((error) => (React__default['default'].createElement(react.MessageBar, Object.assign({}, props, { key: error.type, messageBarType: messageBarType(error.type), messageBarIconProps: messageBarIconProps(error.type), onDismiss: () => setDismissedErrors(dismissError(dismissedErrors, error)) }), strings[error.type])))));
};
// Always returns a new Array so that the state variable is updated, trigerring a render.
const dismissError = (dismissedErrors, toDismiss) => {
    const now = new Date(Date.now());
    for (const error of dismissedErrors) {
        if (error.type === toDismiss.type) {
            // Bump the timestamp for latest dismissal of this error to now.
            error.dismissedAt = now;
            error.activeSince = toDismiss.timestamp;
            return Array.from(dismissedErrors);
        }
    }
    // Record that this error was dismissed for the first time right now.
    return [
        ...dismissedErrors,
        {
            type: toDismiss.type,
            dismissedAt: now,
            activeSince: toDismiss.timestamp
        }
    ];
};
// Returns a new Array if and only if contents change, to avoid re-rendering when nothing was dropped.
const dropDismissalsForInactiveErrors = (activeErrorMessages, dismissedErrors) => {
    const active = new Map();
    for (const message of activeErrorMessages) {
        active.set(message.type, message);
    }
    // For an error such that:
    // * It was previously active, and dismissed.
    // * It did not have a timestamp associated with it.
    // * It is no longer active.
    //
    // We remove it from dismissals. When it becomes active again next time, it will be shown again on the UI.
    const shouldDeleteDismissal = (dismissed) => dismissed.activeSince === undefined && active.get(dismissed.type) === undefined;
    if (dismissedErrors.some((dismissed) => shouldDeleteDismissal(dismissed))) {
        return dismissedErrors.filter((dismissed) => !shouldDeleteDismissal(dismissed));
    }
    return dismissedErrors;
};
const errorsToShow = (activeErrorMessages, dismissedErrors) => {
    const dismissed = new Map();
    for (const error of dismissedErrors) {
        dismissed.set(error.type, error);
    }
    return activeErrorMessages.filter((error) => {
        const dismissal = dismissed.get(error.type);
        if (!dismissal) {
            // This error was never dismissed.
            return true;
        }
        if (!error.timestamp) {
            // No timestamp associated with the error. In this case, the existence of a dismissal is enough to suppress the error.
            return false;
        }
        // Error has an associated timestamp, so compare with last dismissal.
        return error.timestamp > dismissal.dismissedAt;
    });
};
const messageBarType = (errorType) => {
    switch (errorType) {
        case 'callNetworkQualityLow':
        case 'callNoSpeakerFound':
        case 'callNoMicrophoneFound':
        case 'callMicrophoneAccessDenied':
        case 'callMicrophoneMutedBySystem':
        case 'callMacOsMicrophoneAccessDenied':
        case 'callLocalVideoFreeze':
        case 'callCameraAccessDenied':
        case 'callCameraAlreadyInUse':
        case 'callMacOsCameraAccessDenied':
        case 'callMacOsScreenShareAccessDenied':
            return react.MessageBarType.warning;
        default:
            return react.MessageBarType.error;
    }
};
const messageBarIconProps = (errorType) => {
    const iconName = customIconName[errorType];
    return iconName ? { iconName } : undefined;
};
const customIconName = {
    callNetworkQualityLow: 'ErrorBarCallNetworkQualityLow',
    callNoSpeakerFound: 'ErrorBarCallNoSpeakerFound',
    callNoMicrophoneFound: 'ErrorBarCallNoMicrophoneFound',
    callMicrophoneAccessDenied: 'ErrorBarCallMicrophoneAccessDenied',
    callMicrophoneMutedBySystem: 'ErrorBarCallMicrophoneMutedBySystem',
    callMacOsMicrophoneAccessDenied: 'ErrorBarCallMacOsMicrophoneAccessDenied',
    callLocalVideoFreeze: 'ErrorBarCallLocalVideoFreeze',
    callCameraAccessDenied: 'ErrorBarCallCameraAccessDenied',
    callCameraAlreadyInUse: 'ErrorBarCallCameraAlreadyInUse',
    callMacOsCameraAccessDenied: 'ErrorBarCallMacOsCameraAccessDenied'
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const gridLayoutStyle = react.mergeStyles({
    width: '100%',
    height: '100%',
    display: 'grid',
    gridGap: '0.5rem'
});

// Copyright (c) Microsoft Corporation.
/**
 * A component to lay out audio / video participants tiles in a call.
 *
 * @public
 */
const GridLayout = (props) => {
    const { children, styles } = props;
    const numberOfChildren = React__default['default'].Children.count(children);
    const [currentWidth, setCurrentWidth] = React.useState(0);
    const [currentHeight, setCurrentHeight] = React.useState(0);
    const containerRef = React.useRef(null);
    const observer = React.useRef(new ResizeObserver((entries) => {
        const { width, height } = entries[0].contentRect;
        setCurrentWidth(width);
        setCurrentHeight(height);
    }));
    React.useEffect(() => {
        if (containerRef.current) {
            observer.current.observe(containerRef.current);
        }
        const currentObserver = observer.current;
        return () => currentObserver.disconnect();
    }, [observer, containerRef]);
    const gridProps = React.useMemo(() => {
        return calculateGridProps(numberOfChildren, currentWidth, currentHeight);
    }, [numberOfChildren, currentWidth, currentHeight]);
    const cssGridStyles = React.useMemo(() => createGridStyles(numberOfChildren, gridProps), [numberOfChildren, gridProps]);
    return (React__default['default'].createElement("div", { ref: containerRef, className: react.mergeStyles(gridLayoutStyle, cssGridStyles, styles === null || styles === void 0 ? void 0 : styles.root) }, children));
};
/**
 * The cell aspect ratio we aim for in a grid
 */
const TARGET_CELL_ASPECT_RATIO = 16 / 9;
/**
 * The minimum cell aspect ratio we allow
 */
const MINIMUM_CELL_ASPECT_RATIO_ALLOWED = 8 / 9;
const isCloserThan = (a, b, target) => {
    return Math.abs(target - a) < Math.abs(target - b);
};
/**
 * Get the best GridProps to place a number of items in a grid as evenly as possible given the width and height of the grid
 * @param numberOfItems - number of items to place in grid
 * @param width - width of grid
 * @param height - height of grid
 * @returns GridProps
 */
const calculateGridProps = (numberOfItems, width, height) => {
    if (numberOfItems <= 0) {
        return { fillDirection: 'horizontal', rows: 0, columns: 0 };
    }
    // If width or height are 0 then we return rows and column evenly
    if (width <= 0 || height <= 0) {
        return {
            fillDirection: 'horizontal',
            rows: Math.ceil(Math.sqrt(numberOfItems)),
            columns: Math.ceil(Math.sqrt(numberOfItems))
        };
    }
    const aspectRatio = width / height;
    // Approximate how many rows to divide the grid to achieve cells close to the TARGET_CELL_ASPECT_RATIO
    let rows = Math.floor(Math.sqrt((TARGET_CELL_ASPECT_RATIO / aspectRatio) * numberOfItems)) || 1;
    // Make sure rows do not exceed numberOfItems
    rows = Math.min(rows, numberOfItems);
    // Given the rows, get the minimum columns needed to create enough cells for the number of items
    let columns = Math.ceil(numberOfItems / rows);
    // Default fill direction to horizontal
    let fillDirection = 'horizontal';
    while (rows < numberOfItems) {
        // If cell aspect ratio is less than MINIMUM_CELL_ASPECT_RATIO_ALLOWED then try more rows
        if ((rows / columns) * aspectRatio < MINIMUM_CELL_ASPECT_RATIO_ALLOWED) {
            rows += 1;
            columns = Math.ceil(numberOfItems / rows);
            continue;
        }
        if (numberOfItems < rows * columns) {
            // We need to check that stretching columns vertically will result in only one less cell in stretched columns.
            // Likewise, we need to check that stretching rows horizonally will result in only one less cell in stretched rows.
            // e.g. For 4 rows, 2 columns, but only 6 items, we cannot stretch vertically because that would result in a
            // column of 2 cells which is less by more than 1 compared to the unstretched column.
            //  _________
            // |____|    |
            // |____|____|
            // |____|    |
            // |____|____|
            const canStretchVertically = numberOfItems >= rows + (columns - 1) * (rows - 1);
            const canStretchHorizontally = numberOfItems >= columns + (rows - 1) * (columns - 1);
            if (!canStretchVertically && !canStretchHorizontally) {
                rows += 1;
                columns = Math.ceil(numberOfItems / rows);
                continue;
            }
            else if (!canStretchVertically) {
                break;
            }
            else if (!canStretchHorizontally) {
                fillDirection = 'vertical';
                break;
            }
            // We need to figure out whether the big cells should stretch horizontally or vertically
            // to fill in the empty spaces
            // e.g. For 2 rows, 3 columns, but only 5 items, we need to choose whether to stretch cells
            //       horizontally            or           vertically
            //  ______________________               _______________________
            // |       |       |      |             |       |       |       |
            // |_______|_______|______|             |_______|_______|       |
            // |           |          |             |       |       |       |
            // |___________|__________|             |_______|_______|_______|
            // Calculate the aspect ratio of big cells stretched horizontally
            const horizontallyStretchedCellRatio = (rows / (columns - 1)) * aspectRatio;
            // Calculate the aspect ratio of big cells stretched vertically
            const verticallyStretchedCellRatio = ((rows - 1) / columns) * aspectRatio;
            // We know the horizontally stretched cells aspect ratio is higher than MINIMUM_CELL_ASPECT_RATIO_ALLOWED. If vertically stretched cells
            // is also higher than the MINIMUM_CELL_ASPECT_RATIO_ALLOWED, then choose which aspect ratio is better.
            if (verticallyStretchedCellRatio >= MINIMUM_CELL_ASPECT_RATIO_ALLOWED) {
                // If vertically stetched cell has an aspect ratio closer to TARGET_CELL_ASPECT_RATIO then change the fill direction to vertical
                if (isCloserThan(verticallyStretchedCellRatio, horizontallyStretchedCellRatio, TARGET_CELL_ASPECT_RATIO)) {
                    fillDirection = 'vertical';
                }
            }
        }
        break;
    }
    return { fillDirection, rows, columns };
};
/**
 * Creates a styles classname with CSS Grid related styles given GridProps and the number of items to distribute as evenly as possible.
 * @param numberOfItems - number of items to place in grid
 * @param gridProps - GridProps that define the number of rows, number of columns, and the fill direction
 * @returns - classname
 */
const createGridStyles = (numberOfItems, gridProps) => {
    const isHorizontal = gridProps.fillDirection === 'horizontal';
    // Blocks are either rows or columns depending on whether we fill horizontally or vertically. Each block may differ in the number of cells.
    const blocks = isHorizontal ? gridProps.rows : gridProps.columns;
    const smallCellsPerBlock = Math.ceil(numberOfItems / blocks);
    const bigCellsPerBlock = Math.floor(numberOfItems / blocks);
    const numBigCells = (gridProps.rows * gridProps.columns - numberOfItems) * bigCellsPerBlock;
    // Get grid units
    // e.g. If some blocks have 2 big cells while others have 3 small cells, we need to work with 6 units per block
    const units = smallCellsPerBlock * bigCellsPerBlock;
    const gridStyles = isHorizontal
        ? {
            gridTemplateColumns: `repeat(${units}, minmax(0, 1fr))`,
            gridTemplateRows: `repeat(${blocks}, minmax(0, 1fr))`,
            gridAutoFlow: 'row'
        }
        : {
            gridTemplateColumns: `repeat(${blocks}, minmax(0, 1fr))`,
            gridTemplateRows: `repeat(${units}, minmax(0, 1fr))`,
            gridAutoFlow: 'column'
        };
    const smallCellStyle = isHorizontal
        ? {
            '> *': {
                gridColumn: `auto / span ${units / smallCellsPerBlock}`
            }
        }
        : {
            '> *': {
                gridRow: `auto / span ${units / smallCellsPerBlock}`
            }
        };
    // If there are big cells, we are choosing to place the latest children into the big cells.
    // That is why we use the '> *:nth-last-child(-n + ${numBigCells})' CSS selector below
    const bigCellStyle = numBigCells
        ? {
            [`> *:nth-last-child(-n + ${numBigCells})`]: isHorizontal
                ? {
                    gridColumn: `auto / span ${units / bigCellsPerBlock}`
                }
                : {
                    gridRow: `auto / span ${units / bigCellsPerBlock}`
                }
        }
        : {};
    return react.mergeStyles(gridStyles, smallCellStyle, bigCellStyle);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const sendBoxStyleSet = {
    root: {
        padding: '0.25rem'
    }
};
/**
 * @private
 */
const sendBoxStyle = react.mergeStyles({
    paddingRight: '2rem'
});
/**
 * @private
 */
const sendButtonStyle = react.mergeStyles({
    height: '1.25rem',
    width: '1.25rem',
    marginTop: '0.563rem',
    marginRight: '0.313rem' // 5px
});
/**
 * @private
 */
const sendIconStyle = react.mergeStyles({
    width: '1.25rem',
    height: '1.25rem',
    margin: 'auto'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Preset light theme for components exported from this library.
 *
 * @public
 */
const lightTheme = {
    palette: {
        themePrimary: '#0078d4',
        themeLighterAlt: '#eff6fc',
        themeLighter: '#deecf9',
        themeLight: '#c7e0f4',
        themeTertiary: '#71afe5',
        themeSecondary: '#2b88d8',
        themeDarkAlt: '#106ebe',
        themeDark: '#59b0f7',
        themeDarker: '#004578',
        neutralLighterAlt: '#faf9f8',
        neutralLighter: '#f3f2f1',
        neutralLight: '#edebe9',
        neutralQuaternaryAlt: '#e1dfdd',
        neutralQuaternary: '#d0d0d0',
        neutralTertiaryAlt: '#c8c6c4',
        neutralTertiary: '#a19f9d',
        neutralSecondary: '#605e5c',
        neutralPrimaryAlt: '#3b3a39',
        neutralPrimary: '#323130',
        neutralDark: '#201f1e',
        black: '#000000',
        white: '#ffffff'
    },
    callingPalette: {
        callRed: '#c4314b',
        callRedDark: '#a42e43',
        callRedDarker: '#8b2c3d',
        iconWhite: '#ffffff'
    }
};
/**
 * Preset dark theme for components exported from this library.
 *
 * @public
 */
const darkTheme = {
    palette: {
        themePrimary: '#2899f5',
        themeLighterAlt: '#02060a',
        themeLighter: '#061827',
        themeLight: '#0c2e49',
        themeTertiary: '#185b93',
        themeSecondary: '#2286d7',
        themeDarkAlt: '#3ca2f6',
        themeDark: '#59b0f7',
        themeDarker: '#84c5f9',
        neutralLighterAlt: '#302e2d',
        neutralLighter: '#383735',
        neutralLight: '#464443',
        neutralQuaternaryAlt: '#4e4d4b',
        neutralQuaternary: '#4d4b49',
        neutralTertiaryAlt: '#72706e',
        neutralTertiary: '#c8c8c8',
        neutralSecondary: '#d0d0d0',
        neutralPrimaryAlt: '#dadada',
        neutralPrimary: '#ffffff',
        neutralDark: '#f4f4f4',
        black: '#f8f8f8',
        white: '#252423'
    },
    callingPalette: {
        callRed: '#a42e43',
        callRedDark: '#8b2c3d',
        callRedDarker: '#772a38',
        iconWhite: '#ffffff'
    }
};

// Copyright (c) Microsoft Corporation.
const wrapper = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'auto'
});
const defaultTheme = react.mergeThemes(react.getTheme(), lightTheme);
/** Theme context for library's react components */
const ThemeContext = React.createContext(defaultTheme);
const initialFluentNorthstarTheme = reactNorthstar.mergeThemes(reactNorthstar.teamsTheme, {
    componentVariables: {
        // suppressing chat message links style from teamsTheme to get better styling from Fluent UI Link
        ChatMessage: {
            linkColor: undefined,
            linkColorMine: undefined
        }
    },
    componentStyles: {
        ChatMessage: {
            root: {
                lineHeight: '1.4286'
            }
        }
    },
    fontFaces: [],
    siteVariables: {
        // suppressing body styles from teamsTheme to avoid inherited styling to other elements
        bodyPadding: undefined,
        bodyFontSize: undefined,
        bodyFontFamily: undefined,
        bodyBackground: undefined,
        bodyColor: undefined,
        bodyLineHeight: undefined
    }
});
/**
 * Provider to apply a Fluent theme across this library's react components.
 *
 * @remarks Components in this library are composed primarily from [Fluent UI](https://developer.microsoft.com/fluentui#/controls/web),
 * controls, and also from [Fluent React Northstar](https://fluentsite.z22.web.core.windows.net/0.53.0) controls.
 * This provider handles applying any theme provided to both the underlying Fluent UI controls, as well as the Fluent React Northstar controls.
 *
 * @public
 */
const FluentThemeProvider = (props) => {
    const { fluentTheme, rtl, children } = props;
    let fluentUITheme = react.mergeThemes(defaultTheme, fluentTheme);
    // merge in rtl from FluentThemeProviderProps
    fluentUITheme = react.mergeThemes(fluentUITheme, { rtl });
    const fluentNorthstarTheme = reactNorthstar.mergeThemes(initialFluentNorthstarTheme, {
        componentVariables: {
            Chat: {
                backgroundColor: fluentUITheme.palette.white
            },
            ChatMessage: {
                authorColor: fluentUITheme.palette.neutralPrimary,
                contentColor: fluentUITheme.palette.neutralPrimary,
                backgroundColor: fluentUITheme.palette.neutralLighter,
                backgroundColorMine: fluentUITheme.palette.themeLight
            }
        },
        componentStyles: {
            ChatMessage: {
                timestamp: {
                    WebkitTextFillColor: fluentUITheme.palette.neutralSecondary
                }
            }
        }
        // add more northstar components to align with Fluent UI theme
    });
    return (React__default['default'].createElement(ThemeContext.Provider, { value: fluentUITheme },
        React__default['default'].createElement(react.ThemeProvider, { theme: fluentUITheme, className: wrapper },
            React__default['default'].createElement(reactNorthstar.Provider, { theme: fluentNorthstarTheme, className: wrapper, rtl: rtl }, children))));
};
/**
 * React hook to access theme
 *
 * @public
 */
const useTheme = () => React.useContext(ThemeContext);

// Copyright (c) Microsoft Corporation.
const WifiWarning16Filled = () => (
// All ErrorBar icons are 16px x 16px (when 1rem = 16 px).
// There is no 16px version of this icon in the fluent icon package, so scale the larger
// one down to required size.
React__default['default'].createElement("div", { className: react.mergeStyles({ transform: 'scale(0.8)' }) },
    React__default['default'].createElement(reactIcons.WifiWarning20Filled, null)));
/**
 * The default set of icons that are available to use in the UI components.
 *
 * @remark Icons used only in the composites are available in {@link DEFAULT_COMPOSITE_ICONS}.
 *
 * @public
 */
const DEFAULT_COMPONENT_ICONS = {
    ControlButtonCameraOff: React__default['default'].createElement(reactIcons.VideoOff20Filled, null),
    ControlButtonCameraOn: React__default['default'].createElement(reactIcons.Video20Filled, null),
    ControlButtonEndCall: React__default['default'].createElement(reactIcons.CallEnd20Filled, null),
    ControlButtonMicOff: React__default['default'].createElement(reactIcons.MicOff20Filled, null),
    ControlButtonMicOn: React__default['default'].createElement(reactIcons.MicOn20Filled, null),
    ControlButtonOptions: React__default['default'].createElement(reactIcons.Settings20Filled, null),
    ControlButtonParticipants: React__default['default'].createElement(reactIcons.People20Filled, null),
    ControlButtonScreenShareStart: React__default['default'].createElement(reactIcons.ShareScreenStart20Filled, null),
    ControlButtonScreenShareStop: React__default['default'].createElement(reactIcons.ShareScreenStop20Filled, null),
    EditBoxCancel: React__default['default'].createElement(reactIcons.Dismiss20Regular, null),
    EditBoxSubmit: React__default['default'].createElement(reactIcons.Checkmark20Regular, null),
    ErrorBarCallCameraAccessDenied: React__default['default'].createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallCameraAlreadyInUse: React__default['default'].createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallLocalVideoFreeze: React__default['default'].createElement(WifiWarning16Filled, null),
    ErrorBarCallMacOsCameraAccessDenied: React__default['default'].createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallMacOsMicrophoneAccessDenied: React__default['default'].createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallMicrophoneAccessDenied: React__default['default'].createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallMicrophoneMutedBySystem: React__default['default'].createElement(reactIcons.MicOff16Filled, null),
    ErrorBarCallNetworkQualityLow: React__default['default'].createElement(WifiWarning16Filled, null),
    ErrorBarCallNoMicrophoneFound: React__default['default'].createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallNoSpeakerFound: React__default['default'].createElement(reactIcons.SpeakerMute16Filled, null),
    HorizontalGalleryLeftButton: React__default['default'].createElement(reactIcons.ChevronLeft20Regular, null),
    HorizontalGalleryRightButton: React__default['default'].createElement(reactIcons.ChevronRight20Regular, null),
    MessageDelivered: React__default['default'].createElement(reactIcons.CheckmarkCircle16Regular, null),
    MessageEdit: React__default['default'].createElement(reactIcons.Edit20Regular, null),
    MessageFailed: React__default['default'].createElement(reactIcons.ErrorCircle16Regular, null),
    MessageRemove: React__default['default'].createElement(reactIcons.Delete20Regular, null),
    MessageSeen: React__default['default'].createElement(reactIcons.EyeShow16Regular, null),
    MessageSending: React__default['default'].createElement(reactIcons.Circle16Regular, null),
    OptionsCamera: React__default['default'].createElement(reactIcons.Video20Regular, null),
    OptionsMic: React__default['default'].createElement(reactIcons.MicOn20Regular, null),
    OptionsSpeaker: React__default['default'].createElement(reactIcons.Speaker220Regular, null),
    ParticipantItemMicOff: React__default['default'].createElement(reactIcons.MicOff16Regular, null),
    ParticipantItemOptions: React__default['default'].createElement(reactIcons.MoreHorizontal20Regular, null),
    ParticipantItemOptionsHovered: React__default['default'].createElement(reactIcons.MoreHorizontal20Filled, null),
    ParticipantItemScreenShareStart: React__default['default'].createElement(reactIcons.ShareScreenStart20Filled, null),
    SendBoxSend: React__default['default'].createElement(reactIcons.Send20Regular, null),
    SendBoxSendHovered: React__default['default'].createElement(reactIcons.Send20Filled, null),
    VideoTileMicOff: React__default['default'].createElement(reactIcons.MicOff16Filled, null)
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const inputBoxWrapperStyle = react.mergeStyles({
    padding: '0'
});
/**
 * @private
 */
const inputBoxStyle = react.mergeStyles({
    overflow: 'auto',
    minHeight: '2.25rem',
    maxHeight: '8.25rem',
    outline: 'red 5px',
    fontWeight: react.FontWeights.regular,
    fontSize: '0.875rem',
    width: '100%',
    height: '2.25rem',
    lineHeight: '1.5rem',
    '::-webkit-input-placeholder': {
        fontSize: '0.875rem'
    },
    '::-moz-placeholder': {
        fontSize: '0.875rem'
    },
    ':-moz-placeholder': {
        fontSize: '0.875rem'
    }
});
/**
 * @private
 */
const inputBoxNewLineSpaceAffordance = {
    marginBottom: '2rem'
};
/**
 *
 * @private
 */
const textContainerStyle = {
    alignSelf: 'center',
    position: 'relative',
    width: '100%'
};
/**
 * @private
 */
const textFieldStyle = (errorColor, hasErrorMessage, disabled) => {
    const borderColor = hasErrorMessage ? errorColor : 'none';
    return {
        root: {
            width: '100%',
            minHeight: '0',
            fontSize: '8.25rem'
        },
        wrapper: {},
        fieldGroup: {
            height: 'auto',
            minHeight: '0',
            borderRadius: '0.25rem',
            borderColor: borderColor,
            borderWidth: disabled ? '0px' : '1px',
            ':hover': { borderColor: borderColor },
            ':active': { borderColor: borderColor },
            ':after': { borderColor: borderColor, borderRadius: '0.25rem' }
        },
        field: {
            borderRadius: '0.25rem'
        },
        errorMessage: {
            color: errorColor
        }
    };
};
/**
 * @private
 */
const inputButtonStyle = react.mergeStyles({
    color: 'grey',
    margin: 'auto',
    width: '1.0625rem',
    height: '1.0625rem',
    '&:hover': {
        backgroundColor: 'transparent'
    }
});
/**
 * @private
 */
const inlineButtonsContainerStyle = {
    position: 'absolute',
    right: '0.3rem',
    top: '0',
    bottom: '0',
    gap: '0.25rem'
};
/**
 * @private
 */
const newLineButtonsContainerStyle = {
    position: 'absolute',
    right: '0.8rem',
    bottom: '0.8rem',
    gap: '1rem'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const isDarkThemed = (theme) => {
    const themeBlackBrightness = getPerceptualBrightnessOfHexColor(theme.palette.black);
    const themeWhiteBrightness = getPerceptualBrightnessOfHexColor(theme.palette.white);
    if (Number.isNaN(themeBlackBrightness) || Number.isNaN(themeWhiteBrightness)) {
        return false;
    }
    return themeBlackBrightness > themeWhiteBrightness;
};
const getPerceptualBrightnessOfHexColor = (hexColor) => {
    // return NaN if hexColor is not a hex code
    if (!/^#[0-9A-Fa-f]{6}$/i.test(hexColor)) {
        return NaN;
    }
    const r = parseInt(hexColor.substring(1, 3), 16);
    const g = parseInt(hexColor.substring(3, 5), 16);
    const b = parseInt(hexColor.substring(5, 7), 16);
    // arithmetic mean μ of the red, green, and blue color coordinates. Source: https://en.wikipedia.org/wiki/Brightness
    return (r + g + b) / 3;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const InputBoxComponent = (props) => {
    const { styles, id, 'data-ui-id': dataUiId, textValue, onChange, textFieldRef, placeholderText, onKeyDown, onEnterKeyDown, supportNewline, inputClassName, errorMessage, disabled, children } = props;
    const theme = useTheme();
    const mergedRootStyle = react.mergeStyles(inputBoxWrapperStyle, styles === null || styles === void 0 ? void 0 : styles.root);
    const mergedTextFiledStyle = react.mergeStyles(inputBoxStyle, inputClassName, props.inlineChildren ? {} : inputBoxNewLineSpaceAffordance);
    const mergedTextContainerStyle = react.mergeStyles(textContainerStyle, styles === null || styles === void 0 ? void 0 : styles.textFieldContainer);
    const mergedTextFieldStyle = react.concatStyleSets(textFieldStyle(isDarkThemed(theme) ? '#f1707b' : '#a80000', !!errorMessage, !!disabled), {
        fieldGroup: styles === null || styles === void 0 ? void 0 : styles.textField,
        errorMessage: styles === null || styles === void 0 ? void 0 : styles.systemMessage
    });
    const onTexFieldKeyDown = React.useCallback((ev) => {
        if (ev.key === 'Enter' && (ev.shiftKey === false || !supportNewline)) {
            ev.preventDefault();
            onEnterKeyDown && onEnterKeyDown();
        }
        onKeyDown && onKeyDown(ev);
    }, [onEnterKeyDown, onKeyDown, supportNewline]);
    return (React__default['default'].createElement(react.Stack, { className: mergedRootStyle },
        React__default['default'].createElement("div", { className: mergedTextContainerStyle },
            React__default['default'].createElement(react.TextField, { "data-ui-id": dataUiId, multiline: true, autoAdjustHeight: true, multiple: false, resizable: false, componentRef: textFieldRef, id: id, inputClassName: mergedTextFiledStyle, placeholder: placeholderText, value: textValue, onChange: onChange, autoComplete: "off", onKeyDown: onTexFieldKeyDown, styles: mergedTextFieldStyle, disabled: disabled, errorMessage: errorMessage }),
            React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(props.inlineChildren ? inlineButtonsContainerStyle : newLineButtonsContainerStyle) }, children))));
};
/**
 * @private
 */
const InputBoxButton = (props) => {
    const { onRenderIcon, onClick, ariaLabel, className, id } = props;
    const [isHover, setIsHover] = React.useState(false);
    const mergedButtonStyle = react.mergeStyles(inputButtonStyle, className);
    return (React__default['default'].createElement(react.IconButton, { className: mergedButtonStyle, ariaLabel: ariaLabel, onClick: onClick, id: id, onMouseEnter: () => {
            setIsHover(true);
        }, onMouseLeave: () => {
            setIsHover(false);
        }, onRenderIcon: () => onRenderIcon(isHover) }));
};

// Copyright (c) Microsoft Corporation.
const EMPTY_MESSAGE_REGEX = /^\s*$/;
const MAXIMUM_LENGTH_OF_MESSAGE$1 = 8000;
/**
 * Component for typing and sending messages.
 *
 * Supports sending typing notification when user starts entering text.
 * Supports an optional message below the text input field.
 *
 * @public
 */
const SendBox = (props) => {
    const { disabled, systemMessage, supportNewline, onSendMessage, onTyping, onRenderIcon, onRenderSystemMessage, styles } = props;
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.sendBox;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const ids = useIdentifiers();
    const [textValue, setTextValue] = React.useState('');
    const [textValueOverflow, setTextValueOverflow] = React.useState(false);
    const sendTextFieldRef = React__default['default'].useRef(null);
    const sendMessageOnClick = () => {
        var _a;
        // don't send a message when disabled
        if (disabled || textValueOverflow) {
            return;
        }
        // we dont want to send empty messages including spaces, newlines, tabs
        if (!EMPTY_MESSAGE_REGEX.test(textValue)) {
            onSendMessage && onSendMessage(textValue);
            setTextValue('');
        }
        (_a = sendTextFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const setText = (event, newValue) => {
        if (newValue === undefined) {
            return;
        }
        if (newValue.length > MAXIMUM_LENGTH_OF_MESSAGE$1) {
            setTextValueOverflow(true);
        }
        else {
            setTextValueOverflow(false);
        }
        setTextValue(newValue);
    };
    const textTooLongMessage = textValueOverflow ? strings.textTooLong : undefined;
    const errorMessage = systemMessage !== null && systemMessage !== void 0 ? systemMessage : textTooLongMessage;
    const mergedSendButtonStyle = React.useMemo(() => react.mergeStyles(sendButtonStyle, styles === null || styles === void 0 ? void 0 : styles.sendMessageIconContainer), [styles === null || styles === void 0 ? void 0 : styles.sendMessageIconContainer]);
    const mergedStyles = React.useMemo(() => react.concatStyleSets(sendBoxStyleSet, styles), [styles]);
    const hasText = !!textValue;
    const mergedSendIconStyle = React.useMemo(() => react.mergeStyles(sendIconStyle, {
        color: !!errorMessage || !hasText ? theme.palette.neutralTertiary : theme.palette.themePrimary
    }, styles === null || styles === void 0 ? void 0 : styles.sendMessageIcon), [errorMessage, hasText, theme, styles === null || styles === void 0 ? void 0 : styles.sendMessageIcon]);
    const onRenderSendIcon = React.useCallback((isHover) => onRenderIcon ? (onRenderIcon(isHover)) : (React__default['default'].createElement(react.Icon, { iconName: isHover ? 'SendBoxSendHovered' : 'SendBoxSend', className: mergedSendIconStyle })), [mergedSendIconStyle, onRenderIcon]);
    return (React__default['default'].createElement(InputBoxComponent, { "data-ui-id": ids.sendboxTextField, inlineChildren: true, disabled: disabled, errorMessage: onRenderSystemMessage ? onRenderSystemMessage(errorMessage) : errorMessage, textFieldRef: sendTextFieldRef, id: "sendbox", inputClassName: sendBoxStyle, placeholderText: strings.placeholderText, textValue: textValue, onChange: setText, onKeyDown: () => {
            onTyping && onTyping();
        }, onEnterKeyDown: () => {
            sendMessageOnClick();
        }, styles: mergedStyles, supportNewline: supportNewline, maxLength: MAXIMUM_LENGTH_OF_MESSAGE$1 },
        React__default['default'].createElement(InputBoxButton, { onRenderIcon: onRenderSendIcon, onClick: (e) => {
                if (!textValueOverflow) {
                    sendMessageOnClick();
                }
                e.stopPropagation();
            }, id: 'sendIconWrapper', className: mergedSendButtonStyle })));
};

// Copyright (c) Microsoft Corporation.
/** @private */
const MESSAGE_STATUS_INDICATOR_SIZE_REM = 1;
/**
 * ErrorIcon seems designed slightly smaller than other icons we try to match the size and then fix positioning here.
 *
 * @private
 */
const MessageStatusIndicatorErrorIconStyle = react.mergeStyles({
    marginRight: '-0.06rem',
    fontSize: '1.06rem'
});
/**
 * @private
 */
const MessageStatusIndicatorIconStyle = react.mergeStyles({
    fontSize: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`,
    width: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`,
    height: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`
});

// Copyright (c) Microsoft Corporation.
/**
 * Component to display the status of a sent message.
 *
 * Adds an icon and tooltip corresponding to the message status.
 *
 * @public
 */
const MessageStatusIndicator = (props) => {
    const { status, styles } = props;
    const localeStrings = useLocale$1().strings.messageStatusIndicator;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = useTheme();
    switch (status) {
        case 'failed':
            return (React__default['default'].createElement(react.TooltipHost, { content: strings.failedToSendTooltipText },
                React__default['default'].createElement(react.Icon, { role: "status", "aria-label": strings.failedToSendTooltipText, iconName: "MessageFailed", className: react.mergeStyles(MessageStatusIndicatorErrorIconStyle, { color: theme.palette.redDark }, styles === null || styles === void 0 ? void 0 : styles.root) })));
        case 'sending':
            return (React__default['default'].createElement(react.TooltipHost, { content: strings.sendingTooltipText },
                React__default['default'].createElement(react.Icon, { role: "status", "aria-label": strings.sendingTooltipText, iconName: "MessageSending", className: react.mergeStyles(MessageStatusIndicatorIconStyle, { color: theme.palette.themePrimary }, styles === null || styles === void 0 ? void 0 : styles.root) })));
        case 'seen':
            return (React__default['default'].createElement(react.TooltipHost, { content: strings.seenTooltipText },
                React__default['default'].createElement(react.Icon, { role: "status", "aria-label": strings.seenTooltipText, iconName: "MessageSeen", className: react.mergeStyles({ color: theme.palette.themePrimary }, styles === null || styles === void 0 ? void 0 : styles.root) })));
        case 'delivered':
            return (React__default['default'].createElement(react.TooltipHost, { content: strings.deliveredTooltipText },
                React__default['default'].createElement(react.Icon, { role: "status", "aria-label": strings.deliveredTooltipText, iconName: "MessageDelivered", className: react.mergeStyles(MessageStatusIndicatorIconStyle, { color: theme.palette.themePrimary }, styles === null || styles === void 0 ? void 0 : styles.root) })));
        default:
            return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
};

// Copyright (c) Microsoft Corporation.
// Minimum chat bubble width. This matches the minimum chat bubble width from FluentUI
// that can contain a message and a timestamp.
const CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM = 6.25;
// Chat messages should span just short of the width of the container.
// When calculating the width of a message we also must take into account
// the width of the avatar/gutter and the gap between the message and avatar/gutter.
const AVATAR_WIDTH_REM = 2;
const AVATAR_MESSAGE_GAP_REM = 0.5;
const MESSAGE_AMOUNT_OUT_FROM_EDGE_REM = 2;
// Avatars should display on top of chat messages when the chat thread is narrow
const MESSAGE_AVATAR_OVERLAP_REM = 0.425;
const CHAT_MESSAGE_ZINDEX = 1;
const AVATAR_ZINDEX = 2;
/**
 * @private
 */
const messageThreadContainerStyle = react.mergeStyles({
    height: '100%',
    width: '100%',
    maxHeight: '100%',
    overflow: 'auto',
    position: 'relative',
    alignSelf: 'center'
});
/**
 * @private
 */
const noMessageStatusStyle = react.mergeStyles({
    // This should match the size of the message status indicator icon to ensure
    // multiple messages sent by the user are aligned correctly.
    width: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`
});
/**
 * @private
 */
const chatStyle = {
    paddingBottom: '0.5rem',
    paddingTop: '0.8rem',
    border: 'none',
    overflow: 'auto'
};
/**
 * @private
 */
const newMessageButtonContainerStyle = react.mergeStyles({
    position: 'absolute',
    zIndex: 1,
    bottom: 0,
    right: '1.5rem'
});
/**
 * @private
 */
const defaultChatItemMessageContainer = (overlapAvatarAndMessage) => {
    const messageAvatarGap = overlapAvatarAndMessage ? -MESSAGE_AVATAR_OVERLAP_REM : AVATAR_MESSAGE_GAP_REM;
    return {
        marginRight: '0rem',
        marginLeft: `${messageAvatarGap}rem`,
        width: `calc(100% - ${AVATAR_WIDTH_REM + MESSAGE_AMOUNT_OUT_FROM_EDGE_REM + messageAvatarGap}rem)`,
        zIndex: CHAT_MESSAGE_ZINDEX
    };
};
/**
 * @private
 */
const defaultMyChatMessageContainer = {
    maxWidth: '100%',
    minWidth: `${CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM}rem`,
    marginLeft: '0rem'
};
/**
 * @private
 */
const defaultChatMessageContainer = {
    maxWidth: '100%',
    minWidth: `${CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM}rem`,
    marginRight: '0rem'
};
/**
 * @private
 */
const gutterWithAvatar = {
    width: `${AVATAR_WIDTH_REM}`,
    position: 'relative',
    float: 'left',
    display: 'block',
    visibility: 'visible',
    zIndex: AVATAR_ZINDEX
};
/**
 * @private
 */
const gutterWithHiddenAvatar = Object.assign(Object.assign({}, gutterWithAvatar), { visibility: 'hidden', 
    // we use this hidden avatar just as a width placeholder
    // the placeholder is needed for responsive bubble width
    height: 0 });
/**
 * @private
 */
const messageStatusContainerStyle = (mine) => react.mergeStyles({
    marginLeft: mine ? '0.25rem' : '0rem'
});
/**
 * @private
 */
const newMessageButtonStyle = react.mergeStyles({
    float: 'right',
    width: 'fit-content'
});
/**
 * @private
 */
const buttonWithIconStyles$1 = {
    textContainer: {
        display: 'contents'
    }
};
/**
 * @private
 */
react.mergeStyles({
    border: 'none',
    minHeight: '1.5rem',
    '&:hover': { background: 'none' },
    '&:active': { background: 'none' }
});
/**
 * @private
 */
const DownIconStyle = react.mergeStyles({
    marginRight: '0.5em'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const delay = (delay) => {
    return new Promise(function (resolve) {
        setTimeout(resolve, delay);
    });
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const systemMessageIconStyle = react.mergeStyles({
    margin: '0 0.688rem 0 0'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const SystemMessage = (props) => {
    const { iconName, content } = props;
    const Icon = React__default['default'].createElement(react.FontIcon, { iconName: iconName, className: react.mergeStyles(systemMessageIconStyle) });
    return (React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(props === null || props === void 0 ? void 0 : props.containerStyle) },
        Icon,
        React__default['default'].createElement(react.Text, { style: { wordBreak: 'break-word' }, role: "status", title: content }, content)));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const editBoxStyle = (inlineEditButtons) => react.mergeStyles({
    marginTop: '0.0875rem',
    marginBottom: '0.0875rem',
    // @TODO future refactor: This is being used to give enough space to the accept/reject edits buttons
    // This space affordance should be handled by the InputBoxComponent not the here (by the parent of the InputBoxComponent)
    paddingRight: inlineEditButtons ? '3.25rem' : '0.5rem'
});
/**
 * @private
 */
const editingButtonStyle = react.mergeStyles({
    margin: 'auto .3rem'
});
/**
 * @private
 */
const inputBoxIcon = react.mergeStyles({
    margin: 'auto',
    '&:hover svg': {
        stroke: 'currentColor'
    }
});
/**
 * @private
 */
const editBoxStyleSet = {
    root: {
        width: '100%'
    }
};

// Copyright (c) Microsoft Corporation.
const MAXIMUM_LENGTH_OF_MESSAGE = 8000;
const onRenderCancelIcon = (color) => {
    const className = react.mergeStyles(inputBoxIcon, { color });
    return React__default['default'].createElement(react.Icon, { iconName: 'EditBoxCancel', className: className });
};
const onRenderSubmitIcon = (color) => {
    const className = react.mergeStyles(inputBoxIcon, { color });
    return React__default['default'].createElement(react.Icon, { iconName: 'EditBoxSubmit', className: className });
};
/**
 * @private
 */
const ChatMessageComponentAsEditBox = (props) => {
    const { onCancel, onSubmit, initialValue, strings } = props;
    const [textValue, setTextValue] = React.useState(initialValue);
    const [textValueOverflow, setTextValueOverflow] = React.useState(false);
    const editTextFieldRef = React__default['default'].useRef(null);
    const theme = useTheme();
    React.useEffect(() => {
        var _a;
        (_a = editTextFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, []);
    const setText = (event, newValue) => {
        if (newValue === undefined) {
            return;
        }
        if (newValue.length > MAXIMUM_LENGTH_OF_MESSAGE) {
            setTextValueOverflow(true);
        }
        else {
            setTextValueOverflow(false);
        }
        setTextValue(newValue);
    };
    const textTooLongMessage = textValueOverflow
        ? _formatString(strings.editBoxTextLimit, { limitNumber: `${MAXIMUM_LENGTH_OF_MESSAGE}` })
        : undefined;
    const onRenderThemedCancelIcon = React.useCallback(() => onRenderCancelIcon(theme.palette.neutralSecondary), [theme.palette.neutralSecondary]);
    const onRenderThemedSubmitIcon = React.useCallback(() => onRenderSubmitIcon(theme.palette.neutralSecondary), [theme.palette.neutralSecondary]);
    const editBoxStyles = React.useMemo(() => {
        return react.concatStyleSets(editBoxStyleSet, { textField: { borderColor: theme.palette.themePrimary } });
    }, [theme.palette.themePrimary]);
    return (React__default['default'].createElement(InputBoxComponent, { inlineChildren: props.inlineEditButtons, id: 'editbox', textFieldRef: editTextFieldRef, inputClassName: editBoxStyle(props.inlineEditButtons), placeholderText: strings.editBoxPlaceholderText, textValue: textValue, onChange: setText, onEnterKeyDown: () => {
            onSubmit(textValue);
        }, supportNewline: false, maxLength: MAXIMUM_LENGTH_OF_MESSAGE, errorMessage: textTooLongMessage, styles: editBoxStyles },
        React__default['default'].createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxCancelButton, onRenderIcon: onRenderThemedCancelIcon, onClick: () => {
                onCancel && onCancel();
            }, id: 'dismissIconWrapper' }),
        React__default['default'].createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxSubmitButton, onRenderIcon: onRenderThemedSubmitIcon, onClick: (e) => {
                if (!textValueOverflow && textValue !== '') {
                    onSubmit(textValue);
                }
                e.stopPropagation();
            }, id: 'submitIconWrapper' })));
};

// Copyright (c) Microsoft Corporation.
const MINIMUM_TOUCH_TARGET_HEIGHT_REM$1 = 3;
/**
 * @private
 */
const chatActionsCSS = {
    'ul&': {
        right: '0',
        left: 'auto',
        top: '-1.625rem',
        bottom: 'auto',
        position: 'absolute'
    },
    '& a': {
        margin: '0',
        padding: '0',
        border: '0'
    }
};
/**
 * @private
 */
const iconWrapperStyle = react.mergeStyles({
    padding: '0.375rem',
    webkitBoxPack: 'center',
    justifyContent: 'center'
});
/**
 * @private
 */
const chatMessageDateStyle = react.mergeStyles({ fontWeight: react.FontWeights.semibold });
/**
 * @private
 */
const chatMessageEditedTagStyle = (theme) => react.mergeStyles({ fontWeight: react.FontWeights.semibold, color: theme.palette.neutralSecondary });
/**
 * @private
 */
const chatMessageMenuStyle = react.mergeStyles({
    minWidth: '8.5rem',
    cursor: 'pointer'
});
/**
 * Styles that can be applied to ensure flyout items have the minimum touch target size.
 *
 * @private
 */
const menuItemIncreasedSizeStyles = {
    root: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        maxHeight: 'unset'
    },
    linkContent: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        maxHeight: 'unset'
    },
    icon: {
        maxHeight: 'unset'
    }
};
/**
 * @private
 */
const menuIconStyleSet = {
    root: {
        height: 'calc(100% - 8px)',
        width: '1.25rem'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const formatTimeForChatMessage = (messageDate) => {
    let hours = messageDate.getHours();
    let minutes = messageDate.getMinutes().toString();
    const isAm = hours < 12;
    if (hours > 12) {
        hours = hours - 12;
    }
    if (hours === 0) {
        hours = 12;
    }
    if (minutes.length < 2) {
        minutes = '0' + minutes;
    }
    return hours.toString() + ':' + minutes + ' ' + (isAm ? 'a.m.' : 'p.m.');
};
/**
 * @private
 */
const formatDateForChatMessage = (messageDate) => {
    const year = messageDate.getFullYear().toString();
    let month = (messageDate.getMonth() + 1).toString();
    let day = messageDate.getDate().toString();
    if (month.length === 1) {
        month = '0' + month;
    }
    if (day.length === 1) {
        day = '0' + day;
    }
    return year + '-' + month + '-' + day;
};
/**
 * Given a message date object in ISO8601 and a current date object, generates a user friendly timestamp text like the
 * following:
 *
 * 1:30 p.m.
 * Yesterday 1:30 p.m.
 * Monday 1:30 p.m.
 * 2021-01-10 1:30 p.m.
 *
 * If message is after yesterday, then only show the time.
 * If message is before yesteray and after day before yesterday, then show 'Yesterday' plus the time.
 * If message is before day before yesterday and within the current week, then show 'Monday/Tuesday/etc' plus the time.
 *   - We consider start of the week as Sunday. If current day is Sunday, then any time before that is in previous week.
 * If message is in previous or older weeks, then show date string plus the time.
 *
 * @param messageDate - date of message
 * @param currentDate - date used as offset to create the user friendly timestamp (e.g. to create 'Yesterday' instead of an absolute date)
 *
 * @private
 */
const formatTimestampForChatMessage = (messageDate, todayDate, dateStrings) => {
    // If message was in the same day timestamp string is just the time like '1:30 p.m.'.
    const startOfDay = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate());
    if (messageDate > startOfDay) {
        return formatTimeForChatMessage(messageDate);
    }
    // If message was yesterday then timestamp string is like this 'Yesterday 1:30 p.m.'.
    const yesterdayDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate() - 1);
    if (messageDate > yesterdayDate) {
        return dateStrings.yesterday + ' ' + formatTimeForChatMessage(messageDate);
    }
    // If message was before Sunday and today is Sunday (start of week) then timestamp string is like
    // '2021-01-10 1:30 p.m.'.
    const weekDay = todayDate.getDay();
    if (weekDay === 0) {
        return formatDateForChatMessage(messageDate) + ' ' + formatTimeForChatMessage(messageDate);
    }
    // If message was before first day of the week then timestamp string is like Monday 1:30 p.m.
    const firstDayOfTheWeekDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate() - weekDay);
    if (messageDate > firstDayOfTheWeekDate) {
        return dayToDayName(messageDate.getDay(), dateStrings) + ' ' + formatTimeForChatMessage(messageDate);
    }
    // If message date is in previous or older weeks then timestamp string is like 2021-01-10 1:30 p.m.
    return formatDateForChatMessage(messageDate) + ' ' + formatTimeForChatMessage(messageDate);
};
const dayToDayName = (day, dateStrings) => {
    switch (day) {
        case 0:
            return dateStrings.sunday;
        case 1:
            return dateStrings.monday;
        case 2:
            return dateStrings.tuesday;
        case 3:
            return dateStrings.wednesday;
        case 4:
            return dateStrings.thursday;
        case 5:
            return dateStrings.friday;
        case 6:
            return dateStrings.saturday;
        default:
            throw new Error(`Invalid day [${day}] passed`);
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * Chat message actions flyout that contains actions such as Edit Message, or Remove Message.
 *
 * @private
 */
const ChatMessageActionFlyout = (props) => {
    const menuItems = React.useMemo(() => [
        {
            key: 'Edit',
            text: props.strings.editMessage,
            itemProps: { styles: props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined },
            iconProps: { iconName: 'MessageEdit', styles: menuIconStyleSet },
            onClick: props.onEditClick
        },
        {
            key: 'Remove',
            text: props.strings.removeMessage,
            itemProps: { styles: props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined },
            iconProps: {
                iconName: 'MessageRemove',
                styles: menuIconStyleSet
            },
            onClick: props.onRemoveClick
        }
    ], [
        props.increaseFlyoutItemSize,
        props.onEditClick,
        props.onRemoveClick,
        props.strings.editMessage,
        props.strings.removeMessage
    ]);
    // gap space uses pixels
    return (React__default['default'].createElement(react.ContextualMenu, { alignTargetEdge: true, gapSpace: 5 /*px*/, isBeakVisible: false, items: menuItems, hidden: props.hidden, target: props.target, onDismiss: props.onDismiss, directionalHint: react.DirectionalHint.topRightEdge, className: chatMessageMenuStyle }));
};

// Copyright (c) Microsoft Corporation.
/** @private */
const ChatMessageContent = (props) => {
    switch (props.message.contentType) {
        case 'text':
            return MessageContentAsText(props.message, props.liveAuthorIntro);
        case 'html':
            return MessageContentAsRichTextHTML(props.message, props.liveAuthorIntro);
        case 'richtext/html':
            return MessageContentAsRichTextHTML(props.message, props.liveAuthorIntro);
        default:
            console.warn('unknown message content type');
            return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
};
const MessageContentAsRichTextHTML = (message, liveAuthorIntro) => {
    const htmlToReactParser = new htmlToReact.Parser();
    const liveAuthor = _formatString(liveAuthorIntro, { author: `${message.senderDisplayName}` });
    return (React__default['default'].createElement("div", { "data-ui-status": message.status },
        React__default['default'].createElement(reactAriaLive.LiveMessage, { message: `${message.mine ? '' : liveAuthor} ${extractContent(message.content || '')}`, "aria-live": "polite" }),
        htmlToReactParser.parse(message.content)));
};
const MessageContentAsText = (message, liveAuthorIntro) => {
    const liveAuthor = _formatString(liveAuthorIntro, { author: `${message.senderDisplayName}` });
    return (React__default['default'].createElement("div", { "data-ui-status": message.status },
        React__default['default'].createElement(reactAriaLive.LiveMessage, { message: `${message.mine ? '' : liveAuthor} ${message.content}`, "aria-live": "polite" }),
        React__default['default'].createElement(Linkify__default['default'], { componentDecorator: (decoratedHref, decoratedText, key) => {
                return (React__default['default'].createElement(react.Link, { target: "_blank", href: decoratedHref, key: key }, decoratedText));
            } }, message.content)));
};
// https://stackoverflow.com/questions/28899298/extract-the-text-out-of-html-string-using-javascript
const extractContent = (s) => {
    const span = document.createElement('span');
    span.innerHTML = s;
    return span.textContent || span.innerText;
};

// Copyright (c) Microsoft Corporation.
/**
 * Props for the Chat.Message action menu.
 * This is the 3 dots that appear when hovering over one of your own chat messages.
 *
 * @private
 */
const chatMessageActionMenuProps = (menuProps) => {
    if (!menuProps.enabled) {
        return undefined;
    }
    const menuClass = react.mergeStyles(chatActionsCSS, {
        'ul&': { boxShadow: menuProps.theme.effects.elevation4, backgroundColor: menuProps.theme.palette.white }
    });
    const actionMenuProps = {
        showActionMenu: menuProps.forceShow === true ? true : undefined,
        iconOnly: true,
        activeIndex: -1,
        className: menuClass,
        onItemClick: () => menuProps.onActionButtonClick(),
        items: [
            {
                children: (React__default['default'].createElement(reactNorthstar.Ref, { innerRef: menuProps.menuButtonRef },
                    React__default['default'].createElement(reactNorthstar.MoreIcon, Object.assign({ className: iconWrapperStyle }, {
                        outline: true
                    })))),
                key: 'menuButton',
                indicator: false
            }
        ]
    };
    return actionMenuProps;
};

// Copyright (c) Microsoft Corporation.
/** @private */
const ChatMessageComponentAsMessageBubble = (props) => {
    const ids = useIdentifiers();
    const theme = useTheme();
    const { message, onRemoveClick, disableEditing, showDate, messageContainerStyle, strings, onEditClick } = props;
    // Track if the action menu was opened by touch - if so we increase the touch targets for the items
    const [wasInteractionByTouch, setWasInteractionByTouch] = React.useState(false);
    // The chat message action flyout should target the Chat.Message action menu if clicked,
    // or target the chat message if opened via touch press.
    // Undefined indicates the flyout menu should not be being shown.
    const messageRef = React.useRef(null);
    const messageActionButtonRef = React.useRef(null);
    const [chatMessageActionFlyoutTarget, setChatMessageActionFlyoutTarget] = React.useState(undefined);
    const chatActionsEnabled = !disableEditing && message.status !== 'sending' && !!message.mine;
    const actionMenuProps = wasInteractionByTouch
        ? undefined
        : chatMessageActionMenuProps({
            enabled: chatActionsEnabled,
            menuButtonRef: messageActionButtonRef,
            // Force show the action button while the flyout is open (otherwise this will dismiss when the pointer is hovered over the flyout)
            forceShow: chatMessageActionFlyoutTarget === messageActionButtonRef,
            onActionButtonClick: () => {
                // Open chat action flyout, and set the context menu to target the chat message action button
                setChatMessageActionFlyoutTarget(messageActionButtonRef);
            },
            theme
        });
    const onActionFlyoutDismiss = React.useCallback(() => {
        // When the flyout dismiss is called, since we control if the action flyout is visible
        // or not we need to set the target to undefined here to actually hide the action flyout
        setChatMessageActionFlyoutTarget(undefined);
    }, [setChatMessageActionFlyoutTarget]);
    const chatMessage = (React__default['default'].createElement(React__default['default'].Fragment, null,
        React__default['default'].createElement("div", { ref: messageRef },
            React__default['default'].createElement(reactNorthstar.Chat.Message, { className: react.mergeStyles(messageContainerStyle), styles: messageContainerStyle, content: React__default['default'].createElement(ChatMessageContent, { message: message, liveAuthorIntro: strings.liveAuthorIntro }), author: React__default['default'].createElement(reactNorthstar.Text, { className: chatMessageDateStyle }, message.senderDisplayName), mine: message.mine, timestamp: React__default['default'].createElement(reactNorthstar.Text, { "data-ui-id": ids.messageTimestamp }, message.createdOn
                    ? showDate
                        ? formatTimestampForChatMessage(message.createdOn, new Date(), strings)
                        : formatTimeForChatMessage(message.createdOn)
                    : undefined), details: message.editedOn ? React__default['default'].createElement("div", { className: chatMessageEditedTagStyle(theme) }, strings.editedTag) : undefined, positionActionMenu: false, actionMenu: actionMenuProps, onTouchStart: () => setWasInteractionByTouch(true), onPointerDown: () => setWasInteractionByTouch(false), onKeyDown: () => setWasInteractionByTouch(false), onClick: () => wasInteractionByTouch && setChatMessageActionFlyoutTarget(messageRef) })),
        chatActionsEnabled && (React__default['default'].createElement(ChatMessageActionFlyout, { hidden: !chatMessageActionFlyoutTarget, target: chatMessageActionFlyoutTarget, increaseFlyoutItemSize: wasInteractionByTouch, onDismiss: onActionFlyoutDismiss, onEditClick: onEditClick, onRemoveClick: onRemoveClick, strings: strings }))));
    return chatMessage;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$j = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const ChatMessageComponent = (props) => {
    var _a;
    const [isEditing, setIsEditing] = React.useState(false);
    const onEditClick = React.useCallback(() => setIsEditing(true), [setIsEditing]);
    const { onDeleteMessage, message } = props;
    const onRemoveClick = React.useCallback(() => {
        if (onDeleteMessage && message.messageId) {
            onDeleteMessage(message.messageId);
        }
    }, [message.messageId, onDeleteMessage]);
    if (props.message.messageType !== 'chat') {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    else if (isEditing) {
        return (React__default['default'].createElement(ChatMessageComponentAsEditBox, { initialValue: (_a = props.message.content) !== null && _a !== void 0 ? _a : '', inlineEditButtons: props.inlineAcceptRejectEditButtons, strings: props.strings, onSubmit: (text) => __awaiter$j(void 0, void 0, void 0, function* () {
                props.onUpdateMessage &&
                    props.message.messageId &&
                    (yield props.onUpdateMessage(props.message.messageId, text));
                setIsEditing(false);
            }), onCancel: () => {
                setIsEditing(false);
            } }));
    }
    else {
        return React__default['default'].createElement(ChatMessageComponentAsMessageBubble, Object.assign({}, props, { onRemoveClick: onRemoveClick, onEditClick: onEditClick }));
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Converts units of rem to units of pixels
 * @param rem - units of rem
 * @returns units of pixels
 */
const convertRemToPx = (rem) => {
    return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
};

// Copyright (c) Microsoft Corporation.
/**
 * A utility hook for providing the width of a parent element.
 * Returns updated width if parent/window resizes.
 * @param containerRef - Ref of a parent element whose width will be returned.
 */
const useContainerWidth = (containerRef) => {
    const [width, setWidth] = React.useState(0);
    const observer = React.useRef(new ResizeObserver((entries) => {
        const { width } = entries[0].contentRect;
        setWidth(width);
    }));
    React.useEffect(() => {
        if (containerRef.current) {
            observer.current.observe(containerRef.current);
        }
        const currentObserver = observer.current;
        return () => {
            currentObserver.disconnect();
        };
    }, [containerRef, observer]);
    return width;
};
const NARROW_WIDTH_REM = 30;
/**
 * Utility function to determine if container width is narrow
 * @param containerWidthRem  container width in rem
 * @returns boolean
 */
const isNarrowWidth = (containerWidthRem) => containerWidthRem <= convertRemToPx(NARROW_WIDTH_REM);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$i = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const isMessageSame = (first, second) => {
    return (first.messageId === second.messageId &&
        first.content === second.content &&
        first.contentType === second.contentType &&
        JSON.stringify(first.createdOn) === JSON.stringify(second.createdOn) &&
        first.senderId === second.senderId &&
        first.senderDisplayName === second.senderDisplayName &&
        first.status === second.status);
};
/**
 * Get the latest message from the message array.
 *
 * @param messages
 */
const getLatestChatMessage = (messages) => {
    for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message.messageType === 'chat' && !!message.createdOn) {
            return message;
        }
    }
    return undefined;
};
/**
 * Compare latestMessageFromPreviousMessages & latestMessageFromNewMessages to see if the new message is not from
 * current user.
 */
const isThereNewMessageNotFromCurrentUser = (userId, latestMessageFromPreviousMessages, latestMessageFromNewMessages) => {
    if (latestMessageFromNewMessages === undefined) {
        return false;
    }
    if (latestMessageFromPreviousMessages === undefined) {
        return latestMessageFromNewMessages.senderId !== userId;
    }
    return (!isMessageSame(latestMessageFromNewMessages, latestMessageFromPreviousMessages) &&
        latestMessageFromNewMessages.senderId !== userId);
};
/**
 * Returns true if the current user sent the latest message and false otherwise. It will ignore messages that have no
 * sender, messages that have failed to send, and messages from the current user that is marked as SEEN. This is meant
 * as an indirect way to detect if user is at bottom of the chat when the component updates with new messages. If we
 * updated this component due to current user sending a message we want to then call scrollToBottom.
 */
const didUserSendTheLatestMessage = (userId, latestMessageFromPreviousMessages, latestMessageFromNewMessages) => {
    if (latestMessageFromNewMessages === undefined) {
        return false;
    }
    if (latestMessageFromPreviousMessages === undefined) {
        return latestMessageFromNewMessages.senderId === userId;
    }
    return (!isMessageSame(latestMessageFromNewMessages, latestMessageFromPreviousMessages) &&
        latestMessageFromNewMessages.senderId === userId);
};
const DefaultJumpToNewMessageButton = (props) => {
    const { text, onClick } = props;
    return (React__default['default'].createElement(react.PrimaryButton, { className: newMessageButtonStyle, styles: buttonWithIconStyles$1, text: text, onClick: onClick, onRenderIcon: () => React__default['default'].createElement(react.Icon, { iconName: "Down", className: DownIconStyle }) }));
};
const generateParticipantsStr = (participants, defaultName) => participants
    .map((participant) => `${!participant.displayName || participant.displayName === '' ? defaultName : participant.displayName}`)
    .join(', ');
const ParticipantSystemMessageComponent = ({ message, style, defaultName }) => {
    var _a;
    const { strings } = useLocale$1();
    const participantsStr = generateParticipantsStr(message.participants, defaultName);
    const messageSuffix = message.systemMessageType === 'participantAdded'
        ? strings.messageThread.participantJoined
        : strings.messageThread.participantLeft;
    if (participantsStr !== '') {
        return (React__default['default'].createElement(SystemMessage, { iconName: ((_a = message.iconName) !== null && _a !== void 0 ? _a : ''), content: `${participantsStr} ${messageSuffix}`, containerStyle: style }));
    }
    return React__default['default'].createElement(React__default['default'].Fragment, null);
};
const DefaultSystemMessage = (props) => {
    var _a, _b;
    const message = props.message;
    switch (message.messageType) {
        case 'system':
            switch (message.systemMessageType) {
                case 'content':
                    return (React__default['default'].createElement(SystemMessage, { iconName: ((_a = message.iconName) !== null && _a !== void 0 ? _a : ''), content: (_b = message.content) !== null && _b !== void 0 ? _b : '', containerStyle: props === null || props === void 0 ? void 0 : props.messageContainerStyle }));
                case 'participantAdded':
                case 'participantRemoved':
                    return (React__default['default'].createElement(ParticipantSystemMessageComponent, { message: message, style: props.messageContainerStyle, defaultName: props.strings.noDisplayNameSub }));
            }
    }
    return React__default['default'].createElement(React__default['default'].Fragment, null);
};
const memoizeAllMessages = memoizeFnAll((_messageKey, message, showMessageDate, showMessageStatus, onRenderAvatar, shouldOverlapAvatarAndMessage, styles, onRenderMessageStatus, defaultStatusRenderer, defaultChatMessageRenderer, strings, _attached, statusToRender, onRenderMessage, onUpdateMessage, onDeleteMessage) => {
    var _a, _b, _c;
    const messageProps = {
        message,
        strings,
        showDate: showMessageDate,
        onUpdateMessage,
        onDeleteMessage
    };
    switch (message.messageType) {
        case 'chat': {
            const myChatMessageStyle = (styles === null || styles === void 0 ? void 0 : styles.myChatMessageContainer) || defaultMyChatMessageContainer;
            const chatMessageStyle = (styles === null || styles === void 0 ? void 0 : styles.chatMessageContainer) || defaultChatMessageContainer;
            messageProps.messageContainerStyle = message.mine ? myChatMessageStyle : chatMessageStyle;
            const chatMessageComponent = onRenderMessage === undefined
                ? defaultChatMessageRenderer(messageProps)
                : onRenderMessage(messageProps, defaultChatMessageRenderer);
            const personaOptions = {
                hidePersonalDetails: true,
                size: react.PersonaSize.size32,
                text: message.senderDisplayName
            };
            const chatItemMessageStyle = (message.mine ? styles === null || styles === void 0 ? void 0 : styles.myChatItemMessageContainer : styles === null || styles === void 0 ? void 0 : styles.chatItemMessageContainer) ||
                defaultChatItemMessageContainer(shouldOverlapAvatarAndMessage);
            const chatGutterStyles = message.attached === 'top' || message.attached === false ? gutterWithAvatar : gutterWithHiddenAvatar;
            return {
                gutter: {
                    styles: chatGutterStyles,
                    content: message.mine ? ('') : onRenderAvatar ? (onRenderAvatar((_a = message.senderId) !== null && _a !== void 0 ? _a : '', personaOptions)) : (React__default['default'].createElement(react.Persona, Object.assign({}, personaOptions)))
                },
                contentPosition: message.mine ? 'end' : 'start',
                message: {
                    styles: chatItemMessageStyle,
                    content: (React__default['default'].createElement(reactNorthstar.Flex, { hAlign: message.mine ? 'end' : undefined, vAlign: "end" },
                        chatMessageComponent,
                        React__default['default'].createElement("div", { className: react.mergeStyles(messageStatusContainerStyle((_b = message.mine) !== null && _b !== void 0 ? _b : false), (styles === null || styles === void 0 ? void 0 : styles.messageStatusContainer) ? styles.messageStatusContainer((_c = message.mine) !== null && _c !== void 0 ? _c : false) : '') }, showMessageStatus && statusToRender ? (onRenderMessageStatus ? (onRenderMessageStatus({ status: statusToRender })) : (defaultStatusRenderer(statusToRender))) : (React__default['default'].createElement("div", { className: react.mergeStyles(noMessageStatusStyle) })))))
                },
                attached: message.attached,
                key: _messageKey
            };
        }
        case 'system': {
            messageProps.messageContainerStyle = styles === null || styles === void 0 ? void 0 : styles.systemMessageContainer;
            const systemMessageComponent = onRenderMessage === undefined ? (React__default['default'].createElement(DefaultSystemMessage, Object.assign({}, messageProps))) : (onRenderMessage(messageProps, (props) => React__default['default'].createElement(DefaultSystemMessage, Object.assign({}, props))));
            return {
                children: systemMessageComponent,
                key: _messageKey
            };
        }
        default: {
            // We do not handle custom type message by default, users can handle custom type by using onRenderMessage function.
            const customMessageComponent = onRenderMessage === undefined ? React__default['default'].createElement(React__default['default'].Fragment, null) : onRenderMessage(messageProps);
            return {
                children: customMessageComponent,
                key: _messageKey
            };
        }
    }
});
const getLastChatMessageIdWithStatus = (messages, status) => {
    for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message.messageType === 'chat' && message.status === status && message.mine) {
            return message.messageId;
        }
    }
    return undefined;
};
/**
 * `MessageThread` allows you to easily create a component for rendering chat messages, handling scrolling behavior of new/old messages and customizing icons & controls inside the chat thread.
 * @param props - of type MessageThreadProps
 *
 * Users will need to provide at least chat messages and userId to render the `MessageThread` component.
 * Users can also customize `MessageThread` by passing in their own Avatar, `MessageStatusIndicator` icon, `JumpToNewMessageButton`, `LoadPreviousMessagesButton` and the behavior of these controls.
 *
 * `MessageThread` internally uses the `Chat` & `Chat.Message` component from `@fluentui/react-northstar`. You can checkout the details about these [two components](https://fluentsite.z22.web.core.windows.net/0.53.0/components/chat/props).
 *
 * @public
 */
const MessageThread = (props) => {
    var _a;
    const { messages: newMessages, userId, styles, disableJumpToNewMessageButton = false, showMessageDate = false, showMessageStatus = false, numberOfChatMessagesToReload = 5, onMessageSeen, onRenderMessageStatus, onRenderAvatar, onLoadPreviousChatMessages, onRenderJumpToNewMessageButton, onRenderMessage, onUpdateMessage, onDeleteMessage } = props;
    const [messages, setMessages] = React.useState([]);
    // We need this state to wait for one tick and scroll to bottom after messages have been initialized.
    // Otherwise chatScrollDivRef.current.clientHeight is wrong if we scroll to bottom before messages are initialized.
    const [chatMessagesInitialized, setChatMessagesInitialized] = React.useState(false);
    const [isAtBottomOfScroll, setIsAtBottomOfScroll] = React.useState(true);
    const [forceUpdate, setForceUpdate] = React.useState(0);
    // Used to decide if should auto scroll to bottom or show "new message" button
    const [latestPreviousChatMessage, setLatestPreviousChatMessage] = React.useState(undefined);
    const [latestCurrentChatMessage, setLatestCurrentChatMessage] = React.useState(undefined);
    const [existsNewChatMessage, setExistsNewChatMessage] = React.useState(false);
    const [lastSeenChatMessage, setLastSeenChatMessage] = React.useState(undefined);
    const [lastDeliveredChatMessage, setLastDeliveredChatMessage] = React.useState(undefined);
    const [lastSendingChatMessage, setLastSendingChatMessage] = React.useState(undefined);
    const isAllChatMessagesLoadedRef = React.useRef(false);
    const previousTopRef = React.useRef(-1);
    const previousHeightRef = React.useRef(-1);
    const messageIdSeenByMeRef = React.useRef('');
    const chatScrollDivRef = React.useRef(null);
    const chatThreadRef = React.useRef(null);
    const isLoadingChatMessagesRef = React.useRef(false);
    // When the chat thread is narrow, we perform space optimizations such as overlapping
    // the avatar on top of the chat message and moving the chat accept/reject edit buttons
    // to a new line
    const chatThreadWidth = useContainerWidth(chatThreadRef);
    const isNarrow = isNarrowWidth(chatThreadWidth);
    const messagesRef = React.useRef(messages);
    const setMessagesRef = (messagesWithAttachedValue) => {
        messagesRef.current = messagesWithAttachedValue;
        setMessages(messagesWithAttachedValue);
    };
    const isAtBottomOfScrollRef = React.useRef(isAtBottomOfScroll);
    const setIsAtBottomOfScrollRef = (isAtBottomOfScrollValue) => {
        isAtBottomOfScrollRef.current = isAtBottomOfScrollValue;
        setIsAtBottomOfScroll(isAtBottomOfScrollValue);
    };
    const chatMessagesInitializedRef = React.useRef(chatMessagesInitialized);
    const setChatMessagesInitializedRef = (chatMessagesInitialized) => {
        chatMessagesInitializedRef.current = chatMessagesInitialized;
        setChatMessagesInitialized(chatMessagesInitialized);
    };
    // we try to only send those message status if user is scrolled to the bottom.
    const sendMessageStatusIfAtBottom = React.useCallback(() => __awaiter$i(void 0, void 0, void 0, function* () {
        if (!isAtBottomOfScrollRef.current ||
            !document.hasFocus() ||
            !messagesRef.current ||
            messagesRef.current.length === 0 ||
            !showMessageStatus) {
            return;
        }
        const messagesWithId = messagesRef.current.filter((message) => {
            return message.messageType === 'chat' && !message.mine && !!message.messageId;
        });
        if (messagesWithId.length === 0) {
            return;
        }
        const lastMessage = messagesWithId[messagesWithId.length - 1];
        try {
            if (onMessageSeen &&
                lastMessage &&
                lastMessage.messageId &&
                lastMessage.messageId !== messageIdSeenByMeRef.current) {
                yield onMessageSeen(lastMessage.messageId);
                messageIdSeenByMeRef.current = lastMessage.messageId;
            }
        }
        catch (e) {
            console.log('onMessageSeen Error', lastMessage, e);
        }
    }), [showMessageStatus, onMessageSeen]);
    const scrollToBottom = React.useCallback(() => {
        if (chatScrollDivRef.current) {
            chatScrollDivRef.current.scrollTop = chatScrollDivRef.current.scrollHeight;
        }
        setExistsNewChatMessage(false);
        setIsAtBottomOfScrollRef(true);
        sendMessageStatusIfAtBottom();
    }, [sendMessageStatusIfAtBottom]);
    const handleScrollToTheBottom = React.useCallback(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        const atBottom = Math.ceil(chatScrollDivRef.current.scrollTop) >=
            chatScrollDivRef.current.scrollHeight - chatScrollDivRef.current.clientHeight;
        if (atBottom) {
            sendMessageStatusIfAtBottom();
            if (!isAtBottomOfScrollRef.current) {
                scrollToBottom();
            }
        }
        setIsAtBottomOfScrollRef(atBottom);
    }, [scrollToBottom, sendMessageStatusIfAtBottom]);
    // Infinite scrolling + threadInitialize function
    const fetchNewMessageWhenAtTop = React.useCallback(() => __awaiter$i(void 0, void 0, void 0, function* () {
        if (chatScrollDivRef.current && !isLoadingChatMessagesRef.current) {
            if (onLoadPreviousChatMessages) {
                isLoadingChatMessagesRef.current = true;
                // Fetch message until scrollTop reach the threshold for fetching new message
                while (!isAllChatMessagesLoadedRef.current && chatScrollDivRef.current.scrollTop <= 500) {
                    isAllChatMessagesLoadedRef.current = yield onLoadPreviousChatMessages(numberOfChatMessagesToReload);
                    // Release CPU resources for 200 milliseconds between each loop.
                    yield delay(200);
                }
                isLoadingChatMessagesRef.current = false;
            }
        }
    }), [numberOfChatMessagesToReload, onLoadPreviousChatMessages]);
    const handleInfiniteScroll = React.useCallback(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        fetchNewMessageWhenAtTop();
    }, [fetchNewMessageWhenAtTop]);
    // The below 2 of useEffects are design for fixing infinite scrolling problem
    // Scrolling element will behave differently when scrollTop = 0(it sticks at the top)
    // we need to get previousTop before it prepend contents
    // Execute order [newMessage useEffect] => get previousTop => dom update => [messages useEffect]
    React.useEffect(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        previousTopRef.current = chatScrollDivRef.current.scrollTop;
        previousHeightRef.current = chatScrollDivRef.current.scrollHeight;
    }, [newMessages]);
    React.useEffect(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        if (previousTopRef.current === 0) {
            const currentHeight = chatScrollDivRef.current.scrollHeight;
            chatScrollDivRef.current.scrollTop =
                chatScrollDivRef.current.scrollTop + currentHeight - previousHeightRef.current;
        }
    }, [messages]);
    // Fetch more messages to make the scroll bar appear, infinity scroll is then handled in the handleScroll function.
    React.useEffect(() => {
        fetchNewMessageWhenAtTop();
    }, [fetchNewMessageWhenAtTop]);
    /**
     * One time run useEffects. Sets up listeners when component is mounted and tears down listeners when component
     * unmounts unless these function changed
     */
    React.useEffect(() => {
        window && window.addEventListener('click', sendMessageStatusIfAtBottom);
        window && window.addEventListener('focus', sendMessageStatusIfAtBottom);
        return () => {
            window && window.removeEventListener('click', sendMessageStatusIfAtBottom);
            window && window.removeEventListener('focus', sendMessageStatusIfAtBottom);
        };
    }, [sendMessageStatusIfAtBottom]);
    React.useEffect(() => {
        const chatScrollDiv = chatScrollDivRef.current;
        chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.addEventListener('scroll', handleScrollToTheBottom);
        chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.addEventListener('scroll', handleInfiniteScroll);
        return () => {
            chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.removeEventListener('scroll', handleScrollToTheBottom);
            chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.removeEventListener('scroll', handleInfiniteScroll);
        };
    }, [handleInfiniteScroll, handleScrollToTheBottom]);
    /**
     * ClientHeight controls the number of messages to render. However ClientHeight will not be initialized after the
     * first render (not sure but I guess Fluent is updating it in hook which is after render maybe?) so we need to
     * trigger a re-render until ClientHeight is initialized. This force re-render should only happen once.
     */
    const clientHeight = (_a = chatThreadRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight;
    React.useEffect(() => {
        if (clientHeight === undefined) {
            setForceUpdate(forceUpdate + 1);
            return;
        }
        // Only scroll to bottom if isAtBottomOfScrollRef is true
        isAtBottomOfScrollRef.current && scrollToBottom();
    }, [clientHeight, forceUpdate, scrollToBottom, chatMessagesInitialized]);
    /**
     * This needs to run to update latestPreviousChatMessage & latestCurrentChatMessage.
     * These two states are used to manipulate scrollbar
     */
    React.useEffect(() => {
        setLatestPreviousChatMessage(getLatestChatMessage(messagesRef.current));
        setLatestCurrentChatMessage(getLatestChatMessage(newMessages));
        setMessagesRef(newMessages);
        !chatMessagesInitializedRef.current && setChatMessagesInitializedRef(true);
        setLastDeliveredChatMessage(getLastChatMessageIdWithStatus(newMessages, 'delivered'));
        setLastSeenChatMessage(getLastChatMessageIdWithStatus(newMessages, 'seen'));
        setLastSendingChatMessage(getLastChatMessageIdWithStatus(newMessages, 'sending'));
    }, [newMessages]);
    /**
     * This needs to run after messages are rendererd so we can manipulate the scroll bar.
     */
    React.useEffect(() => {
        // If user just sent the latest message then we assume we can move user to bottom of scroll.
        if (isThereNewMessageNotFromCurrentUser(userId, latestPreviousChatMessage, latestCurrentChatMessage) &&
            !isAtBottomOfScrollRef.current) {
            setExistsNewChatMessage(true);
        }
        else if (didUserSendTheLatestMessage(userId, latestPreviousChatMessage, latestCurrentChatMessage) ||
            isAtBottomOfScrollRef.current) {
            scrollToBottom();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [messages]);
    // To rerender the defaultChatMessageRenderer if app running across days(every new day chat time stamp need to be regenerated)
    const defaultChatMessageRenderer = React.useCallback((messageProps) => {
        if (messageProps.message.messageType === 'chat') {
            return (React__default['default'].createElement(ChatMessageComponent, Object.assign({}, messageProps, { message: messageProps.message, inlineAcceptRejectEditButtons: !isNarrow })));
        }
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [new Date().toDateString(), isNarrow]);
    const localeStrings = useLocale$1().strings.messageThread;
    const strings = React.useMemo(() => (Object.assign(Object.assign({}, localeStrings), props.strings)), [localeStrings, props.strings]);
    const defaultStatusRenderer = React.useCallback((status) => React__default['default'].createElement(MessageStatusIndicator, { status: status }), []);
    const messagesToDisplay = React.useMemo(() => memoizeAllMessages((memoizedMessageFn) => {
        return messages.map((message, index) => {
            let key = message.messageId;
            let statusToRender = undefined;
            if (message.messageType === 'chat') {
                if (!message.messageId || message.messageId === '') {
                    key = message.clientMessageId;
                }
                if (showMessageStatus && message.mine) {
                    switch (message.messageId) {
                        case lastSeenChatMessage: {
                            statusToRender = 'seen';
                            break;
                        }
                        case lastSendingChatMessage: {
                            statusToRender = 'sending';
                            break;
                        }
                        case lastDeliveredChatMessage: {
                            statusToRender = 'delivered';
                            break;
                        }
                    }
                }
                if (message.mine && message.status === 'failed') {
                    statusToRender = 'failed';
                }
            }
            return memoizedMessageFn(key !== null && key !== void 0 ? key : 'id_' + index, message, showMessageDate, showMessageStatus, onRenderAvatar, isNarrow, styles, onRenderMessageStatus, defaultStatusRenderer, defaultChatMessageRenderer, strings, 
            // Temporary solution to make sure we re-render if attach attribute is changed.
            // The proper fix should be in selector.
            message.messageType === 'chat' ? message.attached : undefined, statusToRender, onRenderMessage, onUpdateMessage, onDeleteMessage);
        });
    }), [
        messages,
        showMessageDate,
        showMessageStatus,
        onRenderAvatar,
        isNarrow,
        styles,
        onRenderMessageStatus,
        defaultStatusRenderer,
        defaultChatMessageRenderer,
        lastSeenChatMessage,
        lastSendingChatMessage,
        lastDeliveredChatMessage,
        onRenderMessage,
        onUpdateMessage,
        onDeleteMessage,
        strings
    ]);
    const chatBody = React.useMemo(() => {
        var _a;
        return (React__default['default'].createElement(reactAriaLive.LiveAnnouncer, null,
            React__default['default'].createElement(reactNorthstar.Chat, { styles: (_a = styles === null || styles === void 0 ? void 0 : styles.chatContainer) !== null && _a !== void 0 ? _a : chatStyle, items: messagesToDisplay })));
    }, [styles === null || styles === void 0 ? void 0 : styles.chatContainer, messagesToDisplay]);
    return (React__default['default'].createElement(reactNorthstar.Ref, { innerRef: chatThreadRef },
        React__default['default'].createElement(react.Stack, { className: react.mergeStyles(messageThreadContainerStyle, styles === null || styles === void 0 ? void 0 : styles.root), grow: true },
            React__default['default'].createElement(reactNorthstar.Ref, { innerRef: chatScrollDivRef }, chatBody),
            existsNewChatMessage && !disableJumpToNewMessageButton && (React__default['default'].createElement("div", { className: react.mergeStyles(newMessageButtonContainerStyle, styles === null || styles === void 0 ? void 0 : styles.newMessageButtonContainer) }, onRenderJumpToNewMessageButton ? (onRenderJumpToNewMessageButton({ text: strings.newMessagesIndicator, onClick: scrollToBottom })) : (React__default['default'].createElement(DefaultJumpToNewMessageButton, { text: strings.newMessagesIndicator, onClick: scrollToBottom })))))));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mediaContainer = (theme) => react.mergeStyles({
    position: 'relative',
    height: '100%',
    width: '100%',
    background: 'transparent',
    display: 'flex',
    '& video': {
        borderRadius: theme.effects.roundedCorner4
    }
});
/**
 * @private
 */
const invertedVideoStyle = (theme) => react.mergeStyles(mediaContainer(theme), {
    transform: 'rotateY(180deg)'
});

// Copyright (c) Microsoft Corporation.
/**
 * Utility component to convert an HTMLElement with a video stream into a JSX element.
 *
 * Use to convert an HTMLElement returned by headless calling API into a component that can be rendered as a {@link VideoTile}.
 *
 * @public
 */
const StreamMedia = (props) => {
    const containerEl = React.useRef(null);
    const theme = useTheme();
    const { isMirrored, videoStreamElement, styles } = props;
    React.useEffect(() => {
        const container = containerEl.current;
        if (!container) {
            return;
        }
        // If videoStreamElement changes, we clear the container to make sure we don't have duplicate, and replace it with
        // the new videoStreamElement. If videoStreamElement is undefined nothing is appended and container should be empty
        // and we don't render anyting.
        container.innerHTML = '';
        if (videoStreamElement) {
            container.appendChild(videoStreamElement);
        }
        return () => {
            container.innerHTML = '';
        };
    }, [videoStreamElement]);
    return (React__default['default'].createElement("div", { className: react.mergeStyles(isMirrored ? invertedVideoStyle(theme) : mediaContainer(theme), styles === null || styles === void 0 ? void 0 : styles.root), ref: containerEl }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const participantItemContainerStyle = react.mergeStyles({
    paddingTop: '0.25rem',
    paddingBottom: '0.25rem',
    display: 'flex',
    maxWidth: '20rem',
    minWidth: '12rem',
    cursor: 'pointer',
    alignItems: 'center'
});
/**
 * @private
 */
const menuButtonContainerStyle = {
    width: '1.5rem'
};
/**
 * @private
 */
const iconContainerStyle$1 = {
    display: 'flex',
    alignItems: 'center',
    height: '100%',
    paddingTop: '0.2rem'
};
/**
 * @private
 */
const iconStyles$1 = react.mergeStyles({
    display: 'flex',
    lineHeight: 0,
    alignItems: 'center'
});
/**
 * @private
 */
const meContainerStyle = {
    paddingRight: '0.5rem'
};

// Copyright (c) Microsoft Corporation.
/**
 * Component to render a calling or chat participant.
 *
 * Displays the participant's avatar, displayName and status as well as optional icons and context menu.
 *
 * @public
 */
const ParticipantItem = (props) => {
    var _a, _b, _c, _d;
    const { userId, displayName, onRenderAvatar, menuItems, onRenderIcon, presence, styles, me } = props;
    const [itemHovered, setItemHovered] = React.useState(false);
    const [menuHidden, setMenuHidden] = React.useState(true);
    const containerRef = React.useRef(null);
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.participantItem;
    const ids = useIdentifiers();
    const isMeText = (_b = (_a = props.strings) === null || _a === void 0 ? void 0 : _a.isMeText) !== null && _b !== void 0 ? _b : localeStrings.isMeText;
    const menuTitle = (_d = (_c = props.strings) === null || _c === void 0 ? void 0 : _c.menuTitle) !== null && _d !== void 0 ? _d : localeStrings.menuTitle;
    const avatarOptions = {
        text: displayName,
        size: react.PersonaSize.size32,
        presence: presence,
        initialsTextColor: 'white'
    };
    const avatar = onRenderAvatar ? (onRenderAvatar(userId !== null && userId !== void 0 ? userId : '', avatarOptions)) : (React__default['default'].createElement(react.Persona, Object.assign({ className: react.mergeStyles({
            // Prevents persona text from being vertically truncated if a global line height is less than 1.15.
            lineHeight: '1.15rem'
        }, styles === null || styles === void 0 ? void 0 : styles.avatar) }, avatarOptions)));
    const meTextStyle = React.useMemo(() => react.mergeStyles(meContainerStyle, { color: theme.palette.neutralTertiary }, styles === null || styles === void 0 ? void 0 : styles.me), [theme.palette.neutralTertiary, styles === null || styles === void 0 ? void 0 : styles.me]);
    const contextualMenuStyle = React.useMemo(() => react.mergeStyles({ background: theme.palette.neutralLighterAlt }, styles === null || styles === void 0 ? void 0 : styles.menu), [theme.palette.neutralLighterAlt, styles === null || styles === void 0 ? void 0 : styles.menu]);
    const infoContainerStyle = React.useMemo(() => react.mergeStyles(iconContainerStyle$1, { color: theme.palette.neutralTertiary }, styles === null || styles === void 0 ? void 0 : styles.iconContainer), [theme.palette.neutralTertiary, styles === null || styles === void 0 ? void 0 : styles.iconContainer]);
    const menuButton = React.useMemo(() => (React__default['default'].createElement(react.Stack, { horizontal: true, horizontalAlign: "end", className: react.mergeStyles(menuButtonContainerStyle), title: menuTitle, "data-ui-id": ids.participantItemMenuButton },
        React__default['default'].createElement(react.Icon, { iconName: itemHovered ? 'ParticipantItemOptionsHovered' : 'ParticipantItemOptions', className: iconStyles$1 }))), [itemHovered, menuTitle, ids.participantItemMenuButton]);
    const onDismissMenu = () => {
        setItemHovered(false);
        setMenuHidden(true);
    };
    return (React__default['default'].createElement("div", { ref: containerRef, role: 'menuitem', "data-is-focusable": true, className: react.mergeStyles(participantItemContainerStyle, styles === null || styles === void 0 ? void 0 : styles.root), onMouseEnter: () => setItemHovered(true), onMouseLeave: () => setItemHovered(false), onClick: () => {
            setItemHovered(true);
            setMenuHidden(false);
        } },
        React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles({ width: `calc(100% - ${menuButtonContainerStyle.width})`, alignItems: 'center' }) },
            avatar,
            me && React__default['default'].createElement(react.Stack, { className: meTextStyle }, isMeText),
            React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(infoContainerStyle) }, onRenderIcon && onRenderIcon(props))),
        menuItems && menuItems.length > 0 && (React__default['default'].createElement(React__default['default'].Fragment, null,
            menuButton,
            React__default['default'].createElement(react.ContextualMenu, { items: menuItems, hidden: menuHidden, target: containerRef, onItemClick: onDismissMenu, onDismiss: onDismissMenu, directionalHint: react.DirectionalHint.bottomRightEdge, className: contextualMenuStyle, calloutProps: {
                    // Disable dismiss on resize to work around a couple Fluent UI bugs
                    // - The Callout is dismissed whenever *any child of window (inclusive)* is resized. In practice, this
                    //   happens when we change the VideoGallery layout, or even when the video stream element is internally resized
                    //   by the headless SDK.
                    // - There is a `preventDismissOnEvent` prop that we could theoretically use to only dismiss when the target of
                    //   of the 'resize' event is the window itself. But experimentation shows that setting that prop doesn't
                    //   deterministically avoid dismissal.
                    //
                    // A side effect of this workaround is that the context menu stays open when window is resized, and may
                    // get detached from original target visually. That bug is preferable to the bug when this value is not set -
                    // The Callout (frequently) gets dismissed automatically.
                    preventDismissOnResize: true
                } })))));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const participantListStyle = react.mergeStyles({
    height: '100%',
    padding: '0.125rem'
});
/**
 * @private
 */
const participantListItemStyle = {
    root: {
        paddingLeft: '1rem',
        paddingRight: '1rem'
    }
};
/**
 * @private
 */
const iconStyles = react.mergeStyles({
    display: 'flex',
    lineHeight: 0,
    alignItems: 'center'
});

// Copyright (c) Microsoft Corporation.
const onRenderParticipantDefault = (participant, strings, myUserId, onRemoveParticipant, onRenderAvatar, createParticipantMenuItems, styles) => {
    const callingParticipant = participant;
    let presence = undefined;
    if (callingParticipant) {
        if (callingParticipant.state === 'Connected') {
            presence = react.PersonaPresence.online;
        }
        else if (callingParticipant.state === 'Idle') {
            presence = react.PersonaPresence.away;
        }
    }
    const menuItems = createParticipantMenuItems && createParticipantMenuItems(participant);
    const onRenderIcon = (callingParticipant === null || callingParticipant === void 0 ? void 0 : callingParticipant.isScreenSharing) || (callingParticipant === null || callingParticipant === void 0 ? void 0 : callingParticipant.isMuted)
        ? () => (React__default['default'].createElement(react.Stack, { horizontal: true, tokens: { childrenGap: '0.5rem' } },
            callingParticipant.isScreenSharing && (React__default['default'].createElement(react.Icon, { iconName: "ParticipantItemScreenShareStart", className: iconStyles, ariaLabel: strings.sharingIconLabel })),
            callingParticipant.isMuted && (React__default['default'].createElement(react.Icon, { iconName: "ParticipantItemMicOff", className: iconStyles, ariaLabel: strings.mutedIconLabel }))))
        : () => null;
    if (participant.displayName) {
        return (React__default['default'].createElement(ParticipantItem, { styles: styles, key: participant.userId, userId: participant.userId, displayName: participant.displayName, me: myUserId ? participant.userId === myUserId : false, menuItems: menuItems, presence: presence, onRenderIcon: onRenderIcon, onRenderAvatar: onRenderAvatar }));
    }
    return null;
};
const getParticipantsForDefaultRender = (participants, excludeMe, myUserId) => {
    if (!excludeMe || !myUserId) {
        return [...participants];
    }
    const userIndex = participants.map((p) => p.userId).indexOf(myUserId);
    if (userIndex === -1) {
        return [...participants];
    }
    const remoteParticipants = [...participants];
    remoteParticipants.splice(userIndex, 1);
    return remoteParticipants;
};
/**
 * Component to render all calling or chat participants.
 *
 * By default, each participant is rendered with {@link ParticipantItem}. See {@link ParticipantListProps.onRenderParticipant} to override.
 *
 * @public
 */
const ParticipantList = (props) => {
    var _a, _b;
    const { excludeMe = false, myUserId, participants, onRemoveParticipant, onRenderAvatar, onRenderParticipant, onFetchParticipantMenuItems } = props;
    const ids = useIdentifiers();
    const strings = useLocale$1().strings.participantItem;
    const displayedParticipants = React.useMemo(() => {
        return onRenderParticipant ? participants : getParticipantsForDefaultRender(participants, excludeMe, myUserId);
    }, [participants, excludeMe, myUserId, onRenderParticipant]);
    const createParticipantMenuItems = (participant) => {
        var _a, _b;
        let menuItems = [];
        if (participant.userId !== myUserId && onRemoveParticipant) {
            menuItems.push({
                key: 'remove',
                text: strings.removeButtonLabel,
                onClick: () => onRemoveParticipant(participant.userId),
                itemProps: {
                    styles: (_b = (_a = props.styles) === null || _a === void 0 ? void 0 : _a.participantItemStyles) === null || _b === void 0 ? void 0 : _b.participantSubMenuItemsStyles
                },
                disabled: !participant.isRemovable,
                'data-ui-id': ids.participantListRemoveParticipantButton
            });
        }
        if (onFetchParticipantMenuItems) {
            menuItems = onFetchParticipantMenuItems(participant.userId, myUserId, menuItems);
        }
        return menuItems;
    };
    const participantItemStyles = react.merge(participantListItemStyle, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.participantItemStyles);
    return (React__default['default'].createElement(react.Stack, { "data-ui-id": ids.participantList, className: react.mergeStyles(participantListStyle, (_b = props.styles) === null || _b === void 0 ? void 0 : _b.root) }, displayedParticipants.map((participant) => onRenderParticipant
        ? onRenderParticipant(participant)
        : onRenderParticipantDefault(participant, strings, myUserId, onRemoveParticipant, onRenderAvatar, createParticipantMenuItems, participantItemStyles))));
};

/**
 * Calculates the participants that should be rendered based on the list of dominant
 * speakers and currently rendered participants in a call.
 * @param args - SmartDominantSpeakerParticipantsArgs
 * @returns VideoGalleryRemoteParticipant[] {@link @azure/communication-react#VideoGalleryRemoteParticipant}
 */
const smartDominantSpeakerParticipants = (args) => {
    const { participants, dominantSpeakers = [], lastVisibleParticipants = [], maxDominantSpeakers } = args;
    // Don't apply any logic if total number of video streams is less than max dominant speakers.
    if (participants.length <= maxDominantSpeakers) {
        return participants;
    }
    const participantsMap = participantsById(participants);
    // Only use the Max allowed dominant speakers that exist in participants
    const dominantSpeakerIds = Array.from(new Set(dominantSpeakers).values())
        .filter((id) => !!participantsMap[id])
        .slice(0, maxDominantSpeakers);
    const lastVisibleParticipantIds = lastVisibleParticipants.map((p) => p.userId);
    const newVisibleParticipantIds = lastVisibleParticipants.map((p) => p.userId).slice(0, maxDominantSpeakers);
    const newDominantSpeakerIds = dominantSpeakerIds.filter((id) => !newVisibleParticipantIds.includes(id));
    // Remove participants that are no longer dominant and replace them with new dominant speakers.
    for (let index = 0; index < maxDominantSpeakers; index++) {
        const newVisibleParticipantId = newVisibleParticipantIds[index];
        if (newVisibleParticipantId === undefined || !dominantSpeakerIds.includes(newVisibleParticipantId)) {
            const replacement = newDominantSpeakerIds.shift();
            if (!replacement) {
                break;
            }
            newVisibleParticipantIds[index] = replacement;
        }
    }
    const removedVisibleParticipantIds = lastVisibleParticipantIds.filter((p) => !newVisibleParticipantIds.includes(p));
    removedVisibleParticipantIds.forEach((p) => newVisibleParticipantIds.push(p));
    const newVisibleParticipantIdSet = new Set(newVisibleParticipantIds);
    const leftoverParticipants = participants.filter((p) => !newVisibleParticipantIdSet.has(p.userId));
    leftoverParticipants.forEach((p) => {
        newVisibleParticipantIds.push(p.userId);
    });
    // newVisibleParticipantIds can contain identifiers for participants that are no longer in the call. So we ignore those IDs.
    const newVisibleParticipants = newVisibleParticipantIds
        .map((participantId) => participantsMap[participantId])
        .filter((p) => !!p);
    return newVisibleParticipants;
};
const participantsById = (participants) => {
    const response = {};
    participants.forEach((p) => (response[p.userId] = p));
    return response;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const rootStyles = {
    position: 'relative',
    height: '100%',
    width: '100%'
};
/**
 * @private
 */
const videoContainerStyles = {
    position: 'absolute',
    top: '0',
    left: '0',
    width: '100%',
    height: '100%',
    minWidth: '100%',
    minHeight: '100%',
    objectPosition: 'center',
    objectFit: 'cover',
    zIndex: 0
};
/**
 * @private
 */
const overlayContainerStyles = {
    width: '100%',
    height: '100%',
    zIndex: 5
};
/**
 * @private
 */
const tileInfoContainerStyle = react.mergeStyles({
    position: 'absolute',
    bottom: '0.5rem',
    left: '0.5rem',
    width: 'calc(100% - 1rem)'
});
/**
 * @private
 */
const disabledVideoHint = react.mergeStyles({
    backgroundColor: 'inherit',
    boxShadow: 'none',
    textAlign: 'left',
    overflow: 'hidden',
    whiteSpace: 'nowrap',
    alignItems: 'center',
    padding: '0.15rem',
    maxWidth: '100%'
});
/**
 * @private
 */
const videoHint = react.mergeStyles(disabledVideoHint, {
    // This will appear on top of the video stream, so no dependency on theme and explicitly use a translucent white
    backgroundColor: 'rgba(255,255,255,0.8)'
});
/**
 * @private
 */
const displayNameStyle = {
    padding: '0.1rem',
    fontSize: '0.75rem',
    fontWeight: 600,
    // Text component will take body color by default (white in Dark Mode), so forcing it to be parent container color
    color: 'inherit',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    maxWidth: '100%'
};
/**
 * @private
 */
const iconContainerStyle = {
    height: '100%',
    alignItems: 'center',
    '& svg': {
        display: 'block'
    }
};
/**
 * @private
 */
const isSpeakingBorderDiv = {
    zIndex: 1,
    width: '100%',
    height: '100%',
    position: 'absolute',
    top: '0',
    left: '0'
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const getVideoTileOverrideColor = (isVideoRendered, theme, color) => {
    // when video is being rendered, the info has a grey-ish background, so no use of theme
    return { color: isVideoRendered ? react.DefaultPalette[color] : theme.palette[color] };
};

// Copyright (c) Microsoft Corporation.
// Coin max size is set to PersonaSize.size100
const PERSONA_MAX_SIZE = 100;
// Coin min size is set PersonaSize.size32
const PERSONA_MIN_SIZE = 32;
const DefaultPlaceholder = (props) => {
    const { text, noVideoAvailableAriaLabel, coinSize, styles, hidePersonaDetails } = props;
    return (React__default['default'].createElement(react.Stack, { className: react.mergeStyles({ position: 'absolute', height: '100%', width: '100%' }) },
        React__default['default'].createElement(react.Persona, { styles: styles, coinSize: coinSize, hidePersonaDetails: hidePersonaDetails, text: text !== null && text !== void 0 ? text : '', initialsTextColor: "white", "aria-label": noVideoAvailableAriaLabel !== null && noVideoAvailableAriaLabel !== void 0 ? noVideoAvailableAriaLabel : '' })));
};
const defaultPersonaStyles = { root: { margin: 'auto', maxHeight: '100%' } };
/**
 * A component to render the video stream for a single call participant.
 *
 * Use with {@link GridLayout} in a {@link VideoGallery}.
 *
 * @public
 */
const VideoTile = (props) => {
    const { children, displayName, initialsName, isMirrored, isMuted, onRenderPlaceholder, renderElement, showLabel = true, showMuteIndicator = true, styles, userId, noVideoAvailableAriaLabel, isSpeaking } = props;
    const [personaSize, setPersonaSize] = React.useState(100);
    const videoTileRef = React.useRef(null);
    const theme = useTheme();
    const isVideoRendered = !!renderElement;
    const observer = React.useRef(new ResizeObserver((entries) => {
        const { width, height } = entries[0].contentRect;
        const personaSize = Math.min(width, height) / 3;
        setPersonaSize(Math.max(Math.min(personaSize, PERSONA_MAX_SIZE), PERSONA_MIN_SIZE));
    }));
    React.useLayoutEffect(() => {
        if (videoTileRef.current) {
            observer.current.observe(videoTileRef.current);
        }
        const currentObserver = observer.current;
        return () => currentObserver.disconnect();
    }, [observer, videoTileRef]);
    const placeholderOptions = {
        userId,
        text: initialsName || displayName,
        noVideoAvailableAriaLabel,
        coinSize: personaSize,
        styles: defaultPersonaStyles,
        hidePersonaDetails: true
    };
    const videoHintWithBorderRadius = react.mergeStyles(videoHint, { borderRadius: theme.effects.roundedCorner4 });
    const tileInfoStyle = React.useMemo(() => react.mergeStyles(isVideoRendered ? videoHintWithBorderRadius : disabledVideoHint, getVideoTileOverrideColor(isVideoRendered, theme, 'neutralPrimary'), styles === null || styles === void 0 ? void 0 : styles.displayNameContainer), [isVideoRendered, videoHintWithBorderRadius, theme, styles === null || styles === void 0 ? void 0 : styles.displayNameContainer]);
    const ids = useIdentifiers();
    return (React__default['default'].createElement(reactNorthstar.Ref, { innerRef: videoTileRef },
        React__default['default'].createElement(react.Stack, { "data-ui-id": ids.videoTile, className: react.mergeStyles(rootStyles, {
                background: theme.palette.neutralLighter,
                borderRadius: theme.effects.roundedCorner4
            }, styles === null || styles === void 0 ? void 0 : styles.root) },
            React__default['default'].createElement("div", { className: react.mergeStyles(isSpeakingBorderDiv, {
                    borderRadius: theme.effects.roundedCorner4,
                    border: `0.25rem solid ${isSpeaking ? theme.palette.themePrimary : 'transparent'}`
                }) }),
            isVideoRendered ? (React__default['default'].createElement(react.Stack, { className: react.mergeStyles(videoContainerStyles, isMirrored && { transform: 'scaleX(-1)' }, styles === null || styles === void 0 ? void 0 : styles.videoContainer) }, renderElement)) : (React__default['default'].createElement(react.Stack, { className: react.mergeStyles(videoContainerStyles) }, onRenderPlaceholder ? (onRenderPlaceholder(userId !== null && userId !== void 0 ? userId : '', placeholderOptions, DefaultPlaceholder)) : (React__default['default'].createElement(DefaultPlaceholder, Object.assign({}, placeholderOptions))))),
            showLabel && (displayName || (showMuteIndicator && isMuted)) && (React__default['default'].createElement(react.Stack, { horizontal: true, className: tileInfoContainerStyle },
                React__default['default'].createElement(react.Stack, { horizontal: true, className: tileInfoStyle },
                    displayName && (React__default['default'].createElement(react.Text, { className: react.mergeStyles(displayNameStyle), title: displayName }, displayName)),
                    showMuteIndicator && isMuted && (React__default['default'].createElement(react.Stack, { className: react.mergeStyles(iconContainerStyle) },
                        React__default['default'].createElement(react.Icon, { iconName: "VideoTileMicOff" })))))),
            children && (React__default['default'].createElement(react.Stack, { className: react.mergeStyles(overlayContainerStyles, styles === null || styles === void 0 ? void 0 : styles.overlayContainer) }, children)))));
};

// Copyright (c) Microsoft Corporation.
/**
 * A memoized version of VideoTile for rendering remote participants. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering a VideoTile when its position in the
 * array changes causing a rerender in the parent component. https://reactjs.org/docs/react-api.html#reactmemo
 */
const RemoteVideoTile = React__default['default'].memo((props) => {
    const { isAvailable, isMuted, isSpeaking, isScreenSharingOn, onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions, renderElement, userId, displayName, onRenderAvatar, showMuteIndicator } = props;
    React.useEffect(() => {
        if (isAvailable && !renderElement) {
            onCreateRemoteStreamView && onCreateRemoteStreamView(userId, remoteVideoViewOptions);
        }
        // Always clean up element to make tile up to date and be able to dispose correctly
        // TODO: Add an extra param to onDisposeRemoteStreamView(userId, flavor(optional)) after GA
        // and isolate dispose behavior between screen share and video
        return () => {
            if (renderElement && !isScreenSharingOn) {
                onDisposeRemoteStreamView && onDisposeRemoteStreamView(userId);
            }
        };
    }, [
        isAvailable,
        onCreateRemoteStreamView,
        onDisposeRemoteStreamView,
        remoteVideoViewOptions,
        renderElement,
        userId,
        isScreenSharingOn
    ]);
    // The execution order for above useEffect is onCreateRemoteStreamView =>(async time gap) RenderElement generated => element disposed => onDisposeRemoteStreamView
    // Element disposed could happen during async time gap, which still cause leaks for unused renderElement.
    // Need to do an entire cleanup when remoteTile gets disposed and make sure element gets correctly disposed
    React.useEffect(() => {
        return () => {
            // TODO: Remove if condition when we isolate dispose behavior for screen share
            if (!isScreenSharingOn) {
                onDisposeRemoteStreamView && onDisposeRemoteStreamView(userId);
            }
        };
    }, [onDisposeRemoteStreamView, userId, isScreenSharingOn]);
    const renderVideoStreamElement = React.useMemo(() => {
        // Checking if renderElement is well defined or not as calling SDK has a number of video streams limitation which
        // implies that, after their threshold, all streams have no child (blank video)
        if (!renderElement || !renderElement.childElementCount) {
            // Returning `undefined` results in the placeholder with avatar being shown
            return undefined;
        }
        return React__default['default'].createElement(StreamMedia, { videoStreamElement: renderElement });
    }, [renderElement]);
    return (React__default['default'].createElement(VideoTile, { key: userId, userId: userId, renderElement: renderVideoStreamElement, displayName: displayName, onRenderPlaceholder: onRenderAvatar, isMuted: isMuted, isSpeaking: isSpeaking, showMuteIndicator: showMuteIndicator }));
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Horizontal Gallery button width in rem
 */
const HORIZONTAL_GALLERY_BUTTON_WIDTH = 1.75;
/**
 * @private
 */
const leftRightButtonStyles = (theme) => {
    return {
        background: 'none',
        padding: 0,
        height: '100%',
        minWidth: `${HORIZONTAL_GALLERY_BUTTON_WIDTH}rem`,
        maxWidth: `${HORIZONTAL_GALLERY_BUTTON_WIDTH}rem`,
        border: `1px solid ${theme.palette.neutralLight}`,
        borderRadius: theme.effects.roundedCorner4
    };
};
/**
 * Horizontal Gallery gap size in rem between tiles and buttons
 */
const HORIZONTAL_GALLERY_GAP = 0.5;
/**
 * @private
 */
const rootStyle = {
    height: '100%',
    width: '100%',
    gap: `${HORIZONTAL_GALLERY_GAP}rem`
};
/**
 * @private
 */
const childrenContainerStyle = {
    height: '100%',
    gap: `${HORIZONTAL_GALLERY_GAP}rem`
};

// Copyright (c) Microsoft Corporation.
/**
 * {@link HorizontalGallery} default children per page
 */
const DEFAULT_CHILDREN_PER_PAGE = 5;
/**
 * Renders a horizontal gallery that parents children horizontally. Handles pagination based on the childrenPerPage prop.
 * @param props - HorizontalGalleryProps {@link @azure/communication-react#HorizontalGalleryProps}
 * @returns
 */
const HorizontalGallery = (props) => {
    var _a, _b;
    const { children, childrenPerPage = DEFAULT_CHILDREN_PER_PAGE, styles } = props;
    const [page, setPage] = React.useState(0);
    const numberOfChildren = React__default['default'].Children.count(children);
    const lastPage = Math.ceil(numberOfChildren / childrenPerPage) - 1;
    const paginatedChildren = React.useMemo(() => {
        return bucketize(React__default['default'].Children.toArray(children), childrenPerPage);
    }, [children, childrenPerPage]);
    // If children per page is 0 or less return empty element
    if (childrenPerPage <= 0) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    const firstIndexOfCurrentPage = page * childrenPerPage;
    const clippedPage = firstIndexOfCurrentPage < numberOfChildren - 1 ? page : lastPage;
    const childrenOnCurrentPage = paginatedChildren[clippedPage];
    const showButtons = numberOfChildren > childrenPerPage;
    const disablePreviousButton = page === 0;
    const disableNextButton = page === lastPage;
    return (React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(rootStyle, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root) },
        showButtons && (React__default['default'].createElement(HorizontalGalleryNavigationButton, { key: "previous-nav-button", icon: React__default['default'].createElement(react.Icon, { iconName: "HorizontalGalleryLeftButton" }), styles: styles === null || styles === void 0 ? void 0 : styles.previousButton, onClick: () => setPage(Math.max(0, Math.min(lastPage, page - 1))), disabled: disablePreviousButton })),
        React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(childrenContainerStyle, { '> *': (_b = props.styles) === null || _b === void 0 ? void 0 : _b.children }) }, childrenOnCurrentPage),
        showButtons && (React__default['default'].createElement(HorizontalGalleryNavigationButton, { key: "next-nav-button", icon: React__default['default'].createElement(react.Icon, { iconName: "HorizontalGalleryRightButton" }), styles: styles === null || styles === void 0 ? void 0 : styles.nextButton, onClick: () => setPage(Math.min(lastPage, page + 1)), disabled: disableNextButton }))));
};
const HorizontalGalleryNavigationButton = (props) => {
    const theme = useTheme();
    return (React__default['default'].createElement(react.DefaultButton, { className: react.mergeStyles(leftRightButtonStyles(theme), props.styles), onClick: props.onClick, disabled: props.disabled }, props.icon));
};
function bucketize(arr, bucketSize) {
    const bucketArray = [];
    if (bucketSize <= 0) {
        return bucketArray;
    }
    for (let i = 0; i < arr.length; i += bucketSize) {
        bucketArray.push(arr.slice(i, i + bucketSize));
    }
    return bucketArray;
}

// Copyright (c) Microsoft Corporation.
/**
 * Wrapped HorizontalGallery that adjusts the number of items per page based on the
 * available width obtained from a ResizeObserver, width per child, gap width, and button width
 */
const ResponsiveHorizontalGallery = (props) => {
    const { childWidthRem, gapWidthRem, buttonWidthRem = 0 } = props;
    const containerRef = React.useRef(null);
    const containerWidth = useContainerWidth(containerRef);
    const leftPadding = containerRef.current ? parseFloat(getComputedStyle(containerRef.current).paddingLeft) : 0;
    const rightPadding = containerRef.current ? parseFloat(getComputedStyle(containerRef.current).paddingRight) : 0;
    const childrenPerPage = calculateChildrenPerPage({
        numberOfChildren: React__default['default'].Children.count(props.children),
        containerWidth: containerWidth - leftPadding - rightPadding,
        childWidthRem,
        gapWidthRem,
        buttonWidthRem
    });
    return (React__default['default'].createElement("div", { ref: containerRef, className: react.mergeStyles(props.containerStyles) },
        React__default['default'].createElement(HorizontalGallery, { childrenPerPage: childrenPerPage, styles: props.horizontalGalleryStyles }, props.children)));
};
/**
 * Helper function to calculate children per page for HorizontalGallery based on width of container, child, buttons, and
 * gaps in between
 */
const calculateChildrenPerPage = (args) => {
    const { numberOfChildren, containerWidth, buttonWidthRem, childWidthRem, gapWidthRem } = args;
    const childWidth = convertRemToPx(childWidthRem);
    const gapWidth = convertRemToPx(gapWidthRem);
    /** First check how many children can fit in containerWidth.
     *    __________________________________
     *   |                ||                |
     *   |                ||                |
     *   |________________||________________|
     *   <-----------containerWidth--------->
     *  containerWidth = n * childWidth + (n - 1) * gapWidth. Isolate n and take the floor.
     */
    const numberOfChildrenInContainer = Math.floor((containerWidth + gapWidth) / (childWidth + gapWidth));
    // If all children fit then return numberOfChildrenInContainer
    if (numberOfChildren <= numberOfChildrenInContainer) {
        return numberOfChildrenInContainer;
    }
    const buttonWidth = convertRemToPx(buttonWidthRem);
    /** We know we need to paginate. So we need to subtract the buttonWidth twice and gapWidth twice from
     * containerWidth to compute childrenSpace
     *   <-----------containerWidth--------->
     *    __________________________________
     *   | ||             ||             || |
     *   |<||             ||             ||>|
     *   |_||_____________||_____________||_|
     *       <-------childrenSpace------>
     */
    const childrenSpace = containerWidth - 2 * buttonWidth - 2 * gapWidth;
    // Now that we have childrenSpace width we can figure out how many children can fit in childrenSpace.
    // childrenSpace = n * childWidth + (n - 1) * gapWidth. Isolate n and take the floor.
    return Math.floor((childrenSpace + gapWidth) / (childWidth + gapWidth));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const videoGalleryOuterDivStyle = react.mergeStyles({ position: 'relative', width: '100%', height: '100%' });
/**
 * @private
 */
const videoGalleryContainerStyle = {
    root: { position: 'relative', height: '100%', width: '100%', padding: '0.5rem' }
};
/**
 * @private
 */
const videoGalleryContainerTokens = {
    childrenGap: '0.5rem'
};
/**
 * Small floating modal width and height in rem for small screen
 */
const SMALL_FLOATING_MODAL_SIZE_REM = { width: 4, height: 5.5 };
/**
 * Large floating modal width and height in rem for large screen
 */
const LARGE_FLOATING_MODAL_SIZE_REM = { width: 10, height: 7.5 };
/**
 * @private
 */
const floatingLocalVideoModalStyle = (theme, isNarrow) => {
    return react.concatStyleSets({
        main: localVideoTileContainerStyle(theme, isNarrow)
    }, { main: { boxShadow: theme.effects.elevation8 } });
};
/**
 * @private
 */
const localVideoTileContainerStyle = (theme, isNarrow) => {
    return Object.assign({ minWidth: isNarrow ? `${SMALL_FLOATING_MODAL_SIZE_REM.width}rem` : `${LARGE_FLOATING_MODAL_SIZE_REM.width}rem`, minHeight: isNarrow ? `${SMALL_FLOATING_MODAL_SIZE_REM.height}rem` : `${LARGE_FLOATING_MODAL_SIZE_REM.height}rem`, position: 'absolute', bottom: '0.5rem', borderRadius: theme.effects.roundedCorner4, overflow: 'hidden' }, (theme.rtl ? { left: '0.5rem' } : { right: '0.5rem' }));
};
/**
 * @private
 */
const floatingLocalVideoTileStyle = {
    root: {
        position: 'absolute',
        zIndex: 1,
        height: '100%',
        width: '100%'
    }
};
/**
 * @private
 */
const horizontalGalleryContainerStyle = (shouldFloatLocalVideo, isNarrow) => {
    return {
        maxHeight: isNarrow
            ? `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`
            : `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
        minHeight: isNarrow
            ? `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`
            : `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
        width: shouldFloatLocalVideo
            ? isNarrow
                ? `calc(100% - ${SMALL_FLOATING_MODAL_SIZE_REM.width}rem)`
                : `calc(100% - ${LARGE_FLOATING_MODAL_SIZE_REM.width}rem)`
            : '100%',
        paddingRight: '0.5rem'
    };
};
/**
 * @private
 */
const horizontalGalleryStyle = (isNarrow) => {
    return {
        children: isNarrow ? SMALL_HORIZONTAL_GALLERY_TILE_STYLE : LARGE_HORIZONTAL_GALLERY_TILE_STYLE
    };
};
/**
 * Small horizontal gallery tile size in rem
 * @private
 */
const SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM = { height: 5.5, width: 5.5 };
/**
 * Large horizontal gallery tile size in rem
 * @private
 */
const LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM = { height: 7.5, width: 10 };
/**
 * @private
 */
const SMALL_HORIZONTAL_GALLERY_TILE_STYLE = {
    minHeight: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    minWidth: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`,
    maxHeight: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    maxWidth: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`
};
/**
 * @private
 */
const LARGE_HORIZONTAL_GALLERY_TILE_STYLE = {
    minHeight: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    minWidth: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`,
    maxHeight: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    maxWidth: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const screenSharingContainerStyle = react.mergeStyles({
    width: '100%',
    height: '100%'
});
/**
 * @private
 */
const screenSharingNotificationContainerStyle = (theme) => react.mergeStyles({
    backgroundColor: 'inherit',
    padding: '1rem',
    maxWidth: '95%',
    borderRadius: theme.effects.roundedCorner4,
    color: theme.palette.neutralSecondary
});
/**
 * @private
 */
const screenSharingNotificationIconContainerStyle = react.mergeStyles({
    height: '2rem',
    lineHeight: 0
});
/**
 * @private
 */
const screenSharingNotificationIconStyle = (theme) => react.mergeStyles({
    // svg is (20px x 20px) but path is only (16px x 12px), so need to scale at 2.5 to get 40px
    transform: 'scale(2.5)',
    color: theme.palette.neutralTertiary
});
/**
 * @private
 */
const screenSharingNotificationTextStyle = react.mergeStyles({
    fontSize: '1rem',
    // Text component will take body color by default (white in Dark Mode), so forcing it to be parent container color
    color: 'inherit'
});

// Copyright (c) Microsoft Corporation.
/**
 * A memoized version of local screen share component. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering this when the parent component rerenders.
 * https://reactjs.org/docs/react-api.html#reactmemo
 */
const LocalScreenShare = React__default['default'].memo((props) => {
    const { localParticipant } = props;
    const theme = useTheme();
    const locale = useLocale$1();
    if (!localParticipant || !localParticipant.isScreenSharingOn) {
        return null;
    }
    const localScreenSharingNotification = (React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: screenSharingContainerStyle },
        React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: screenSharingNotificationContainerStyle(theme), tokens: { childrenGap: '1rem' } },
            React__default['default'].createElement(react.Stack, { horizontal: true, verticalAlign: "center", className: screenSharingNotificationIconContainerStyle },
                React__default['default'].createElement(react.Icon, { iconName: "ControlButtonScreenShareStart", className: screenSharingNotificationIconStyle(theme) })),
            React__default['default'].createElement(react.Text, { className: screenSharingNotificationTextStyle, "aria-live": "polite" }, locale.strings.videoGallery.screenIsBeingSharedMessage))));
    return (React__default['default'].createElement(VideoTile, { displayName: localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.displayName, isMuted: localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isMuted, onRenderPlaceholder: () => React__default['default'].createElement(React__default['default'].Fragment, null) }, localScreenSharingNotification));
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const loadingStyle = react.mergeStyles({
    height: '100%',
    width: '100%'
});

// Copyright (c) Microsoft Corporation.
/**
 * A memoized version of VideoTile for rendering the remote screen share stream. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering this when the parent component rerenders.
 * https://reactjs.org/docs/react-api.html#reactmemo
 */
const RemoteScreenShare = React__default['default'].memo((props) => {
    const { userId, displayName, isMuted, renderElement, onCreateRemoteStreamView, onDisposeRemoteStreamView } = props;
    const locale = useLocale$1();
    if (!renderElement) {
        onCreateRemoteStreamView && onCreateRemoteStreamView(userId);
    }
    React.useEffect(() => {
        return () => {
            // TODO: Isolate disposing behaviors for screenShare and videoStream
            onDisposeRemoteStreamView && onDisposeRemoteStreamView(userId);
        };
    }, [onDisposeRemoteStreamView, userId]);
    const loadingMessage = displayName
        ? _formatString(locale.strings.videoGallery.screenShareLoadingMessage, {
            participant: displayName
        })
        : '';
    return (React__default['default'].createElement(VideoTile, { displayName: displayName, isMuted: isMuted, renderElement: renderElement ? React__default['default'].createElement(StreamMedia, { videoStreamElement: renderElement }) : undefined, onRenderPlaceholder: () => React__default['default'].createElement(LoadingSpinner, { loadingMessage: loadingMessage }) }));
});
const LoadingSpinner = (props) => {
    return (React__default['default'].createElement(react.Stack, { verticalAlign: "center", className: loadingStyle },
        React__default['default'].createElement(react.Spinner, { label: props.loadingMessage, size: react.SpinnerSize.xSmall, "aria-live": 'assertive' })));
};

// Copyright (c) Microsoft Corporation.
// Currently the Calling JS SDK supports up to 4 remote video streams
const DEFAULT_MAX_REMOTE_VIDEO_STREAMS = 4;
// Set aside only 6 dominant speakers for remaining audio participants
const MAX_AUDIO_DOMINANT_SPEAKERS = 6;
const DRAG_OPTIONS = {
    moveMenuItemText: 'Move',
    closeMenuItemText: 'Close',
    menu: react.ContextualMenu,
    keepInBounds: true
};
/**
 * VideoGallery represents a layout of video tiles for a specific call.
 * It displays a {@link VideoTile} for the local user as well as for each remote participant who has joined the call.
 *
 * @public
 */
const VideoGallery = (props) => {
    var _a, _b, _c, _d, _e;
    const { localParticipant, remoteParticipants = [], localVideoViewOptions, remoteVideoViewOptions, dominantSpeakers, onRenderLocalVideoTile, onRenderRemoteVideoTile, onCreateLocalStreamView, onCreateRemoteStreamView, onDisposeRemoteStreamView, styles, layout, onRenderAvatar, showMuteIndicator, maxRemoteVideoStreams = DEFAULT_MAX_REMOTE_VIDEO_STREAMS } = props;
    const ids = useIdentifiers();
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.videoGallery;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const shouldFloatLocalVideo = !!(layout === 'floatingLocalVideo' && remoteParticipants.length > 0);
    const containerRef = React.useRef(null);
    const containerWidth = useContainerWidth(containerRef);
    const isNarrow = isNarrowWidth(containerWidth);
    const visibleVideoParticipants = React.useRef([]);
    const visibleAudioParticipants = React.useRef([]);
    visibleVideoParticipants.current = smartDominantSpeakerParticipants({
        participants: (_a = remoteParticipants === null || remoteParticipants === void 0 ? void 0 : remoteParticipants.filter((p) => { var _a; return (_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable; })) !== null && _a !== void 0 ? _a : [],
        dominantSpeakers,
        lastVisibleParticipants: visibleVideoParticipants.current,
        maxDominantSpeakers: maxRemoteVideoStreams
    }).slice(0, maxRemoteVideoStreams);
    // This set will be used to filter out participants already in visibleVideoParticipants
    const visibleVideoParticipantsSet = new Set(visibleVideoParticipants.current.map((p) => p.userId));
    visibleAudioParticipants.current = smartDominantSpeakerParticipants({
        participants: (_b = remoteParticipants === null || remoteParticipants === void 0 ? void 0 : remoteParticipants.filter((p) => !visibleVideoParticipantsSet.has(p.userId))) !== null && _b !== void 0 ? _b : [],
        dominantSpeakers,
        lastVisibleParticipants: visibleAudioParticipants.current,
        maxDominantSpeakers: MAX_AUDIO_DOMINANT_SPEAKERS
    });
    /**
     * Utility function for memoized rendering of LocalParticipant.
     */
    const localVideoTile = React.useMemo(() => {
        const localVideoStream = localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.videoStream;
        if (onRenderLocalVideoTile) {
            return onRenderLocalVideoTile(localParticipant);
        }
        const localVideoTileStyles = shouldFloatLocalVideo ? floatingLocalVideoTileStyle : {};
        const localVideoTileStylesThemed = react.concatStyleSets(localVideoTileStyles, {
            root: { borderRadius: theme.effects.roundedCorner4 }
        }, styles === null || styles === void 0 ? void 0 : styles.localVideo);
        if (localVideoStream && !localVideoStream.renderElement) {
            onCreateLocalStreamView && onCreateLocalStreamView(localVideoViewOptions);
        }
        return (React__default['default'].createElement(VideoTile, { key: localParticipant.userId, userId: localParticipant.userId, renderElement: (localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.renderElement) ? (React__default['default'].createElement(StreamMedia, { videoStreamElement: localVideoStream.renderElement })) : undefined, showLabel: !(shouldFloatLocalVideo && isNarrow), displayName: isNarrow ? '' : strings.localVideoLabel, initialsName: localParticipant.displayName, styles: localVideoTileStylesThemed, onRenderPlaceholder: onRenderAvatar, isMuted: localParticipant.isMuted, showMuteIndicator: showMuteIndicator }));
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        localParticipant,
        localParticipant.isScreenSharingOn,
        localParticipant.videoStream,
        (_c = localParticipant.videoStream) === null || _c === void 0 ? void 0 : _c.renderElement,
        isNarrow,
        onCreateLocalStreamView,
        onRenderLocalVideoTile,
        onRenderAvatar,
        shouldFloatLocalVideo
    ]);
    const defaultOnRenderVideoTile = React.useCallback((participant, isVideoParticipant) => {
        const remoteVideoStream = participant.videoStream;
        return (React__default['default'].createElement(RemoteVideoTile, Object.assign({ key: participant.userId }, participant, { onCreateRemoteStreamView: isVideoParticipant ? onCreateRemoteStreamView : undefined, onDisposeRemoteStreamView: isVideoParticipant ? onDisposeRemoteStreamView : undefined, isAvailable: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.isAvailable : false, renderElement: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.renderElement : undefined, remoteVideoViewOptions: isVideoParticipant ? remoteVideoViewOptions : undefined, onRenderAvatar: onRenderAvatar, showMuteIndicator: showMuteIndicator })));
    }, [onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions, onRenderAvatar, showMuteIndicator]);
    const videoTiles = onRenderRemoteVideoTile
        ? visibleVideoParticipants.current.map((participant) => onRenderRemoteVideoTile(participant))
        : visibleVideoParticipants.current.map((participant) => {
            return defaultOnRenderVideoTile(participant, true);
        });
    const audioTiles = onRenderRemoteVideoTile
        ? visibleAudioParticipants.current.map((participant) => onRenderRemoteVideoTile(participant))
        : visibleAudioParticipants.current.map((participant) => {
            return defaultOnRenderVideoTile(participant, false);
        });
    const screenShareParticipant = remoteParticipants.find((participant) => { var _a; return (_a = participant.screenShareStream) === null || _a === void 0 ? void 0 : _a.isAvailable; });
    const screenShareActive = screenShareParticipant || (localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isScreenSharingOn);
    let gridTiles = [];
    let horizontalGalleryTiles = [];
    if (screenShareActive) {
        // If screen sharing is active, assign video and audio participants as horizontal gallery participants
        horizontalGalleryTiles = videoTiles.concat(audioTiles);
    }
    else {
        // If screen sharing is not active, then assign all video tiles as grid tiles.
        // If there are no video tiles, then assign audio tiles as grid tiles.
        gridTiles = videoTiles.length > 0 ? videoTiles : audioTiles;
        horizontalGalleryTiles = videoTiles.length > 0 ? audioTiles : [];
    }
    if (!shouldFloatLocalVideo && localParticipant) {
        gridTiles.push(localVideoTile);
    }
    const localScreenShareStreamComponent = React__default['default'].createElement(LocalScreenShare, { localParticipant: localParticipant });
    const remoteScreenShareComponent = screenShareParticipant && (React__default['default'].createElement(RemoteScreenShare, Object.assign({}, screenShareParticipant, { renderElement: (_d = screenShareParticipant.screenShareStream) === null || _d === void 0 ? void 0 : _d.renderElement, onCreateRemoteStreamView: onCreateRemoteStreamView, onDisposeRemoteStreamView: onDisposeRemoteStreamView })));
    React.useEffect(() => {
        if (containerRef.current) {
            containerRef.current.id = `video-gallery-${uuid.v4()}`;
        }
    }, [containerRef]);
    const horizontalGalleryPresent = horizontalGalleryTiles && horizontalGalleryTiles.length > 0;
    return (React__default['default'].createElement("div", { "data-ui-id": ids.videoGallery, ref: containerRef, className: react.mergeStyles(videoGalleryOuterDivStyle, styles === null || styles === void 0 ? void 0 : styles.root) },
        shouldFloatLocalVideo &&
            localParticipant &&
            (horizontalGalleryPresent ? (React__default['default'].createElement(react.Stack, { className: react.mergeStyles(localVideoTileContainerStyle(theme, isNarrow)) }, localVideoTile)) : (React__default['default'].createElement(react.Modal, { isOpen: true, isModeless: true, dragOptions: DRAG_OPTIONS, styles: floatingLocalVideoModalStyle(theme, isNarrow), layerProps: { hostId: (_e = containerRef.current) === null || _e === void 0 ? void 0 : _e.id } }, localVideoTile))),
        React__default['default'].createElement(react.Stack, { horizontal: false, styles: videoGalleryContainerStyle, tokens: videoGalleryContainerTokens },
            screenShareParticipant ? (remoteScreenShareComponent) : (localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isScreenSharingOn) ? (localScreenShareStreamComponent) : (React__default['default'].createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles)),
            horizontalGalleryPresent && (React__default['default'].createElement(ResponsiveHorizontalGallery, { key: "responsive-horizontal-gallery", containerStyles: horizontalGalleryContainerStyle(shouldFloatLocalVideo, isNarrow), horizontalGalleryStyles: react.concatStyleSets(horizontalGalleryStyle(isNarrow), styles === null || styles === void 0 ? void 0 : styles.horizontalGallery), childWidthRem: isNarrow ? SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width : LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.width, buttonWidthRem: HORIZONTAL_GALLERY_BUTTON_WIDTH, gapWidthRem: HORIZONTAL_GALLERY_GAP }, horizontalGalleryTiles)))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const controlBarStyles = {
    horizontal: {
        flexFlow: 'row nowrap'
    },
    vertical: {
        flexFlow: 'column nowrap',
        maxWidth: '3.5rem'
    },
    dockedTop: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        minWidth: 'fit-content'
    },
    dockedBottom: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        bottom: 0,
        left: 0,
        width: '100%',
        minWidth: 'fit-content'
    },
    dockedLeft: {
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        left: 0,
        height: '100%'
    },
    dockedRight: {
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        right: 0,
        height: '100%'
    },
    floatingTop: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '1rem',
        left: '50%',
        transform: 'translateX(-50%)',
        minWidth: 'fit-content',
        zIndex: 10
    },
    floatingBottom: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        bottom: '1rem',
        left: '50%',
        transform: 'translateX(-50%)',
        minWidth: 'fit-content',
        zIndex: 10
    },
    floatingLeft: {
        flexFlow: 'column nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '50%',
        left: '1rem',
        transform: 'translateY(-50%)',
        zIndex: 10
    },
    floatingRight: {
        flexFlow: 'column nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '50%',
        right: '1rem',
        transform: 'translateY(-50%)',
        zIndex: 10
    }
};
/**
 * @private
 */
const controlButtonStyles = {
    root: {
        background: 'none',
        border: 'none',
        borderRadius: 0,
        minHeight: '3.5rem',
        minWidth: '3.5rem',
        svg: {
            verticalAlign: 'text-top'
        }
    },
    flexContainer: {
        flexFlow: 'column',
        display: 'contents'
    },
    label: {
        fontSize: '0.625rem',
        fontWeight: '400',
        lineHeight: '1rem',
        cursor: 'pointer',
        display: 'block',
        margin: '0rem 0.25rem'
    }
};
/**
 * making it Partial as IContextualMenuStyles has all its props non-optional and we only need title to be defined here.
 *
 * @private
 */
const participantsButtonMenuPropsStyle = {
    title: {
        background: 'initial',
        paddingLeft: '.5rem',
        fontWeight: 600,
        fontSize: '.75rem'
    }
};
/**
 * @private
 */
const defaultParticipantListContainerStyle = {
    root: {
        maxHeight: '20rem'
    }
};
/**
 * Default styles for button flyout items
 *
 * @private
 */
const buttonFlyoutItemStyles = {
    icon: {
        lineHeight: 0
    },
    checkmarkIcon: {
        lineHeight: 0
    }
};

// Copyright (c) Microsoft Corporation.
// Place callout with no gap between it and the button.
const calloutProps = { gapSpace: 0 };
// The TooltipHost root uses display: inline by default.
// To prevent sizing issues or tooltip positioning issues, we override to inline-block.
// For more details see "Icon Button with Tooltip" on https://developer.microsoft.com/en-us/fluentui#/controls/web/button
const hostStyles = { root: { display: 'inline-block' } };
/**
 * Tooltip that should wrap control bar buttons.
 *
 * @private
 */
const ControlButtonTooltip = (props) => {
    return (React__default['default'].createElement(react.TooltipHost, Object.assign({}, props, { "data-ui-id": props.id, calloutProps: Object.assign(Object.assign({}, calloutProps), props.calloutProps), styles: react.mergeStyleSets(hostStyles, props.styles) }), props.children));
};

// Copyright (c) Microsoft Corporation.
const DefaultRenderIcon = (props) => {
    return (props === null || props === void 0 ? void 0 : props.checked)
        ? (props === null || props === void 0 ? void 0 : props.onRenderOnIcon)
            ? props === null || props === void 0 ? void 0 : props.onRenderOnIcon()
            : null
        : (props === null || props === void 0 ? void 0 : props.onRenderOffIcon)
            ? props === null || props === void 0 ? void 0 : props.onRenderOffIcon()
            : null;
};
/**
 * Default button styled for the {@link ControlBar}.
 *
 * Use this component create custom buttons that are styled the same as other buttons provided by the UI Library.
 *
 * @public
 */
const ControlBarButton = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const componentStyles = react.concatStyleSets(controlButtonStyles, (_a = props.styles) !== null && _a !== void 0 ? _a : {});
    const labelText = (_d = (_b = props === null || props === void 0 ? void 0 : props.text) !== null && _b !== void 0 ? _b : (_c = props === null || props === void 0 ? void 0 : props.strings) === null || _c === void 0 ? void 0 : _c.label) !== null && _d !== void 0 ? _d : ((props === null || props === void 0 ? void 0 : props.checked) ? (_e = props === null || props === void 0 ? void 0 : props.strings) === null || _e === void 0 ? void 0 : _e.onLabel : (_f = props === null || props === void 0 ? void 0 : props.strings) === null || _f === void 0 ? void 0 : _f.offLabel);
    const tooltipContent = (_h = (_g = props === null || props === void 0 ? void 0 : props.strings) === null || _g === void 0 ? void 0 : _g.tooltipContent) !== null && _h !== void 0 ? _h : ((props === null || props === void 0 ? void 0 : props.disabled)
        ? (_j = props === null || props === void 0 ? void 0 : props.strings) === null || _j === void 0 ? void 0 : _j.tooltipDisabledContent
        : (props === null || props === void 0 ? void 0 : props.checked)
            ? (_k = props === null || props === void 0 ? void 0 : props.strings) === null || _k === void 0 ? void 0 : _k.tooltipOnContent
            : (_l = props === null || props === void 0 ? void 0 : props.strings) === null || _l === void 0 ? void 0 : _l.tooltipOffContent);
    const tooltipId = ((_m = props.tooltipId) !== null && _m !== void 0 ? _m : props.labelKey) ? props.labelKey + '-tooltip' : undefined;
    return (React__default['default'].createElement(ControlButtonTooltip, { content: tooltipContent, id: tooltipId },
        React__default['default'].createElement(react.DefaultButton, Object.assign({}, props, { styles: componentStyles, onRenderText: props.showLabel && props.onRenderText ? props.onRenderText : undefined, onRenderIcon: (_o = props.onRenderIcon) !== null && _o !== void 0 ? _o : DefaultRenderIcon, ariaLabel: tooltipContent }), props.showLabel ? labelText : React__default['default'].createElement(React__default['default'].Fragment, null))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$h = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const defaultLocalVideoViewOptions = {
    scalingMode: 'Crop',
    isMirrored: true
};
const onRenderCameraOnIcon = () => React__default['default'].createElement(react.Icon, { iconName: "ControlButtonCameraOn" });
const onRenderCameraOffIcon = () => React__default['default'].createElement(react.Icon, { iconName: "ControlButtonCameraOff" });
/**
 * A button to turn camera on / off.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const CameraButton = (props) => {
    var _a, _b, _c;
    const { localVideoViewOptions, onToggleCamera } = props;
    const [waitForCamera, setWaitForCamera] = React.useState(false);
    const localeStrings = useLocale$1().strings.cameraButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const onToggleClick = React.useCallback(() => __awaiter$h(void 0, void 0, void 0, function* () {
        // Throttle click on camera, need to await onToggleCamera then allow another click
        if (onToggleCamera) {
            setWaitForCamera(true);
            try {
                yield onToggleCamera(localVideoViewOptions !== null && localVideoViewOptions !== void 0 ? localVideoViewOptions : defaultLocalVideoViewOptions);
            }
            finally {
                setWaitForCamera(false);
            }
        }
    }), [localVideoViewOptions, onToggleCamera]);
    return (React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { disabled: props.disabled || waitForCamera, onClick: onToggleCamera ? onToggleClick : props.onClick, onRenderOnIcon: (_a = props.onRenderOnIcon) !== null && _a !== void 0 ? _a : onRenderCameraOnIcon, onRenderOffIcon: (_b = props.onRenderOffIcon) !== null && _b !== void 0 ? _b : onRenderCameraOffIcon, strings: strings, labelKey: (_c = props.labelKey) !== null && _c !== void 0 ? _c : 'cameraButtonLabel' })));
};

// Copyright (c) Microsoft Corporation.
const mainDivStyle = { position: 'relative', height: '100%', width: '100%' };
/**
 * A container for various buttons for call controls.
 *
 * Use with various call control buttons in this library, e.g., {@link CameraButton}, or your own instances of
 * {@link ControlBarButton} directly.
 *
 * @public
 */
const ControlBar = (props) => {
    const { styles, layout } = props;
    const theme = useTheme();
    const controlBarClassName = React.useMemo(() => {
        const controlBarStyle = controlBarStyles[layout !== null && layout !== void 0 ? layout : 'horizontal'];
        // if theme is dark and layout is floating then use palette.neutralQuaternaryAlt as background, otherwise use palette.white
        const backgroundStyle = {
            background: isDarkThemed(theme) && (layout === null || layout === void 0 ? void 0 : layout.startsWith('floating')) ? theme.palette.neutralQuaternaryAlt : theme.palette.white
        };
        const borderAndBoxShadowStyle = (layout === null || layout === void 0 ? void 0 : layout.startsWith('floating'))
            ? {
                boxShadow: theme.effects.elevation16,
                borderRadius: theme.effects.roundedCorner6
            }
            : {};
        // if rtl is true and layout is either floatingTop or floatingBottom then we need to override the transform-style property
        // to translate 50% to right instead of the left
        const transformOverrideStyle = theme.rtl && (layout === 'floatingTop' || layout === 'floatingBottom') ? { transform: 'translateX(50%)' } : {};
        return react.mergeStyles(controlBarStyle, backgroundStyle, borderAndBoxShadowStyle, transformOverrideStyle, styles === null || styles === void 0 ? void 0 : styles.root);
    }, [layout, styles === null || styles === void 0 ? void 0 : styles.root, theme]);
    return (React__default['default'].createElement("div", { className: react.mergeStyles(mainDivStyle) },
        React__default['default'].createElement(react.Stack, { className: controlBarClassName }, props.children)));
};

// Copyright (c) Microsoft Corporation.
const onRenderEndCallIcon = () => React__default['default'].createElement(react.Icon, { iconName: "ControlButtonEndCall" });
/**
 * A button to end an ongoing call.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const EndCallButton = (props) => {
    var _a, _b, _c;
    const { styles } = props;
    const localeStrings = useLocale$1().strings.endCallButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = useTheme();
    const isDarkTheme = isDarkThemed(theme);
    const componentStyles = react.concatStyleSets(isDarkTheme ? darkThemeCallButtonStyles : lightThemeCallButtonStyles, styles !== null && styles !== void 0 ? styles : {});
    return (React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { onClick: (_a = props.onHangUp) !== null && _a !== void 0 ? _a : props.onClick, styles: componentStyles, onRenderIcon: (_b = props.onRenderIcon) !== null && _b !== void 0 ? _b : onRenderEndCallIcon, strings: strings, labelKey: (_c = props.labelKey) !== null && _c !== void 0 ? _c : 'endCallButtonLabel' })));
};
const darkThemeCallButtonStyles = {
    root: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed,
        ':focus::after': { outlineColor: `${darkTheme.callingPalette.iconWhite} !important` } // added !important to avoid override by FluentUI button styles
    },
    rootHovered: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed
    },
    rootPressed: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed
    },
    label: {
        color: darkTheme.callingPalette.iconWhite
    }
};
const lightThemeCallButtonStyles = {
    root: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed,
        ':focus::after': { outlineColor: `${lightTheme.callingPalette.iconWhite} !important` } // added !important to avoid override by FluentUI button styles
    },
    rootHovered: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed
    },
    rootPressed: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed
    },
    label: {
        color: lightTheme.callingPalette.iconWhite
    }
};

// Copyright (c) Microsoft Corporation.
const onRenderMicOnIcon = () => React__default['default'].createElement(react.Icon, { iconName: "ControlButtonMicOn" });
const onRenderMicOffIcon = () => React__default['default'].createElement(react.Icon, { iconName: "ControlButtonMicOff" });
/**
 * A button to turn microphone on / off.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const MicrophoneButton = (props) => {
    var _a, _b, _c, _d;
    const localeStrings = useLocale$1().strings.microphoneButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    return (React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { onClick: (_a = props.onToggleMicrophone) !== null && _a !== void 0 ? _a : props.onClick, onRenderOnIcon: (_b = props.onRenderOnIcon) !== null && _b !== void 0 ? _b : onRenderMicOnIcon, onRenderOffIcon: (_c = props.onRenderOffIcon) !== null && _c !== void 0 ? _c : onRenderMicOffIcon, strings: strings, labelKey: (_d = props.labelKey) !== null && _d !== void 0 ? _d : 'microphoneButtonLabel' })));
};

// Copyright (c) Microsoft Corporation.
/**
 * Generates default menuprops for an DevicesButton if the props contain device
 * information and device change handlers.
 * @param props DevicesButtonProps
 * @returns MenuProps
 */
const generateDefaultMenuProps = (props, strings) => {
    var _a, _b, _c, _d;
    const { microphones, speakers, cameras, selectedMicrophone, selectedSpeaker, selectedCamera, onSelectCamera, onSelectMicrophone, onSelectSpeaker } = props;
    const defaultMenuProps = {
        items: [],
        styles: (_a = props.styles) === null || _a === void 0 ? void 0 : _a.menuStyles,
        calloutProps: {
            styles: {
                root: {
                    // Confine the menu to the parents bounds.
                    // More info: https://github.com/microsoft/fluentui/issues/18835
                    // NB: 95% to keep some space for margin, drop shadow etc around the Callout.
                    maxWidth: '95%'
                }
            },
            // Disable dismiss on resize to work around a couple Fluent UI bugs
            // - The Callout is dismissed whenever *any child of window (inclusive)* is resized. In practice, this
            //   happens when we change the VideoGallery layout, or even when the video stream element is internally resized
            //   by the headless SDK.
            // - There is a `preventDismissOnEvent` prop that we could theoretically use to only dismiss when the target of
            //   of the 'resize' event is the window itself. But experimentation shows that setting that prop doesn't
            //   deterministically avoid dismissal.
            //
            // A side effect of this workaround is that the context menu stays open when window is resized, and may
            // get detached from original target visually. That bug is preferable to the bug when this value is not set -
            // The Callout (frequently) gets dismissed automatically.
            preventDismissOnResize: true
        }
    };
    const menuItemStyles = react.merge(buttonFlyoutItemStyles, (_d = (_c = (_b = props.styles) === null || _b === void 0 ? void 0 : _b.menuStyles) === null || _c === void 0 ? void 0 : _c.menuItemStyles) !== null && _d !== void 0 ? _d : {});
    if (cameras && selectedCamera && onSelectCamera) {
        defaultMenuProps.items.push({
            key: 'sectionCamera',
            title: strings.cameraMenuTooltip,
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.cameraMenuTitle,
                items: cameras.map((camera) => ({
                    key: camera.id,
                    text: camera.name,
                    title: camera.name,
                    iconProps: { iconName: 'OptionsCamera', styles: { root: { lineHeight: 0 } } },
                    itemProps: {
                        styles: menuItemStyles
                    },
                    canCheck: true,
                    isChecked: camera.id === (selectedCamera === null || selectedCamera === void 0 ? void 0 : selectedCamera.id),
                    onClick: () => {
                        if (camera.id !== (selectedCamera === null || selectedCamera === void 0 ? void 0 : selectedCamera.id)) {
                            onSelectCamera(camera);
                        }
                    }
                }))
            }
        });
    }
    if (microphones && selectedMicrophone && onSelectMicrophone) {
        defaultMenuProps.items.push({
            key: 'sectionMicrophone',
            title: strings.microphoneMenuTooltip,
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.microphoneMenuTitle,
                items: microphones.map((microphone) => ({
                    key: microphone.id,
                    text: microphone.name,
                    title: microphone.name,
                    iconProps: { iconName: 'OptionsMic', styles: { root: { lineHeight: 0 } } },
                    itemProps: {
                        styles: menuItemStyles
                    },
                    canCheck: true,
                    isChecked: microphone.id === (selectedMicrophone === null || selectedMicrophone === void 0 ? void 0 : selectedMicrophone.id),
                    onClick: () => {
                        if (microphone.id !== (selectedMicrophone === null || selectedMicrophone === void 0 ? void 0 : selectedMicrophone.id)) {
                            onSelectMicrophone(microphone);
                        }
                    }
                }))
            }
        });
    }
    if (speakers && selectedSpeaker && onSelectSpeaker) {
        defaultMenuProps.items.push({
            key: 'sectionSpeaker',
            title: strings.speakerMenuTooltip,
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.speakerMenuTitle,
                items: speakers.map((speaker) => ({
                    key: speaker.id,
                    text: speaker.name,
                    title: speaker.name,
                    iconProps: { iconName: 'OptionsSpeaker', styles: { root: { lineHeight: 0 } } },
                    itemProps: {
                        styles: menuItemStyles
                    },
                    canCheck: true,
                    isChecked: speaker.id === (selectedSpeaker === null || selectedSpeaker === void 0 ? void 0 : selectedSpeaker.id),
                    onClick: () => {
                        if (speaker.id !== (selectedSpeaker === null || selectedSpeaker === void 0 ? void 0 : selectedSpeaker.id)) {
                            onSelectSpeaker(speaker);
                        }
                    }
                }))
            }
        });
    }
    if (defaultMenuProps.items.length === 0) {
        // Avoids creating an empty context menu.
        return undefined;
    }
    return defaultMenuProps;
};
const onRenderOptionsIcon = () => React__default['default'].createElement(react.Icon, { iconName: "ControlButtonOptions" });
/**
 * A button to open a menu that controls device options.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const DevicesButton = (props) => {
    var _a, _b;
    const { onRenderIcon } = props;
    const localeStrings = useLocale$1().strings.devicesButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const devicesButtonMenu = (_a = props.menuProps) !== null && _a !== void 0 ? _a : generateDefaultMenuProps(props, strings);
    return (React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { menuProps: devicesButtonMenu, menuIconProps: { hidden: true }, onRenderIcon: onRenderIcon !== null && onRenderIcon !== void 0 ? onRenderIcon : onRenderOptionsIcon, strings: strings, labelKey: (_b = props.labelKey) !== null && _b !== void 0 ? _b : 'devicesButtonLabel' })));
};

// Copyright (c) Microsoft Corporation.
const onRenderPeopleIcon = () => {
    return React__default['default'].createElement(react.Icon, { iconName: "ControlButtonParticipants" });
};
/**
 * A button to show a menu with calling or chat participants.
 *
 * Can be used with {@link ControlBar}.
 *
 * This button contains dropdown menu items defined through its property `menuProps`. By default, it can display the number of remote participants with the full list
 * as sub-menu and an option to mute all participants, as well as a copy-to-clipboard button to copy the call invitation URL.
 * This `menuProps` can be fully redefined and its property is of type [IContextualMenuProps](https://developer.microsoft.com/fluentui#/controls/web/contextualmenu#IContextualMenuProps).
 *
 * @public
 */
const ParticipantsButton = (props) => {
    var _a, _b, _c, _d;
    const { callInvitationURL, styles, onMuteAll, onRenderIcon, onRenderParticipantList, participants, myUserId, excludeMe, onRenderParticipant, onRenderAvatar, onRemoveParticipant, onFetchParticipantMenuItems } = props;
    const ids = useIdentifiers();
    const onMuteAllCallback = React.useCallback(() => {
        if (onMuteAll) {
            onMuteAll();
        }
    }, [onMuteAll]);
    const defaultParticipantList = React.useCallback(() => {
        var _a;
        return (React__default['default'].createElement(ParticipantList, { participants: participants, myUserId: myUserId, excludeMe: excludeMe, onRenderParticipant: onRenderParticipant, onRenderAvatar: onRenderAvatar, onRemoveParticipant: onRemoveParticipant, onFetchParticipantMenuItems: onFetchParticipantMenuItems, styles: react.merge(defaultParticipantListContainerStyle, (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.participantListStyles) }));
    }, [
        excludeMe,
        myUserId,
        onRemoveParticipant,
        onRenderAvatar,
        onRenderParticipant,
        participants,
        (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.participantListStyles,
        onFetchParticipantMenuItems
    ]);
    const onCopyCallback = React.useCallback(() => {
        if (callInvitationURL) {
            return copy__default['default'](callInvitationURL);
        }
        return false;
    }, [callInvitationURL]);
    const localeStrings = useLocale$1().strings.participantsButton;
    const strings = React.useMemo(() => (Object.assign(Object.assign({}, localeStrings), props.strings)), [localeStrings, props.strings]);
    const participantCount = participants.length;
    const generateDefaultParticipantsSubMenuProps = React.useCallback(() => {
        var _a;
        const items = [];
        if (participantCount > 0) {
            items.push({
                key: 'participantListMenuItemKey',
                onRender: onRenderParticipantList !== null && onRenderParticipantList !== void 0 ? onRenderParticipantList : defaultParticipantList
            });
            items.push({ key: 'participantsDivider1', itemType: react.ContextualMenuItemType.Divider });
            if (onMuteAll) {
                items.push({
                    key: 'muteAllKey',
                    text: strings.muteAllButtonLabel,
                    title: strings.muteAllButtonLabel,
                    styles: (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.menuItemStyles,
                    iconProps: { iconName: 'MicOff2' },
                    onClick: onMuteAllCallback
                });
            }
        }
        return items;
    }, [
        participantCount,
        onRenderParticipantList,
        defaultParticipantList,
        onMuteAll,
        strings.muteAllButtonLabel,
        (_b = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _b === void 0 ? void 0 : _b.menuItemStyles,
        onMuteAllCallback
    ]);
    const defaultMenuProps = React.useMemo(() => {
        var _a, _b;
        const menuProps = {
            title: strings.menuHeader,
            styles: react.merge(participantsButtonMenuPropsStyle, styles === null || styles === void 0 ? void 0 : styles.menuStyles),
            items: [],
            calloutProps: {
                // Disable dismiss on resize to work around a couple Fluent UI bugs
                // - The Callout is dismissed whenever *any child of window (inclusive)* is resized. In practice, this
                //   happens when we change the VideoGallery layout, or even when the video stream element is internally resized
                //   by the headless SDK.
                // - There is a `preventDismissOnEvent` prop that we could theoretically use to only dismiss when the target of
                //   of the 'resize' event is the window itself. But experimentation shows that setting that prop doesn't
                //   deterministically avoid dismissal.
                //
                // A side effect of this workaround is that the context menu stays open when window is resized, and may
                // get detached from original target visually. That bug is preferable to the bug when this value is not set -
                // The Callout (frequently) gets dismissed automatically.
                preventDismissOnResize: true
            }
        };
        if (participantCount > 0) {
            const participantIds = participants.map((p) => p.userId);
            let participantCountWithoutMe = participantIds.length;
            if (excludeMe) {
                participantCountWithoutMe -= 1;
            }
            menuProps.items.push({
                key: 'participantCountKey',
                name: _formatString(strings.participantsListButtonLabel, { numParticipants: `${participantCountWithoutMe}` }),
                itemProps: { styles: (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.menuItemStyles },
                iconProps: { iconName: 'People' },
                subMenuProps: {
                    items: generateDefaultParticipantsSubMenuProps(),
                    calloutProps: {
                        styles: {
                            root: {
                                // Confine the menu to the parents bounds.
                                // More info: https://github.com/microsoft/fluentui/issues/18835
                                maxWidth: '100%'
                            }
                        },
                        // Disable dismiss on resize to work around a couple Fluent UI bugs
                        // See reasoning in the props for the parent menu.
                        preventDismissOnResize: true
                    }
                },
                'data-ui-id': ids.participantButtonPeopleMenuItem
            });
        }
        if (callInvitationURL) {
            menuProps.items.push({
                key: 'InviteLinkKey',
                name: strings.copyInviteLinkButtonLabel,
                title: strings.copyInviteLinkButtonLabel,
                itemProps: { styles: (_b = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _b === void 0 ? void 0 : _b.menuItemStyles },
                iconProps: { iconName: 'Link' },
                onClick: onCopyCallback
            });
        }
        return menuProps;
    }, [
        strings.menuHeader,
        strings.participantsListButtonLabel,
        strings.copyInviteLinkButtonLabel,
        styles === null || styles === void 0 ? void 0 : styles.menuStyles,
        participantCount,
        callInvitationURL,
        participants,
        excludeMe,
        ids.participantButtonPeopleMenuItem,
        generateDefaultParticipantsSubMenuProps,
        onCopyCallback
    ]);
    return (React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { menuProps: (_c = props.menuProps) !== null && _c !== void 0 ? _c : defaultMenuProps, menuIconProps: { hidden: true }, onRenderIcon: onRenderIcon !== null && onRenderIcon !== void 0 ? onRenderIcon : onRenderPeopleIcon, strings: strings, labelKey: (_d = props.labelKey) !== null && _d !== void 0 ? _d : 'participantsButtonLabel' })));
};

// Copyright (c) Microsoft Corporation.
const onRenderScreenShareOnIcon = () => React__default['default'].createElement(react.Icon, { iconName: "ControlButtonScreenShareStop" });
const onRenderScreenShareOffIcon = () => React__default['default'].createElement(react.Icon, { iconName: "ControlButtonScreenShareStart" });
/**
 * A button to start / stop screen sharing.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const ScreenShareButton = (props) => {
    var _a, _b, _c, _d;
    const localeStrings = useLocale$1().strings.screenShareButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = react.useTheme();
    const styles = screenshareButtonStyles(theme);
    return (React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { styles: styles, onClick: (_a = props.onToggleScreenShare) !== null && _a !== void 0 ? _a : props.onClick, onRenderOnIcon: (_b = props.onRenderOnIcon) !== null && _b !== void 0 ? _b : onRenderScreenShareOnIcon, onRenderOffIcon: (_c = props.onRenderOffIcon) !== null && _c !== void 0 ? _c : onRenderScreenShareOffIcon, strings: strings, labelKey: (_d = props.labelKey) !== null && _d !== void 0 ? _d : 'screenShareButtonLabel' })));
};
const screenshareButtonStyles = (theme) => ({
    rootChecked: {
        background: theme.palette.themePrimary,
        color: react.DefaultPalette.white,
        ':focus::after': { outlineColor: `${react.DefaultPalette.white} !important` } // added !important to avoid override by FluentUI button styles
    },
    rootCheckedHovered: {
        background: theme.palette.themePrimary,
        color: react.DefaultPalette.white,
        ':focus::after': { outlineColor: `${react.DefaultPalette.white} !important` } // added !important to avoid override by FluentUI button styles
    },
    labelChecked: { color: react.DefaultPalette.white }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const checkIsSpeaking = (participant) => participant.isSpeaking && !participant.isMuted;

// Copyright (c) Microsoft Corporation.
const convertRemoteVideoStreamToVideoGalleryStream = (stream) => {
    var _a, _b;
    return {
        id: stream.id,
        isAvailable: stream.isAvailable,
        isMirrored: (_a = stream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
        renderElement: (_b = stream.view) === null || _b === void 0 ? void 0 : _b.target
    };
};
const convertRemoteParticipantToVideoGalleryRemoteParticipant = (userId, isMuted, isSpeaking, videoStreams, displayName) => {
    const rawVideoStreamsArray = Object.values(videoStreams);
    let videoStream = undefined;
    let screenShareStream = undefined;
    if (rawVideoStreamsArray[0]) {
        if (rawVideoStreamsArray[0].mediaStreamType === 'Video') {
            videoStream = convertRemoteVideoStreamToVideoGalleryStream(rawVideoStreamsArray[0]);
        }
        else {
            screenShareStream = convertRemoteVideoStreamToVideoGalleryStream(rawVideoStreamsArray[0]);
        }
    }
    if (rawVideoStreamsArray[1]) {
        if (rawVideoStreamsArray[1].mediaStreamType === 'ScreenSharing') {
            screenShareStream = convertRemoteVideoStreamToVideoGalleryStream(rawVideoStreamsArray[1]);
        }
        else {
            videoStream = convertRemoteVideoStreamToVideoGalleryStream(rawVideoStreamsArray[1]);
        }
    }
    return {
        userId,
        displayName,
        isMuted,
        isSpeaking,
        videoStream,
        screenShareStream,
        isScreenSharingOn: screenShareStream !== undefined && screenShareStream.isAvailable
    };
};
const memoizedAllConvertRemoteParticipant = memoizeFnAll((userId, isMuted, isSpeaking, videoStreams, displayName) => {
    return convertRemoteParticipantToVideoGalleryRemoteParticipant(userId, isMuted, isSpeaking, videoStreams, displayName);
});
const videoGalleryRemoteParticipantsMemo = (remoteParticipants) => {
    if (!remoteParticipants) {
        return [];
    }
    return memoizedAllConvertRemoteParticipant((memoizedFn) => {
        return Object.values(remoteParticipants)
            .filter((participant) => {
            return participant.state !== 'InLobby';
        })
            .map((participant) => {
            return memoizedFn(toFlatCommunicationIdentifier(participant.identifier), participant.isMuted, checkIsSpeaking(participant), participant.videoStreams, participant.displayName);
        });
    });
};
const dominantSpeakersWithFlatId = (dominantSpeakers) => {
    return dominantSpeakers === null || dominantSpeakers === void 0 ? void 0 : dominantSpeakers.speakersList.map(toFlatCommunicationIdentifier);
};
/**
 * Provides data attributes to {@link VideoGallery} component.
 * @public
 */
const videoGallerySelector = reselect.createSelector([
    getScreenShareRemoteParticipant,
    getRemoteParticipants,
    getLocalVideoStreams$1,
    getIsMuted,
    getIsScreenSharingOn,
    getDisplayName$1,
    getIdentifier,
    getDominantSpeakers
], (screenShareRemoteParticipantId, remoteParticipants, localVideoStreams, isMuted, isScreenSharingOn, displayName, identifier, dominantSpeakers) => {
    var _a, _b;
    const screenShareRemoteParticipant = screenShareRemoteParticipantId && remoteParticipants
        ? remoteParticipants[screenShareRemoteParticipantId]
        : undefined;
    const localVideoStream = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find((i) => i.mediaStreamType === 'Video');
    const dominantSpeakerIds = dominantSpeakersWithFlatId(dominantSpeakers);
    dominantSpeakerIds === null || dominantSpeakerIds === void 0 ? void 0 : dominantSpeakerIds.forEach((speaker, idx) => (idx));
    return {
        screenShareParticipant: screenShareRemoteParticipant
            ? convertRemoteParticipantToVideoGalleryRemoteParticipant(toFlatCommunicationIdentifier(screenShareRemoteParticipant.identifier), screenShareRemoteParticipant.isMuted, checkIsSpeaking(screenShareRemoteParticipant), screenShareRemoteParticipant.videoStreams, screenShareRemoteParticipant.displayName)
            : undefined,
        localParticipant: {
            userId: identifier,
            displayName: displayName !== null && displayName !== void 0 ? displayName : '',
            isMuted: isMuted,
            isScreenSharingOn: isScreenSharingOn,
            videoStream: {
                isAvailable: !!localVideoStream,
                isMirrored: (_a = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
                renderElement: (_b = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _b === void 0 ? void 0 : _b.target
            }
        },
        remoteParticipants: videoGalleryRemoteParticipantsMemo(remoteParticipants),
        dominantSpeakers: dominantSpeakerIds
    };
});

// Copyright (c) Microsoft Corporation.
const convertRemoteParticipantsToParticipantListParticipants = (remoteParticipants) => {
    return (remoteParticipants
        // temporarily hiding lobby participants in ACS clients till we can admit users through ACS clients
        .filter((participant) => {
        return participant.state !== 'InLobby';
    })
        .map((participant) => {
        const isScreenSharing = Object.values(participant.videoStreams).some((videoStream) => videoStream.mediaStreamType === 'ScreenSharing' && videoStream.isAvailable);
        return {
            userId: toFlatCommunicationIdentifier(participant.identifier),
            displayName: participant.displayName,
            state: participant.state,
            isMuted: participant.isMuted,
            isScreenSharing: isScreenSharing,
            isSpeaking: participant.isSpeaking,
            // ACS users can not remove Teams users.
            // Removing phone numbers or unknown types of users is undefined.
            isRemovable: communicationCommon.getIdentifierKind(participant.identifier).kind === 'communicationUser'
        };
    })
        .sort((a, b) => {
        var _a, _b;
        const nameA = ((_a = a.displayName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || '';
        const nameB = ((_b = b.displayName) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || '';
        if (nameA < nameB) {
            return -1;
        }
        else if (nameA > nameB) {
            return 1;
        }
        else {
            return 0;
        }
    }));
};
/**
 * Selects data that drives {@link ParticipantList} component.
 *
 * @public
 */
const participantListSelector = reselect.createSelector([getIdentifier, getDisplayName$1, getRemoteParticipants, getIsScreenSharingOn, getIsMuted], (userId, displayName, remoteParticipants, isScreenSharingOn, isMuted) => {
    const participants = remoteParticipants
        ? convertRemoteParticipantsToParticipantListParticipants(Object.values(remoteParticipants))
        : [];
    participants.push({
        userId: userId,
        displayName: displayName,
        isScreenSharing: isScreenSharingOn,
        isMuted: isMuted,
        state: 'Connected',
        // Local participant can never remove themselves.
        isRemovable: false
    });
    return {
        participants: participants,
        myUserId: userId
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * Selects data that drives {@link ParticipantsButton} component.
 *
 * @public
 */
const participantsButtonSelector = reselect.createSelector([participantListSelector], (participantListProps) => {
    return participantListProps;
});

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a handler for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers$3 = (component) => {
    var _a;
    const callClient = (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.callClient;
    const callAgent = useCallAgent();
    const deviceManager = useDeviceManager();
    const call = useCall();
    if (!callClient) {
        return undefined;
    }
    return createDefaultCallingHandlersForComponent(callClient, callAgent, deviceManager, call);
};

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector$3 = (selector, selectorProps) => {
    var _a, _b;
    const callClient = (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.callClient;
    const callId = (_b = useCall()) === null || _b === void 0 ? void 0 : _b.id;
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const callIdConfigProps = React.useMemo(() => ({
        callId
    }), [callId]);
    const [props, setProps] = React.useState(callClient && selector ? selector(callClient.getState(), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callIdConfigProps) : undefined);
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        if (!callClient || !selector) {
            return;
        }
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(state, selectorProps !== null && selectorProps !== void 0 ? selectorProps : callIdConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        callClient.onStateChange(onStateChange);
        return () => {
            callClient.offStateChange(onStateChange);
        };
    }, [callClient, selector, selectorProps, callIdConfigProps, mounted]);
    return selector ? props : undefined;
};

// Copyright (c) Microsoft Corporation.
/**
 * Select the first 3 active errors from the state for the `ErrorBar` component.
 *
 * In case there are many errors, only the first three errors are returned to avoid
 * filling up the UI with too many errors.
 *
 * Invariants:
 *   - `ErrorType` is never repeated in the returned errors.
 *   - Errors are returned in a fixed order by `ErrorType`.
 *
 * @public
 */
const errorBarSelector$1 = reselect.createSelector([getLatestErrors$1, getDiagnostics, getDeviceManager$1], (latestErrors, diagnostics, deviceManager) => {
    var _a, _b, _c, _d;
    // The order in which the errors are returned is significant: The `ErrorBar` shows errors on the UI in that order.
    // There are several options for the ordering:
    //   - Sorted by when the errors happened (latest first / oldest first).
    //   - Stable sort by error type.
    //
    // We chose to stable sort by error type: We intend to show only a small number of errors on the UI and we do not
    // have timestamps for errors.
    const activeErrorMessages = [];
    // Errors reported via diagnostics are more reliable than from API method failures, so process those first.
    if (((_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReceiveQuality) === null || _a === void 0 ? void 0 : _a.value) === communicationCalling.DiagnosticQuality.Bad ||
        ((_b = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReceiveQuality) === null || _b === void 0 ? void 0 : _b.value) == communicationCalling.DiagnosticQuality.Poor) {
        activeErrorMessages.push({ type: 'callNetworkQualityLow' });
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.noSpeakerDevicesEnumerated) {
        activeErrorMessages.push({ type: 'callNoSpeakerFound' });
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.noMicrophoneDevicesEnumerated) {
        activeErrorMessages.push({ type: 'callNoMicrophoneFound' });
    }
    if (((_c = deviceManager.deviceAccess) === null || _c === void 0 ? void 0 : _c.audio) === false || (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphoneNotFunctioning)) {
        activeErrorMessages.push({ type: 'callMicrophoneAccessDenied' });
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphoneMuteUnexpectedly) {
        activeErrorMessages.push({ type: 'callMicrophoneMutedBySystem' });
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphonePermissionDenied) {
        activeErrorMessages.push({ type: 'callMacOsMicrophoneAccessDenied' });
    }
    if (((_d = deviceManager.deviceAccess) === null || _d === void 0 ? void 0 : _d.video) === false) {
        activeErrorMessages.push({ type: 'callCameraAccessDenied' });
    }
    else {
        if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraFreeze) {
            activeErrorMessages.push({ type: 'callCameraAlreadyInUse' });
        }
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraPermissionDenied) {
        activeErrorMessages.push({ type: 'callMacOsCameraAccessDenied' });
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.screenshareRecordingDisabled) {
        activeErrorMessages.push({ type: 'callMacOsScreenShareAccessDenied' });
    }
    // Prefer to show errors with privacy implications.
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.stopVideo', 'stopVideoGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.mute', 'muteGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.stopScreenSharing', 'stopScreenShareGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.startVideo', 'startVideoGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.unmute', 'unmuteGeneric');
    // We only return the first few errors to avoid filling up the UI with too many `MessageBar`s.
    activeErrorMessages.splice(maxErrorCount$1);
    return { activeErrorMessages: activeErrorMessages };
});
const appendActiveErrorIfDefined = (activeErrorMessages, latestErrors, target, activeErrorType) => {
    if (latestErrors[target] === undefined) {
        return;
    }
    activeErrorMessages.push({
        type: activeErrorType,
        timestamp: latestErrors[target].timestamp
    });
};
const maxErrorCount$1 = 3;

// Copyright (c) Microsoft Corporation.
const emptySelector = () => ({});
/**
 * Get the selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
const getSelector$1 = (component) => {
    return findSelector$1(component);
};
const findSelector$1 = (component) => {
    switch (component) {
        case VideoGallery:
            return videoGallerySelector;
        case MicrophoneButton:
            return microphoneButtonSelector;
        case CameraButton:
            return cameraButtonSelector;
        case ScreenShareButton:
            return screenShareButtonSelector;
        case DevicesButton:
            return devicesButtonSelector;
        case ParticipantList:
            return participantListSelector;
        case ParticipantsButton:
            return participantsButtonSelector;
        case EndCallButton:
            return emptySelector;
        case ErrorBar:
            return errorBarSelector$1;
    }
    return undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$g = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Create the default implementation of {@link ChatHandlers}.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * Returned object is memoized to avoid rerenders when used as props for React Components.
 *
 * @public
 */
const createDefaultChatHandlers = memoizeOne__default['default']((chatClient, chatThreadClient) => {
    let messageIterator = undefined;
    return {
        onSendMessage: (content) => __awaiter$g(void 0, void 0, void 0, function* () {
            const sendMessageRequest = {
                content,
                senderDisplayName: chatClient.getState().displayName
            };
            yield chatThreadClient.sendMessage(sendMessageRequest);
        }),
        onUpdateMessage: (messageId, content) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield chatThreadClient.updateMessage(messageId, { content });
        }),
        onDeleteMessage: (messageId) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield chatThreadClient.deleteMessage(messageId);
        }),
        // This handler is designed for chatThread to consume
        onMessageSeen: (chatMessageId) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield chatThreadClient.sendReadReceipt({ chatMessageId });
        }),
        onTyping: () => __awaiter$g(void 0, void 0, void 0, function* () {
            yield chatThreadClient.sendTypingNotification();
        }),
        onRemoveParticipant: (userId) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield chatThreadClient.removeParticipant(fromFlatCommunicationIdentifier(userId));
        }),
        updateThreadTopicName: (topicName) => __awaiter$g(void 0, void 0, void 0, function* () {
            yield chatThreadClient.updateTopic(topicName);
        }),
        onLoadPreviousChatMessages: (messagesToLoad) => __awaiter$g(void 0, void 0, void 0, function* () {
            var _a;
            if (messageIterator === undefined) {
                // Lazy definition so that errors in the method call are reported correctly.
                // Also allows recovery via retries in case of transient errors.
                messageIterator = chatThreadClient.listMessages({ maxPageSize: 50 });
            }
            let remainingMessagesToGet = messagesToLoad;
            let isAllChatMessagesLoaded = false;
            while (remainingMessagesToGet >= 1) {
                const message = yield messageIterator.next();
                if (((_a = message.value) === null || _a === void 0 ? void 0 : _a.type) && message.value.type === 'text') {
                    remainingMessagesToGet--;
                }
                // We have traversed all messages in this thread
                if (message.done) {
                    isAllChatMessagesLoaded = true;
                    break;
                }
            }
            return isAllChatMessagesLoaded;
        })
    };
});
/**
 * Create a set of default handlers for given component.
 *
 * Returned object is memoized (with reference to the arguments) to avoid
 * renders when used as props for React Components.
 *
 * @public
 */
const createDefaultChatHandlersForComponent = (chatClient, chatThreadClient, _) => {
    return createDefaultChatHandlers(chatClient, chatThreadClient);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatClientContext = React.createContext(undefined);
/**
 * A {@link React.Context} that stores a {@link StatefulChatClient}.
 *
 * Chat components from this package must be wrapped with a {@link ChatClientProvider}.
 *
 * @public
 */
const ChatClientProvider = (props) => {
    return React__default['default'].createElement(ChatClientContext.Provider, { value: props.chatClient }, props.children);
};
/**
 * Hook to obtain {@link StatefulChatClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useChatClient = () => {
    const chatClient = React.useContext(ChatClientContext);
    if (!chatClient) {
        throw 'Please wrap components with ChatClientProvider and initialize a chat client before calling the hook!';
    }
    return chatClient;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatThreadClientContext = React.createContext(undefined);
/**
 * A {@link React.Context} that stores a {@link @azure/communication-chat#ChatThreadClient}.
 *
 * Chat components from this package must be wrapped with a {@link ChatThreadClientProvider}.
 *
 * @public
 */
const ChatThreadClientProvider = (props) => {
    return (React__default['default'].createElement(ChatThreadClientContext.Provider, { value: props.chatThreadClient }, props.children));
};
/**
 * Hook to obtain {@link @azure/communication-chat#ChatThreadClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useChatThreadClient = () => {
    const chatThreadClient = React.useContext(ChatThreadClientContext);
    if (!chatThreadClient) {
        throw 'Please wrap components with ChatThreadClientProvider and initialize a chat thread client before calling the hook.';
    }
    return chatThreadClient;
};

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a handler for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useHandlers$2 = (component) => {
    const chatClient = React.useContext(ChatClientContext);
    const chatThreadClient = React.useContext(ChatThreadClientContext);
    if (!chatThreadClient || !chatClient) {
        return undefined;
    }
    return createDefaultChatHandlersForComponent(chatClient, chatThreadClient);
};

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector$2 = (selector, selectorProps) => {
    var _a;
    const chatClient = React.useContext(ChatClientContext);
    const threadId = (_a = React.useContext(ChatThreadClientContext)) === null || _a === void 0 ? void 0 : _a.threadId;
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const threadConfigProps = React.useMemo(() => ({
        threadId
    }), [threadId]);
    const [props, setProps] = React.useState(chatClient && selector ? selector(chatClient.getState(), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps) : undefined);
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        if (!chatClient || !selector) {
            return;
        }
        const onStateChange = (state) => {
            const newProps = selector(state, selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        chatClient.onStateChange(onStateChange);
        return () => {
            chatClient.offStateChange(onStateChange);
        };
    }, [chatClient, selector, selectorProps, threadConfigProps]);
    return selector ? props : undefined;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const getUserId = (state) => toFlatCommunicationIdentifier(state.userId);
/**
 * @private
 */
const getDisplayName = (state) => state.displayName;
/**
 * @private
 */
const getChatMessages = (state, props) => { var _a; return (props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages)) || {}; };
/**
 * @private
 */
const getParticipants = (state, props) => { var _a; return (props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.participants)) || {}; };
/**
 * @private
 */
const getIsLargeGroup = (state, props) => {
    var _a;
    const participants = (_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.participants;
    return !!participants && Object.values(participants).length > 20;
};
/**
 * @private
 */
const getLatestReadTime = (state, props) => { var _a; return (props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.latestReadTime)) || new Date(0); };
/**
 * @private
 */
const getTypingIndicators = (state, props) => {
    var _a;
    return (props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.typingIndicators)) || [];
};
/**
 * @private
 */
const getLatestErrors = (state) => state.latestErrors;

// Copyright (c) Microsoft Corporation.
/**
 * Selector for {@link SendBox} component.
 *
 * @public
 */
const sendBoxSelector = reselect.createSelector([getUserId, getDisplayName], (userId, displayName) => ({
    displayName: displayName,
    userId: userId
}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const MINIMUM_TYPING_INTERVAL_IN_MILLISECONDS = 8000;
/**
 * @private
 */
const PARTICIPANTS_THRESHOLD = 20;
/**
 * @private
 *
 * TODO: Import enum from @azure/communication-chat when ChatMessageType shows up in new release version
 * (or define our type to decouple)
 */
const ACSKnownMessageType = {
    text: 'text',
    html: 'html',
    richtextHtml: 'richtext/html',
    topicUpdated: 'topicUpdated',
    participantAdded: 'participantAdded',
    participantRemoved: 'participantRemoved'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const compareMessages = (firstMessage, secondMessage) => {
    if (firstMessage.createdOn === undefined) {
        return 1;
    }
    if (secondMessage.createdOn === undefined) {
        return -1;
    }
    const firstDate = new Date(firstMessage.createdOn).getTime();
    const secondDate = new Date(secondMessage.createdOn).getTime();
    // Workaround to get a stable order of message before we can get sequenceId from signaling
    // MessageIds are generated by time order the message persist, a good candidate other than time
    const idDelta = firstMessage.messageId && secondMessage.messageId
        ? Number.parseInt(firstMessage.messageId) - Number.parseInt(secondMessage.messageId)
        : 0;
    return firstDate - secondDate === 0 ? idDelta : firstDate - secondDate;
};

/**
 * @private
 */
const updateMessagesWithAttached = (chatMessagesWithStatus, userId) => {
    chatMessagesWithStatus.sort(compareMessages);
    chatMessagesWithStatus.forEach((message, index, messages) => {
        if (message.messageType !== 'chat') {
            return;
        }
        /**
         * Attached === true means it is within a group of messages in the current order
         * Attached === top/bottom means it is on the top/bottom boundary
         * Attached === false means it is just a single message
         * A group of messages: continuous messages that belong to the same sender and not intercepted by other senders.
         */
        let attached = false;
        const previousMessage = index > 0 ? messages[index - 1] : undefined;
        const nextMessage = index === messages.length - 1 ? undefined : messages[index + 1];
        const previousSenderId = (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.messageType) === 'chat' ? previousMessage.senderId : undefined;
        const nextSenderId = (nextMessage === null || nextMessage === void 0 ? void 0 : nextMessage.messageType) === 'chat' ? nextMessage.senderId : undefined;
        if (previousSenderId !== message.senderId) {
            attached = message.senderId === nextSenderId ? 'top' : false;
        }
        else {
            attached = message.senderId === nextSenderId ? true : 'bottom';
        }
        message.attached = attached;
    });
};

// Copyright (c) Microsoft Corporation.
const memoizedAllConvertChatMessage = memoizeFnAll((_key, chatMessage, userId, isSeen, isLargeGroup) => {
    const messageType = chatMessage.type.toLowerCase();
    if (messageType === ACSKnownMessageType.text ||
        messageType === ACSKnownMessageType.richtextHtml ||
        messageType === ACSKnownMessageType.html) {
        return convertToUiChatMessage(chatMessage, userId, isSeen, isLargeGroup);
    }
    else {
        return convertToUiSystemMessage(chatMessage);
    }
});
const convertToUiChatMessage = (message, userId, isSeen, isLargeGroup) => {
    var _a;
    const messageSenderId = message.sender !== undefined ? toFlatCommunicationIdentifier(message.sender) : userId;
    return {
        messageType: 'chat',
        createdOn: message.createdOn,
        content: (_a = message.content) === null || _a === void 0 ? void 0 : _a.message,
        contentType: sanitizedMessageContentType(message.type),
        status: !isLargeGroup && message.status === 'delivered' && isSeen ? 'seen' : message.status,
        senderDisplayName: message.senderDisplayName,
        senderId: messageSenderId,
        messageId: message.id,
        clientMessageId: message.clientMessageId,
        editedOn: message.editedOn,
        deletedOn: message.deletedOn,
        mine: messageSenderId === userId
    };
};
const convertToUiSystemMessage = (message) => {
    var _a, _b, _c, _d, _e;
    const systemMessageType = message.type;
    if (systemMessageType === 'participantAdded' || systemMessageType === 'participantRemoved') {
        return {
            messageType: 'system',
            systemMessageType,
            createdOn: message.createdOn,
            participants: (_c = (_b = (_a = message.content) === null || _a === void 0 ? void 0 : _a.participants) === null || _b === void 0 ? void 0 : _b.filter((participant) => participant.displayName && participant.displayName !== '').map((participant) => ({
                userId: toFlatCommunicationIdentifier(participant.id),
                displayName: participant.displayName
            }))) !== null && _c !== void 0 ? _c : [],
            messageId: message.id,
            iconName: systemMessageType === 'participantAdded' ? 'PeopleAdd' : 'PeopleBlock'
        };
    }
    else {
        // Only topic updated type left, according to ACSKnown type
        return {
            messageType: 'system',
            systemMessageType: 'topicUpdated',
            createdOn: message.createdOn,
            topic: (_e = (_d = message.content) === null || _d === void 0 ? void 0 : _d.topic) !== null && _e !== void 0 ? _e : '',
            messageId: message.id,
            iconName: 'Edit'
        };
    }
};
/** Returns `true` if the message has participants and at least one participant has a display name. */
const hasValidParticipant = (chatMessage) => { var _a; return !!((_a = chatMessage.content) === null || _a === void 0 ? void 0 : _a.participants) && chatMessage.content.participants.some((p) => !!p.displayName); };
/**
 * Selector for {@link MessageThread} component.
 *
 * @public
 */
const messageThreadSelector = reselect.createSelector([getUserId, getChatMessages, getLatestReadTime, getIsLargeGroup], (userId, chatMessages, latestReadTime, isLargeGroup) => {
    // A function takes parameter above and generate return value
    const convertedMessages = memoizedAllConvertChatMessage((memoizedFn) => Object.values(chatMessages)
        .filter((message) => message.type.toLowerCase() === ACSKnownMessageType.text ||
        message.type.toLowerCase() === ACSKnownMessageType.richtextHtml ||
        message.type.toLowerCase() === ACSKnownMessageType.html ||
        (message.type === ACSKnownMessageType.participantAdded && hasValidParticipant(message)) ||
        (message.type === ACSKnownMessageType.participantRemoved && hasValidParticipant(message)) ||
        // TODO: Add support for topicUpdated system messages in MessageThread component.
        // message.type === ACSKnownMessageType.topicUpdated ||
        message.clientMessageId !== undefined)
        .filter((message) => message.content && message.content.message !== '') // TODO: deal with deleted message and remove
        .map((message) => {
        var _a;
        return memoizedFn((_a = message.id) !== null && _a !== void 0 ? _a : message.clientMessageId, message, userId, message.createdOn <= latestReadTime, isLargeGroup);
    }));
    updateMessagesWithAttached(convertedMessages);
    return {
        userId,
        showMessageStatus: !isLargeGroup,
        messages: convertedMessages
    };
});
const sanitizedMessageContentType = (type) => {
    const lowerCaseType = type.toLowerCase();
    return lowerCaseType === 'text' || lowerCaseType === 'html' || lowerCaseType === 'richtext/html'
        ? lowerCaseType
        : 'unknown';
};

// Copyright (c) Microsoft Corporation.
const filterTypingIndicators = (typingIndicators, userId) => {
    const filteredTypingIndicators = [];
    const seen = new Set();
    const date8SecondsAgo = new Date(Date.now() - MINIMUM_TYPING_INTERVAL_IN_MILLISECONDS);
    for (let i = typingIndicators.length - 1; i >= 0; i--) {
        const typingIndicator = typingIndicators[i];
        if (toFlatCommunicationIdentifier(typingIndicator.sender) === userId) {
            continue;
        }
        if (typingIndicator.receivedOn < date8SecondsAgo) {
            continue;
        }
        if (seen.has(toFlatCommunicationIdentifier(typingIndicator.sender))) {
            continue;
        }
        seen.add(toFlatCommunicationIdentifier(typingIndicator.sender));
        filteredTypingIndicators.push(typingIndicator);
    }
    return filteredTypingIndicators;
};
const convertSdkTypingIndicatorsToCommunicationParticipants = (typingIndicators, participants) => {
    return typingIndicators.map((typingIndicator) => {
        var _a;
        return ({
            userId: toFlatCommunicationIdentifier(typingIndicator.sender),
            displayName: (_a = participants[toFlatCommunicationIdentifier(typingIndicator.sender)]) === null || _a === void 0 ? void 0 : _a.displayName
        });
    });
};
/**
 * Selector for {@link TypingIndicator} component.
 *
 * @public
 */
const typingIndicatorSelector = reselect.createSelector([getTypingIndicators, getParticipants, getUserId], (typingIndicators, participants, userId) => {
    // if the participant size reaches the threshold then return no typing users
    if (Object.values(participants).length >= PARTICIPANTS_THRESHOLD) {
        return { typingUsers: [] };
    }
    // filter typing indicators to remove those that are from the duplicate users or current user as well as those older than a threshold
    const filteredTypingIndicators = filterTypingIndicators(typingIndicators, userId);
    const typingUsers = convertSdkTypingIndicatorsToCommunicationParticipants(filteredTypingIndicators, participants);
    return { typingUsers };
});

// Copyright (c) Microsoft Corporation.
const convertChatParticipantsToCommunicationParticipants = (chatParticipants) => {
    return chatParticipants.map((participant) => {
        return {
            userId: toFlatCommunicationIdentifier(participant.id),
            displayName: participant.displayName,
            // ACS users can not remove Teams users.
            // Removing phone numbers or unknown types of users is undefined.
            isRemovable: communicationCommon.getIdentifierKind(participant.id).kind == 'communicationUser'
        };
    });
};
/**
 * get the index of moderator to help updating its display name if they are the local user or removing them from list of participants otherwise
 */
const moderatorIndex = (participants) => {
    return participants.map((p) => p.displayName).indexOf(undefined);
};
/**
 * Selector for {@link ParticipantList} component.
 *
 * @public
 */
const chatParticipantListSelector = reselect__namespace.createSelector([getUserId, getParticipants, getDisplayName], (userId, chatParticipants, displayName) => {
    let participants = convertChatParticipantsToCommunicationParticipants(Object.values(chatParticipants));
    if (0 !== participants.length) {
        const moderatorIdx = moderatorIndex(participants);
        if (-1 !== moderatorIdx) {
            const userIndex = participants.map((p) => p.userId).indexOf(userId);
            if (moderatorIdx === userIndex) {
                participants[moderatorIdx].displayName = displayName;
            }
            else {
                participants = participants.filter((p) => p.displayName);
            }
        }
    }
    return {
        myUserId: userId,
        participants: participants
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * Select the first fiew active errors from the state for the {@link ErrorBar} component.
 *
 * In case there are many errors, only a few top errors are returned to avoid
 * filling up the UI with too many errors.
 *
 * Invariants:
 *   - {@link ErrorType} is never repeated in the returned errors.
 *   - Errors are returned in a fixed order by {@link ErrorType}.
 *
 * @public
 */
const errorBarSelector = reselect.createSelector([getLatestErrors], (latestErrors) => {
    var _a;
    // The order in which the errors are returned is significant: The `ErrorBar` shows errors on the UI in that order.
    // There are several options for the ordering:
    //   - Sorted by when the errors happened (latest first / oldest first).
    //   - Stable sort by error type.
    //
    // We chose to stable sort by error type: We intend to show only a small number of errors on the UI and we do not
    // have timestamps for errors.
    const activeErrorMessages = [];
    let specificSendMessageErrorSeen = false;
    {
        const error = latestUnableToReachChatServiceError(latestErrors);
        if (error !== undefined) {
            activeErrorMessages.push(error);
        }
    }
    {
        const error = latestAccessDeniedError(latestErrors);
        if (error !== undefined) {
            activeErrorMessages.push(error);
        }
    }
    const sendMessageError = latestErrors['ChatThreadClient.sendMessage'];
    {
        const error = latestNotInThisThreadError(latestErrors);
        if (error !== undefined) {
            if (sendMessageError !== undefined) {
                activeErrorMessages.push({
                    type: 'sendMessageNotInChatThread',
                    // Set the latest timestamp of all the errors that translated to an active error.
                    timestamp: sendMessageError.timestamp > ((_a = error.timestamp) !== null && _a !== void 0 ? _a : 0) ? sendMessageError.timestamp : error.timestamp
                });
                specificSendMessageErrorSeen = true;
            }
            else {
                activeErrorMessages.push(error);
            }
        }
    }
    if (!specificSendMessageErrorSeen && sendMessageError !== undefined) {
        activeErrorMessages.push({ type: 'sendMessageGeneric', timestamp: sendMessageError.timestamp });
    }
    // We only return the first few errors to avoid filling up the UI with too many `MessageBar`s.
    activeErrorMessages.splice(maxErrorCount);
    return { activeErrorMessages: activeErrorMessages };
});
const maxErrorCount = 3;
const accessErrorTargets = [
    'ChatThreadClient.getProperties',
    'ChatThreadClient.listMessages',
    'ChatThreadClient.listParticipants',
    'ChatThreadClient.sendMessage',
    'ChatThreadClient.sendTypingNotification'
];
const latestUnableToReachChatServiceError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'unableToReachChatService', (error) => {
        return !!error && !!error.innerError && error.innerError['code'] === 'REQUEST_SEND_ERROR';
    });
};
const latestAccessDeniedError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'accessDenied', (error) => {
        return !!error && !!error.innerError && error.innerError['statusCode'] === 401;
    });
};
const latestNotInThisThreadError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'userNotInChatThread', (error) => {
        if (!error || !error.innerError) {
            return false;
        }
        // Chat service returns 403 if a user has been removed from a thread.
        // Chat service returns either 400 or 404 if the thread ID is malformed, depending on how the thread ID is malformed.
        return [400, 403, 404].some((statusCode) => error.innerError['statusCode'] === statusCode);
    });
};
const latestActiveErrorSatisfying = (errors, activeErrorType, predicate) => {
    const activeErrorMessages = [];
    for (const target of accessErrorTargets) {
        const error = errors[target];
        if (predicate(error)) {
            activeErrorMessages.push({ type: activeErrorType, timestamp: error.timestamp });
        }
    }
    if (activeErrorMessages.length === 0) {
        return undefined;
    }
    // We're actually sure that both timestamps will always exist, because we set them above.
    activeErrorMessages.sort((a, b) => { var _a, _b, _c, _d; return ((_b = (_a = a.timestamp) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) - ((_d = (_c = b.timestamp) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0); });
    return activeErrorMessages[activeErrorMessages.length - 1];
};

// Copyright (c) Microsoft Corporation.
/**
 * Get the selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const getSelector = (component) => {
    return findSelector(component);
};
const findSelector = (component) => {
    switch (component) {
        case SendBox:
            return sendBoxSelector;
        case MessageThread:
            return messageThreadSelector;
        case TypingIndicator:
            return typingIndicatorSelector;
        case ParticipantList:
            return chatParticipantListSelector;
        case ErrorBar:
            return errorBarSelector;
    }
    return undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$f = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * ProxyDeviceManager proxies DeviceManager and subscribes to all events that affect device manager state. State updates
 * are set on the provided context. Also any queries for state are proxied and stored in state as well. Only one device
 * manager should exist for a given CallClient so if CallClient.getDeviceManager is called multiple times, either a
 * cached ProxyDeviceManager should be returned or the existing ProxyDeviceManager should be destructed via destructor()
 * and a new ProxyDeviceManager created.
 */
class ProxyDeviceManager {
    constructor(deviceManager, context) {
        this.setDeviceManager = () => {
            // isSpeakerSelectionAvailable, selectedMicrophone, and selectedSpeaker are properties on DeviceManager. Since they
            // are not functions we can't proxy them so we'll update whenever we think they may need updating such as at
            // construction time or when certain events happen.
            this._context.setDeviceManagerIsSpeakerSelectionAvailable(this._deviceManager.isSpeakerSelectionAvailable);
            this._context.setDeviceManagerSelectedMicrophone(this._deviceManager.selectedMicrophone);
            this._context.setDeviceManagerSelectedSpeaker(this._deviceManager.selectedSpeaker);
        };
        this.subscribe = () => {
            this._deviceManager.on('videoDevicesUpdated', this.videoDevicesUpdated);
            this._deviceManager.on('audioDevicesUpdated', this.audioDevicesUpdated);
            this._deviceManager.on('selectedMicrophoneChanged', this.selectedMicrophoneChanged);
            this._deviceManager.on('selectedSpeakerChanged', this.selectedSpeakerChanged);
        };
        /**
         * This is used to unsubscribe DeclarativeDeviceManager from the DeviceManager events.
         */
        this.unsubscribe = () => {
            this._deviceManager.off('videoDevicesUpdated', this.videoDevicesUpdated);
            this._deviceManager.off('audioDevicesUpdated', this.audioDevicesUpdated);
            this._deviceManager.off('selectedMicrophoneChanged', this.selectedMicrophoneChanged);
            this._deviceManager.off('selectedSpeakerChanged', this.selectedSpeakerChanged);
        };
        /**
         * Used to set a camera inside the proxy device manager.
         *
         * @param videoDeviceInfo VideoDeviceInfo
         */
        this.selectCamera = (videoDeviceInfo) => {
            this._context.setDeviceManagerSelectedCamera(videoDeviceInfo);
        };
        this.videoDevicesUpdated = () => __awaiter$f(this, void 0, void 0, function* () {
            this._context.setDeviceManagerCameras(dedupeById(yield this._deviceManager.getCameras()));
        });
        this.audioDevicesUpdated = () => __awaiter$f(this, void 0, void 0, function* () {
            this._context.setDeviceManagerMicrophones(dedupeById(yield this._deviceManager.getMicrophones()));
            this._context.setDeviceManagerSpeakers(dedupeById(yield this._deviceManager.getSpeakers()));
        });
        this.selectedMicrophoneChanged = () => {
            this._context.setDeviceManagerSelectedMicrophone(this._deviceManager.selectedMicrophone);
        };
        this.selectedSpeakerChanged = () => {
            this._context.setDeviceManagerSelectedSpeaker(this._deviceManager.selectedSpeaker);
        };
        this._deviceManager = deviceManager;
        this._context = context;
        this.setDeviceManager();
        this.subscribe();
    }
    get(target, prop) {
        switch (prop) {
            case 'getCameras': {
                return this._context.withAsyncErrorTeedToState(() => {
                    return target.getCameras().then((cameras) => {
                        this._context.setDeviceManagerCameras(dedupeById(cameras));
                        return cameras;
                    });
                }, 'DeviceManager.getCameras');
            }
            case 'getMicrophones': {
                return this._context.withAsyncErrorTeedToState(() => {
                    return target.getMicrophones().then((microphones) => {
                        this._context.setDeviceManagerMicrophones(dedupeById(microphones));
                        return microphones;
                    });
                }, 'DeviceManager.getMicrophones');
            }
            case 'getSpeakers': {
                return this._context.withAsyncErrorTeedToState(() => {
                    return target.getSpeakers().then((speakers) => {
                        this._context.setDeviceManagerSpeakers(dedupeById(speakers));
                        return speakers;
                    });
                }, 'DeviceManager.getSpeakers');
            }
            case 'selectMicrophone': {
                return this._context.withAsyncErrorTeedToState((...args) => {
                    return target.selectMicrophone(...args).then(() => {
                        this._context.setDeviceManagerSelectedMicrophone(target.selectedMicrophone);
                    });
                }, 'DeviceManager.selectMicrophone');
            }
            case 'selectSpeaker': {
                return this._context.withAsyncErrorTeedToState((...args) => {
                    return target.selectSpeaker(...args).then(() => {
                        this._context.setDeviceManagerSelectedSpeaker(target.selectedSpeaker);
                    });
                }, 'DeviceManager.selectSpeaker');
            }
            case 'askDevicePermission': {
                return this._context.withAsyncErrorTeedToState((...args) => {
                    return target.askDevicePermission(...args).then((deviceAccess) => {
                        this._context.setDeviceManagerDeviceAccess(deviceAccess);
                        this.setDeviceManager();
                        return deviceAccess;
                    });
                }, 'DeviceManager.askDevicePermission');
            }
            default:
                return Reflect.get(target, prop);
        }
    }
}
// TODO: Remove this when SDK no longer returns duplicate audio and video devices
/** Helper function to dedupe duplicate audio and video devices obtained from SDK */
const dedupeById = (devices) => {
    const ids = new Set();
    const uniqueDevices = [];
    devices.forEach((device) => {
        if (!ids.has(device.id)) {
            uniqueDevices.push(device);
            ids.add(device.id);
        }
    });
    return uniqueDevices;
};
/**
 * Creates a declarative DeviceManager by proxying DeviceManager with ProxyDeviceManager. The declarative DeviceManager
 * will put state updates in the given context.
 *
 * @param deviceManager - DeviceManager from SDK
 * @param context - CallContext from StatefulCallClient
 */
const deviceManagerDeclaratify = (deviceManager, context) => {
    const proxyDeviceManager = new ProxyDeviceManager(deviceManager, context);
    Object.defineProperty(deviceManager, 'unsubscribe', {
        configurable: false,
        value: () => proxyDeviceManager.unsubscribe()
    });
    Object.defineProperty(deviceManager, 'selectCamera', {
        configurable: false,
        value: (videoDeviceInfo) => proxyDeviceManager.selectCamera(videoDeviceInfo)
    });
    return new Proxy(deviceManager, proxyDeviceManager);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Error thrown from failed stateful API methods.
 *
 * @public
 */
class CallError extends Error {
    constructor(target, innerError, timestamp) {
        super();
        this.target = target;
        this.innerError = innerError;
        // Testing note: It is easier to mock Date::now() than the Date() constructor.
        this.timestamp = timestamp !== null && timestamp !== void 0 ? timestamp : new Date(Date.now());
        this.name = 'CallError';
        this.message = `${this.target}: ${this.innerError.message}`;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$e = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
produce.enableMapSet();
// TODO: How can we make this configurable?
/**
 * @private
 */
const MAX_CALL_HISTORY_LENGTH = 10;
/**
 * @private
 */
class CallContext$1 {
    constructor(userId, maxListeners = 50) {
        this._state = {
            calls: {},
            callsEnded: {},
            incomingCalls: {},
            incomingCallsEnded: {},
            deviceManager: {
                isSpeakerSelectionAvailable: false,
                cameras: [],
                microphones: [],
                speakers: [],
                unparentedViews: []
            },
            callAgent: undefined,
            userId: userId,
            latestErrors: {}
        };
        this._emitter = new EventEmitter__default['default']();
        this._emitter.setMaxListeners(maxListeners);
        this._batchMode = false;
        this._atomicId = 0;
    }
    getState() {
        return this._state;
    }
    setState(state) {
        this._state = state;
        if (!this._batchMode) {
            this._emitter.emit('stateChanged', this._state);
        }
    }
    modifyState(modifier) {
        this.batch(() => {
            this.setState(produce.produce(this._state, (draft) => {
                modifier(draft);
            }));
        });
    }
    /**
     * Batch updates to minimize `stateChanged` events across related operations.
     *
     * - A maximum of one `stateChanged` event is emitted, at the end of the operations.
     * - No `stateChanged` event is emitted if the state did not change through the operations.
     * - In case of an exception, state is reset to the prior value and no `stateChanged` event is emitted.
     *
     * All operations finished in this batch should be synchronous.
     * This function is not reentrant -- do not call batch() from within another batch().
     */
    batch(operations) {
        if (this._batchMode) {
            throw new Error('batch() called from within another batch()');
        }
        this._batchMode = true;
        const priorState = this._state;
        try {
            operations();
            if (this._state !== priorState) {
                this._emitter.emit('stateChanged', this._state);
            }
        }
        catch (e) {
            this._state = priorState;
            throw e;
        }
        finally {
            this._batchMode = false;
        }
    }
    onStateChange(handler) {
        this._emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this._emitter.off('stateChanged', handler);
    }
    // Disposing of the CallAgentDeclarative will not clear the state. If we create a new CallAgentDeclarative, we should
    // make sure the state is clean because any left over state (if previous CallAgentDeclarative was disposed) may be
    // invalid.
    clearCallRelatedState() {
        this.setState(produce.produce(this._state, (draft) => {
            draft.calls = {};
            draft.incomingCalls = {};
            draft.callsEnded = {};
            draft.incomingCallsEnded = {};
        }));
    }
    setCallAgent(callAgent) {
        this.setState(produce.produce(this._state, (draft) => {
            draft.callAgent = callAgent;
        }));
    }
    setCall(call) {
        this.setState(produce.produce(this._state, (draft) => {
            const existingCall = draft.calls[call.id];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
                existingCall.state = call.state;
                existingCall.callEndReason = call.callEndReason;
                existingCall.direction = call.direction;
                existingCall.isMuted = call.isMuted;
                existingCall.isScreenSharingOn = call.isScreenSharingOn;
                existingCall.localVideoStreams = call.localVideoStreams;
                existingCall.remoteParticipants = call.remoteParticipants;
                existingCall.transcription.isTranscriptionActive = call.transcription.isTranscriptionActive;
                existingCall.recording.isRecordingActive = call.recording.isRecordingActive;
                // We don't update the startTime and endTime if we are updating an existing active call
            }
            else {
                draft.calls[call.id] = call;
            }
        }));
    }
    removeCall(callId) {
        this.setState(produce.produce(this._state, (draft) => {
            delete draft.calls[callId];
        }));
    }
    setCallEnded(callId, callEndReason) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.calls[callId];
                // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.callsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.callsEnded[findOldestCallEnded(draft.callsEnded)];
                }
                draft.callsEnded[callId] = call;
            }
        }));
    }
    setCallState(callId, state) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                call.state = state;
            }
        }));
    }
    setCallId(newCallId, oldCallId) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[oldCallId];
            if (call) {
                delete draft.calls[oldCallId];
                draft.calls[newCallId] = call;
            }
        }));
    }
    setCallIsScreenSharingOn(callId, isScreenSharingOn) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                call.isScreenSharingOn = isScreenSharingOn;
            }
        }));
    }
    setCallRemoteParticipants(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipants[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipants[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
            }
        }));
    }
    setCallRemoteParticipantsEnded(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipantsEnded[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipantsEnded[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
            }
        }));
    }
    setCallLocalVideoStream(callId, streams) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                call.localVideoStreams = streams;
            }
        }));
    }
    setCallIsMicrophoneMuted(callId, isMicrophoneMuted) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                call.isMuted = isMicrophoneMuted;
            }
        }));
    }
    setCallDominantSpeakers(callId, dominantSpeakers) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                call.dominantSpeakers = dominantSpeakers;
            }
        }));
    }
    setCallRecordingActive(callId, isRecordingActive) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                call.recording.isRecordingActive = isRecordingActive;
            }
        }));
    }
    setCallTranscriptionActive(callId, isTranscriptionActive) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                call.transcription.isTranscriptionActive = isTranscriptionActive;
            }
        }));
    }
    setCallScreenShareParticipant(callId, participantKey) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                call.screenShareRemoteParticipant = participantKey;
            }
        }));
    }
    setLocalVideoStreamRendererView(callId, view) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                if (call.localVideoStreams.length > 0) {
                    call.localVideoStreams[0].view = view;
                }
            }
        }));
    }
    setParticipantState(callId, participantKey, state) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.state = state;
                }
            }
        }));
    }
    setParticipantIsMuted(callId, participantKey, muted) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isMuted = muted;
                }
            }
        }));
    }
    setParticipantDisplayName(callId, participantKey, displayName) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.displayName = displayName;
                }
            }
        }));
    }
    setParticipantIsSpeaking(callId, participantKey, isSpeaking) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isSpeaking = isSpeaking;
                }
            }
        }));
    }
    setParticipantVideoStream(callId, participantKey, stream) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    // Set is called by subscriber will not modify any rendered stream so if there is existing stream only
                    // modify the values that subscriber has access to.
                    const existingStream = participant.videoStreams[stream.id];
                    if (existingStream) {
                        existingStream.isAvailable = stream.isAvailable;
                        existingStream.mediaStreamType = stream.mediaStreamType;
                    }
                    else {
                        participant.videoStreams[stream.id] = stream;
                    }
                }
            }
        }));
    }
    setRemoteVideoStreamIsAvailable(callId, participantKey, streamId, isAvailable) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.isAvailable = isAvailable;
                    }
                }
            }
        }));
    }
    setRemoteVideoStreams(callId, participantKey, addRemoteVideoStream, removeRemoteVideoStream) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    for (const id of removeRemoteVideoStream) {
                        delete participant.videoStreams[id];
                    }
                    for (const newStream of addRemoteVideoStream) {
                        // This should only be called by the subscriber and some properties are add by other components so if the
                        // stream already exists, only update the values that subscriber knows about.
                        const stream = participant.videoStreams[newStream.id];
                        if (stream) {
                            stream.mediaStreamType = newStream.mediaStreamType;
                            stream.isAvailable = newStream.isAvailable;
                        }
                        else {
                            participant.videoStreams[newStream.id] = newStream;
                        }
                    }
                }
            }
        }));
    }
    setRemoteVideoStreamRendererView(callId, participantKey, streamId, view) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.calls[callId];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.view = view;
                    }
                }
            }
        }));
    }
    setIncomingCall(call) {
        this.setState(produce.produce(this._state, (draft) => {
            const existingCall = draft.incomingCalls[call.id];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
            }
            else {
                draft.incomingCalls[call.id] = call;
            }
        }));
    }
    removeIncomingCall(callId) {
        this.setState(produce.produce(this._state, (draft) => {
            delete draft.incomingCalls[callId];
        }));
    }
    setIncomingCallEnded(callId, callEndReason) {
        this.setState(produce.produce(this._state, (draft) => {
            const call = draft.incomingCalls[callId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.incomingCalls[callId];
                // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.incomingCallsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.incomingCallsEnded[findOldestCallEnded(draft.incomingCallsEnded)];
                }
                draft.incomingCallsEnded[callId] = call;
            }
        }));
    }
    setDeviceManagerIsSpeakerSelectionAvailable(isSpeakerSelectionAvailable) {
        this.setState(produce.produce(this._state, (draft) => {
            draft.deviceManager.isSpeakerSelectionAvailable = isSpeakerSelectionAvailable;
        }));
    }
    setDeviceManagerSelectedMicrophone(selectedMicrophone) {
        this.setState(produce.produce(this._state, (draft) => {
            draft.deviceManager.selectedMicrophone = selectedMicrophone;
        }));
    }
    setDeviceManagerSelectedSpeaker(selectedSpeaker) {
        this.setState(produce.produce(this._state, (draft) => {
            draft.deviceManager.selectedSpeaker = selectedSpeaker;
        }));
    }
    setDeviceManagerSelectedCamera(selectedCamera) {
        this.setState(produce.produce(this._state, (draft) => {
            draft.deviceManager.selectedCamera = selectedCamera;
        }));
    }
    setDeviceManagerCameras(cameras) {
        this.setState(produce.produce(this._state, (draft) => {
            /**
             * SDK initializes cameras with one dummy camera with value { id: 'camera:id', name: '', deviceType: 'USBCamera' } immediately after
             * camera permissions are granted. So selectedCamera will have this value before the actual cameras are obtained. Therefore we should reset
             * selectedCamera to the first camera when there are cameras AND when current selectedCamera does not exist in the new array of cameras *
             */
            if (cameras.length > 0 && !cameras.some((camera) => { var _a; return camera.id === ((_a = draft.deviceManager.selectedCamera) === null || _a === void 0 ? void 0 : _a.id); })) {
                draft.deviceManager.selectedCamera = cameras[0];
            }
            draft.deviceManager.cameras = cameras;
        }));
    }
    setDeviceManagerMicrophones(microphones) {
        this.setState(produce.produce(this._state, (draft) => {
            draft.deviceManager.microphones = microphones;
        }));
    }
    setDeviceManagerSpeakers(speakers) {
        this.setState(produce.produce(this._state, (draft) => {
            draft.deviceManager.speakers = speakers;
        }));
    }
    setDeviceManagerDeviceAccess(deviceAccess) {
        this.setState(produce.produce(this._state, (draft) => {
            draft.deviceManager.deviceAccess = deviceAccess;
        }));
    }
    setDeviceManagerUnparentedView(localVideoStream, view) {
        this.setState(produce.produce(this._state, (draft) => {
            draft.deviceManager.unparentedViews.push({
                source: localVideoStream.source,
                mediaStreamType: localVideoStream.mediaStreamType,
                view: view
            });
        }));
    }
    deleteDeviceManagerUnparentedView(localVideoStream) {
        this.setState(produce.produce(this._state, (draft) => {
            const foundIndex = draft.deviceManager.unparentedViews.findIndex((stream) => stream.source.id === localVideoStream.source.id &&
                stream.mediaStreamType === localVideoStream.mediaStreamType);
            if (foundIndex !== -1) {
                draft.deviceManager.unparentedViews.splice(foundIndex, 1);
            }
        }));
    }
    getAndIncrementAtomicId() {
        const id = this._atomicId;
        this._atomicId++;
        return id;
    }
    /**
     * Tees any errors encountered in an async function to the state.
     *
     * @param action Async function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withAsyncErrorTeedToState(action, target) {
        return (...args) => __awaiter$e(this, void 0, void 0, function* () {
            try {
                return yield action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        });
    }
    /**
     * Tees any errors encountered in an function to the state.
     *
     * @param action Function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withErrorTeedToState(action, target) {
        return (...args) => {
            try {
                return action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        };
    }
    setLatestError(target, error) {
        this.setState(produce.produce(this._state, (draft) => {
            draft.latestErrors[target] = error;
        }));
    }
}
const toCallError = (target, error) => {
    if (error instanceof Error) {
        return new CallError(target, error);
    }
    return new CallError(target, new Error(error));
};
const findOldestCallEnded = (calls) => {
    var _a, _b, _c, _d;
    const callEntries = Object.entries(calls);
    let [oldestCallId, oldestCall] = callEntries[0];
    if (oldestCall.endTime === undefined) {
        return oldestCallId;
    }
    for (const [callId, call] of callEntries.slice(1)) {
        if (call.endTime === undefined) {
            return callId;
        }
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) < ((_d = (_c = oldestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            [oldestCallId, oldestCall] = [callId, call];
        }
    }
    return oldestCallId;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$d = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProxyCall {
    constructor(context) {
        this._context = context;
    }
    unsubscribe() {
        /** No subscriptions yet. But there will be one for transfer feature soon. */
    }
    get(target, prop) {
        switch (prop) {
            case 'mute': {
                return this._context.withAsyncErrorTeedToState(function (...args) {
                    return __awaiter$d(this, void 0, void 0, function* () {
                        return yield target.mute(...args);
                    });
                }, 'Call.mute');
            }
            case 'unmute': {
                return this._context.withAsyncErrorTeedToState(function (...args) {
                    return __awaiter$d(this, void 0, void 0, function* () {
                        return yield target.unmute(...args);
                    });
                }, 'Call.unmute');
            }
            case 'startVideo': {
                return this._context.withAsyncErrorTeedToState(function (...args) {
                    return __awaiter$d(this, void 0, void 0, function* () {
                        return yield target.startVideo(...args);
                    });
                }, 'Call.startVideo');
            }
            case 'stopVideo': {
                return this._context.withAsyncErrorTeedToState(function (...args) {
                    return __awaiter$d(this, void 0, void 0, function* () {
                        return yield target.stopVideo(...args);
                    });
                }, 'Call.stopVideo');
            }
            case 'startScreenSharing': {
                return this._context.withAsyncErrorTeedToState(function (...args) {
                    return __awaiter$d(this, void 0, void 0, function* () {
                        return yield target.startScreenSharing(...args);
                    });
                }, 'Call.startScreenSharing');
            }
            case 'stopScreenSharing': {
                return this._context.withAsyncErrorTeedToState(function (...args) {
                    return __awaiter$d(this, void 0, void 0, function* () {
                        return yield target.stopScreenSharing(...args);
                    });
                }, 'Call.stopScreenSharing');
            }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a declarative Call by proxying Call with ProxyCall.
 * This should only be used with CallAgentDeclarative as CallAgentDeclarative will add that
 * call to the context properly (need to have the Call in context to update it - CallAgentDeclarative will add Call to
 * context)
 *
 * @param call - Call from SDK
 * @param context - CallContext from StatefulCallClient
 */
const callDeclaratify = (call, context) => {
    const proxyCall = new ProxyCall(context);
    Object.defineProperty(call, 'unsubscribe', {
        configurable: false,
        value: () => proxyCall.unsubscribe()
    });
    return new Proxy(call, proxyCall);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
function convertSdkLocalStreamToDeclarativeLocalStream(stream) {
    return {
        source: stream.source,
        mediaStreamType: stream.mediaStreamType,
        view: undefined
    };
}
/**
 * @private
 */
function convertSdkRemoteStreamToDeclarativeRemoteStream(stream) {
    return {
        id: stream.id,
        mediaStreamType: stream.mediaStreamType,
        isAvailable: stream.isAvailable,
        view: undefined
    };
}
/**
 * @private
 */
function convertSdkParticipantToDeclarativeParticipant(participant) {
    const declarativeVideoStreams = {};
    for (const videoStream of participant.videoStreams) {
        declarativeVideoStreams[videoStream.id] = convertSdkRemoteStreamToDeclarativeRemoteStream(videoStream);
    }
    return {
        identifier: participant.identifier,
        displayName: participant.displayName,
        state: participant.state,
        callEndReason: participant.callEndReason,
        videoStreams: declarativeVideoStreams,
        isMuted: participant.isMuted,
        isSpeaking: participant.isSpeaking
    };
}
/**
 * @private
 *
 * Note at the time of writing only one LocalVideoStream is supported by the SDK.
 */
function convertSdkCallToDeclarativeCall(call) {
    const declarativeRemoteParticipants = {};
    call.remoteParticipants.forEach((participant) => {
        declarativeRemoteParticipants[toFlatCommunicationIdentifier(participant.identifier)] =
            convertSdkParticipantToDeclarativeParticipant(participant);
    });
    return {
        id: call.id,
        callerInfo: call.callerInfo,
        state: call.state,
        callEndReason: call.callEndReason,
        diagnostics: {
            network: {
                latest: {}
            },
            media: {
                latest: {}
            }
        },
        direction: call.direction,
        isMuted: call.isMuted,
        isScreenSharingOn: call.isScreenSharingOn,
        localVideoStreams: call.localVideoStreams.map(convertSdkLocalStreamToDeclarativeLocalStream),
        remoteParticipants: declarativeRemoteParticipants,
        remoteParticipantsEnded: {},
        recording: { isRecordingActive: false },
        transcription: { isTranscriptionActive: false },
        screenShareRemoteParticipant: undefined,
        startTime: new Date(),
        endTime: undefined
    };
}
/**
 * @private
 */
function convertSdkIncomingCallToDeclarativeIncomingCall(call) {
    return {
        id: call.id,
        callerInfo: call.callerInfo,
        startTime: new Date(),
        endTime: undefined
    };
}
/**
 * @private
 */
function convertFromSDKToDeclarativeVideoStreamRendererView(view) {
    return {
        scalingMode: view.scalingMode,
        isMirrored: view.isMirrored,
        target: view.target
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
class RemoteVideoStreamSubscriber {
    constructor(callIdRef, participantKey, remoteVideoStream, context) {
        this.subscribe = () => {
            this._remoteVideoStream.on('isAvailableChanged', this.isAvailableChanged);
            this.checkAndUpdateScreenShareState();
        };
        this.unsubscribe = () => {
            this._remoteVideoStream.off('isAvailableChanged', this.isAvailableChanged);
        };
        this.includesActiveScreenShareStream = (streams) => {
            for (const stream of Object.values(streams)) {
                if (stream.mediaStreamType === 'ScreenSharing' && stream.isAvailable) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Update the state with the active screen share stream. If there is an existing stream will overwrite it if this one
         * is active (newer stream takes priority). If there is an existing stream and this one is set to unavailable, and the
         * existing stream is different participant, then don't set the active screen share stream to undefined, else set it
         * to undefined.
         */
        this.checkAndUpdateScreenShareState = () => {
            var _a, _b, _c;
            if (this._remoteVideoStream.mediaStreamType !== 'ScreenSharing') {
                return;
            }
            if (this._remoteVideoStream.isAvailable) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, this._participantKey);
                return;
            }
            const existingScreenShare = (_a = this._context.getState().calls[this._callIdRef.callId]) === null || _a === void 0 ? void 0 : _a.screenShareRemoteParticipant;
            // If somehow we end up with an event where a RemoteParticipant's ScreenShare stream is set to
            // unavailable but there exists already another different participant actively sharing, and they are still
            // sharing then this event shouldn't set the screenShareRemoteParticipant to undefined.
            if (!existingScreenShare || existingScreenShare === this._participantKey) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            }
            const streams = (_c = (_b = this._context.getState().calls[this._callIdRef.callId]) === null || _b === void 0 ? void 0 : _b.remoteParticipants[existingScreenShare]) === null || _c === void 0 ? void 0 : _c.videoStreams;
            if (!streams) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            }
            // If the existing ScreenShare that is not owned by the current RemoteParticipant is still active, don't
            // overwrite it with undefined. So only overwrite if it is not active.
            if (!this.includesActiveScreenShareStream(streams)) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            }
        };
        this.isAvailableChanged = () => {
            this._context.setRemoteVideoStreamIsAvailable(this._callIdRef.callId, this._participantKey, this._remoteVideoStream.id, this._remoteVideoStream.isAvailable);
            this.checkAndUpdateScreenShareState();
        };
        this._callIdRef = callIdRef;
        this._participantKey = participantKey;
        this._remoteVideoStream = remoteVideoStream;
        this._context = context;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$c = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function createViewRemoteVideo(context, internalContext, callId, participantId, stream, options) {
    return __awaiter$c(this, void 0, void 0, function* () {
        // Render RemoteVideoStream that is part of a Call
        const streamId = stream.id;
        let participantKey;
        if (typeof participantId === 'string') {
            participantKey = participantId;
        }
        else {
            participantKey = toFlatCommunicationIdentifier(participantId);
        }
        const renderInfo = internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId);
        if (!renderInfo) {
            console.warn('RemoteVideoStream not found in state');
            return;
        }
        if (renderInfo.status === 'Rendered') {
            console.warn('RemoteVideoStream is already rendered');
            return;
        }
        if (renderInfo.status === 'Rendering') {
            // Do not log to console here as this is a very common situation due to UI rerenders while
            // the video rendering is in progress.
            return;
        }
        if (renderInfo.status === 'Stopping') {
            console.warn('RemoteVideoStream is in the middle of stopping');
            return;
        }
        const renderer = new communicationCalling.VideoStreamRenderer(renderInfo.stream);
        internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'Rendering', undefined);
        let view;
        try {
            view = yield renderer.createView(options);
        }
        catch (e) {
            internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'NotRendered', undefined);
            throw e;
        }
        const refreshedRenderInfo = internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId);
        if (!refreshedRenderInfo) {
            // RenderInfo was removed. This should not happen unless stream was removed from the call so dispose the renderer
            // and clean up state.
            renderer.dispose();
            context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined);
            return;
        }
        if (refreshedRenderInfo.status === 'Stopping') {
            // Stop render was called on this stream after we had started rendering. We will dispose this view and do not
            // put the view into the state.
            renderer.dispose();
            internalContext.setRemoteRenderInfo(callId, participantKey, streamId, refreshedRenderInfo.stream, 'NotRendered', undefined);
            context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined);
            return;
        }
        // Else the stream still exists and status is not telling us to stop rendering. Complete the render process by
        // updating the state.
        internalContext.setRemoteRenderInfo(callId, participantKey, streamId, refreshedRenderInfo.stream, 'Rendered', renderer);
        context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, convertFromSDKToDeclarativeVideoStreamRendererView(view));
    });
}
function createViewLocalVideo(context, internalContext, callId, options) {
    return __awaiter$c(this, void 0, void 0, function* () {
        // Render LocalVideoStream that is part of a Call
        const renderInfo = internalContext.getLocalRenderInfo(callId);
        if (!renderInfo) {
            console.warn('LocalVideoStream not found in state');
            return;
        }
        if (renderInfo.status === 'Rendered') {
            console.warn('LocalVideoStream is already rendered');
            return;
        }
        if (renderInfo.status === 'Rendering') {
            // Do not log to console here as this is a very common situation due to UI rerenders while
            // the video rendering is in progress.
            return;
        }
        if (renderInfo.status === 'Stopping') {
            console.warn('LocalVideoStream is in the middle of stopping');
            return;
        }
        const renderer = new communicationCalling.VideoStreamRenderer(renderInfo.stream);
        internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'Rendering', renderer);
        let view;
        try {
            view = yield renderer.createView(options);
        }
        catch (e) {
            internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'NotRendered', undefined);
            throw e;
        }
        // Since render could take some time, we need to check if the stream is still valid and if we received a signal to
        // stop rendering.
        const refreshedRenderInfo = internalContext.getLocalRenderInfo(callId);
        if (!refreshedRenderInfo) {
            // RenderInfo was removed. This should not happen unless stream was removed from the call so dispose the renderer
            // and clean up the state.
            renderer.dispose();
            context.setLocalVideoStreamRendererView(callId, undefined);
            return;
        }
        if (refreshedRenderInfo.status === 'Stopping') {
            // Stop render was called on this stream after we had started rendering. We will dispose this view and do not
            // put the view into the state.
            renderer.dispose();
            internalContext.setLocalRenderInfo(callId, refreshedRenderInfo.stream, 'NotRendered', undefined);
            context.setLocalVideoStreamRendererView(callId, undefined);
            return;
        }
        // Else The stream still exists and status is not telling us to stop rendering. Complete the render process by
        // updating the state.
        internalContext.setLocalRenderInfo(callId, refreshedRenderInfo.stream, 'Rendered', renderer);
        context.setLocalVideoStreamRendererView(callId, convertFromSDKToDeclarativeVideoStreamRendererView(view));
    });
}
function createViewUnparentedVideo(context, internalContext, stream, options) {
    return __awaiter$c(this, void 0, void 0, function* () {
        const renderInfo = internalContext.getUnparentedRenderInfo(stream);
        if (renderInfo && renderInfo.status === 'Rendered') {
            console.warn('Unparented LocalVideoStream is already rendered');
            return;
        }
        if (renderInfo && renderInfo.status === 'Rendering') {
            // Do not log to console here as this is a very common situation due to UI rerenders while
            // the video rendering is in progress.
            return;
        }
        if (renderInfo && renderInfo.status === 'Stopping') {
            console.warn('Unparented LocalVideoStream is in the middle of stopping');
            return;
        }
        const localVideoStream = new communicationCalling.LocalVideoStream(stream.source);
        const renderer = new communicationCalling.VideoStreamRenderer(localVideoStream);
        internalContext.setUnparentedRenderInfo(stream, localVideoStream, 'Rendering', undefined);
        let view;
        try {
            view = yield renderer.createView(options);
        }
        catch (e) {
            // Special case for unparented views. Since they are not tied to anything and created by us based on the calls to
            // this function we'll delete it to clean up the data since keeping it around doesn't help us and if developer wants
            // to create a new view they can check that the view is not rendered and call this function again.
            internalContext.deleteUnparentedRenderInfo(stream);
            throw e;
        }
        // Since render could take some time, we need to check if the stream is still valid and if we received a signal to
        // stop rendering.
        const refreshedRenderInfo = internalContext.getUnparentedRenderInfo(stream);
        if (!refreshedRenderInfo) {
            // Unparented stream's RenderInfo was deleted. Currently this shouldn't happen but if it does we'll just dispose the
            // renderer and clean up state. If developer wanted the stream they could call this function again and that should
            // generate new working state via this function.
            renderer.dispose();
            context.deleteDeviceManagerUnparentedView(stream);
            return;
        }
        if (refreshedRenderInfo.status === 'Stopping') {
            // Stop render was called on this stream after we had started rendering. We will dispose this view and do not
            // put the view into the state. Special case for unparented views, delete them from state when stopped to free up
            // the memory since we were the ones generating this and not tied to any Call state.
            internalContext.deleteUnparentedRenderInfo(stream);
            context.deleteDeviceManagerUnparentedView(stream);
            return;
        }
        // Else the stream still exists and status is not telling us to stop rendering. Complete the render process by
        // updating the state.
        internalContext.setUnparentedRenderInfo(stream, localVideoStream, 'Rendered', renderer);
        context.setDeviceManagerUnparentedView(stream, convertFromSDKToDeclarativeVideoStreamRendererView(view));
    });
}
function disposeViewRemoteVideo(context, internalContext, callId, participantId, stream) {
    const streamId = stream.id;
    let participantKey;
    if (typeof participantId === 'string') {
        participantKey = participantId;
    }
    else {
        participantKey = toFlatCommunicationIdentifier(participantId);
    }
    context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined);
    const renderInfo = internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId);
    if (!renderInfo) {
        return;
    }
    // Sets the status and also renderer. I think we need to always set renderer to undefined since in all status when
    // cleaned up should have renderer as undefined. If the status is 'Rendered' and renderer is not defined it should
    // be cleaned up below so we can set it to undefined here.
    if (renderInfo.status === 'Rendering') {
        internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'Stopping', undefined);
    }
    else {
        internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'NotRendered', undefined);
    }
    if (renderInfo.renderer) {
        renderInfo.renderer.dispose();
    }
}
function disposeViewLocalVideo(context, internalContext, callId) {
    context.setLocalVideoStreamRendererView(callId, undefined);
    const renderInfo = internalContext.getLocalRenderInfo(callId);
    if (!renderInfo) {
        return;
    }
    // Sets the status and also renderer. I think we need to always set renderer to undefined since in all status when
    // cleaned up should have renderer as undefined. If the status is 'Rendered' and renderer is not defined it should
    // be cleaned up below so we can set it to undefined here.
    if (renderInfo.status === 'Rendering') {
        internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'Stopping', undefined);
    }
    else {
        internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'NotRendered', undefined);
    }
    if (renderInfo.renderer) {
        renderInfo.renderer.dispose();
    }
}
function disposeViewUnparentedVideo(context, internalContext, stream) {
    context.deleteDeviceManagerUnparentedView(stream);
    const renderInfo = internalContext.getUnparentedRenderInfo(stream);
    if (!renderInfo) {
        return;
    }
    if (renderInfo.status === 'Rendering') {
        internalContext.setUnparentedRenderInfo(stream, renderInfo.stream, 'Stopping', undefined);
    }
    else {
        internalContext.deleteUnparentedRenderInfo(stream);
    }
    if (renderInfo.renderer) {
        renderInfo.renderer.dispose();
    }
}
/**
 * @private
 */
function createView(context, internalContext, callId, participantId, stream, options) {
    if ('id' in stream && callId && participantId) {
        // Render RemoteVideoStream that is part of a Call
        return createViewRemoteVideo(context, internalContext, callId, participantId, stream, options);
    }
    else if (!('id' in stream) && callId) {
        // Render LocalVideoStream that is part of a Call
        return createViewLocalVideo(context, internalContext, callId, options);
    }
    else if (!('id' in stream) && !callId) {
        // Render LocalVideoStream that is not part of a Call
        return createViewUnparentedVideo(context, internalContext, stream, options);
    }
    else {
        console.warn('Invalid combination of parameters');
        return Promise.resolve();
    }
}
/**
 * @private
 */
function disposeView(context, internalContext, callId, participantId, stream) {
    if ('id' in stream && callId && participantId) {
        // Stop rendering RemoteVideoStream that is part of a Call
        disposeViewRemoteVideo(context, internalContext, callId, participantId, stream);
    }
    else if (!('id' in stream) && callId) {
        // Stop rendering LocalVideoStream that is part of a Call
        disposeViewLocalVideo(context, internalContext, callId);
    }
    else if (!('id' in stream) && !callId) {
        // Stop rendering LocalVideoStream that is not part of a Call
        disposeViewUnparentedVideo(context, internalContext, stream);
    }
    else {
        console.warn('Invalid combination of parameters');
        return;
    }
}
/**
 * @private
 * Only stops videos that are tied to a Call.
 */
function disposeAllViewsFromCall(context, internalContext, callId) {
    const callStreams = internalContext.getRemoteRenderInfoForCall(callId);
    if (callStreams) {
        for (const [participantKey, participantStreams] of callStreams.entries()) {
            for (const [_, remoteStreamAndRenderer] of participantStreams.entries()) {
                // We don't want to accept SDK stream as parameter but we also don't cache the declarative stream so we have to
                // convert the SDK stream to declarative stream which is not pretty so this could use some further refactoring.
                disposeView(context, internalContext, callId, participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(remoteStreamAndRenderer.stream));
            }
        }
    }
    const localStreamAndRenderer = internalContext.getLocalRenderInfo(callId);
    if (localStreamAndRenderer && localStreamAndRenderer.renderer) {
        // We don't want to accept SDK stream as parameter but we also don't cache the declarative stream so we have to
        // convert the SDK stream to declarative stream which is not pretty so this could use some further refactoring.
        disposeView(context, internalContext, callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(localStreamAndRenderer.stream));
    }
}
/**
 * @private
 */
function disposeAllViews(context, internalContext) {
    const remoteStreamAndRenderers = internalContext.getRemoteRenderInfos();
    for (const [callId] of remoteStreamAndRenderers.entries()) {
        disposeAllViewsFromCall(context, internalContext, callId);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Keeps track of the listeners assigned to a particular participant because when we get an event from SDK, it doesn't
 * tell us which participant it is for. If we keep track of this then we know which participant in the state that needs
 * an update and also which property of that participant. Also we can use this when unregistering to a participant.
 */
class ParticipantSubscriber$1 {
    constructor(callIdRef, participant, context, internalContext) {
        this.subscribe = () => {
            this._participant.on('stateChanged', this.stateChanged);
            this._participant.on('isMutedChanged', this.isMutedChanged);
            this._participant.on('displayNameChanged', this.displayNameChanged);
            this._participant.on('isSpeakingChanged', this.isSpeakingChanged);
            this._participant.on('videoStreamsUpdated', this.videoStreamsUpdated);
            if (this._participant.videoStreams.length > 0) {
                for (const stream of this._participant.videoStreams) {
                    this._internalContext.setRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id, stream, 'NotRendered', undefined);
                    this.addRemoteVideoStreamSubscriber(stream);
                }
                this._context.setRemoteVideoStreams(this._callIdRef.callId, this._participantKey, this._participant.videoStreams.map(convertSdkRemoteStreamToDeclarativeRemoteStream), []);
            }
        };
        this.unsubscribe = () => {
            this._participant.off('stateChanged', this.stateChanged);
            this._participant.off('isMutedChanged', this.isMutedChanged);
            this._participant.off('displayNameChanged', this.displayNameChanged);
            this._participant.off('isSpeakingChanged', this.isSpeakingChanged);
            this._participant.off('videoStreamsUpdated', this.videoStreamsUpdated);
            // If unsubscribing it means the participant left the call. If they have any rendering streams we should stop them
            // as it doesn't make sense to render for an ended participant.
            if (this._participant.videoStreams.length > 0) {
                for (const stream of this._participant.videoStreams) {
                    disposeView(this._context, this._internalContext, this._callIdRef.callId, this._participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(stream));
                    this._internalContext.deleteRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id);
                }
            }
        };
        this.addRemoteVideoStreamSubscriber = (remoteVideoStream) => {
            var _a;
            (_a = this._remoteVideoStreamSubscribers.get(remoteVideoStream.id)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this._remoteVideoStreamSubscribers.set(remoteVideoStream.id, new RemoteVideoStreamSubscriber(this._callIdRef, this._participantKey, remoteVideoStream, this._context));
        };
        this.stateChanged = () => {
            this._context.setParticipantState(this._callIdRef.callId, this._participantKey, this._participant.state);
        };
        this.isMutedChanged = () => {
            this._context.setParticipantIsMuted(this._callIdRef.callId, this._participantKey, this._participant.isMuted);
        };
        this.displayNameChanged = () => {
            this._context.setParticipantDisplayName(this._callIdRef.callId, this._participantKey, this._participant.displayName || '');
        };
        this.isSpeakingChanged = () => {
            this._context.setParticipantIsSpeaking(this._callIdRef.callId, this._participantKey, this._participant.isSpeaking);
        };
        this.videoStreamsUpdated = (event) => {
            var _a;
            for (const stream of event.removed) {
                (_a = this._remoteVideoStreamSubscribers.get(stream.id)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                disposeView(this._context, this._internalContext, this._callIdRef.callId, this._participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(stream));
                this._internalContext.deleteRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id);
            }
            for (const stream of event.added) {
                this._internalContext.setRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id, stream, 'NotRendered', undefined);
                this.addRemoteVideoStreamSubscriber(stream);
            }
            this._context.setRemoteVideoStreams(this._callIdRef.callId, this._participantKey, event.added.map(convertSdkRemoteStreamToDeclarativeRemoteStream), event.removed.map((stream) => stream.id));
        };
        this._callIdRef = callIdRef;
        this._participant = participant;
        this._context = context;
        this._internalContext = internalContext;
        this._participantKey = toFlatCommunicationIdentifier(this._participant.identifier);
        this._remoteVideoStreamSubscribers = new Map();
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
class RecordingSubscriber {
    constructor(callIdRef, context, recording) {
        this.subscribe = () => {
            this._recording.on('isRecordingActiveChanged', this.isAvailableChanged);
        };
        this.unsubscribe = () => {
            this._recording.off('isRecordingActiveChanged', this.isAvailableChanged);
        };
        this.isAvailableChanged = () => {
            this._context.setCallRecordingActive(this._callIdRef.callId, this._recording.isRecordingActive);
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._recording = recording;
        // If recording as already started when we joined the call, make sure it is reflected in state as there may not
        // be an event for it.
        if (this._recording.isRecordingActive) {
            this._context.setCallRecordingActive(this._callIdRef.callId, this._recording.isRecordingActive);
        }
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
class TranscriptionSubscriber {
    constructor(callIdRef, context, transcription) {
        this.subscribe = () => {
            this._transcription.on('isTranscriptionActiveChanged', this.isTranscriptionActiveChanged);
        };
        this.unsubscribe = () => {
            this._transcription.off('isTranscriptionActiveChanged', this.isTranscriptionActiveChanged);
        };
        this.isTranscriptionActiveChanged = () => {
            this._context.setCallTranscriptionActive(this._callIdRef.callId, this._transcription.isTranscriptionActive);
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._transcription = transcription;
        // If transcription as already started when we joined the call, make sure it is reflected in state as there may not
        // be an event for it.
        if (this._transcription.isTranscriptionActive) {
            this._context.setCallTranscriptionActive(this._callIdRef.callId, this._transcription.isTranscriptionActive);
        }
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
class UserFacingDiagnosticsSubscriber {
    constructor(callIdRef, context, diagnostics) {
        this.unsubscribe = () => {
            this._diagnostics.network.off('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
            this._diagnostics.media.off('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._diagnostics = diagnostics;
        this.setInitialDiagnostics();
        this.subscribe();
    }
    setInitialDiagnostics() {
        const network = this._diagnostics.network.getLatest();
        const media = this._diagnostics.media.getLatest();
        if (Object.entries(network).length === 0 && Object.entries(media).length === 0) {
            return;
        }
        this._context.modifyState((state) => {
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            call.diagnostics = {
                network: {
                    latest: network
                },
                media: {
                    latest: media
                }
            };
        });
    }
    subscribe() {
        this._diagnostics.network.on('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
        this._diagnostics.media.on('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
    }
    networkDiagnosticsChanged(args) {
        this._context.modifyState((state) => {
            var _a;
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            const network = (_a = call.diagnostics) === null || _a === void 0 ? void 0 : _a.network.latest;
            if (network) {
                network[args.diagnostic] = latestFromEvent(args);
            }
        });
    }
    mediaDiagnosticsChanged(args) {
        this._context.modifyState((state) => {
            var _a;
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            const media = (_a = call.diagnostics) === null || _a === void 0 ? void 0 : _a.media.latest;
            if (media) {
                media[args.diagnostic] = latestFromEvent(args);
            }
        });
    }
}
const latestFromEvent = (args) => ({
    value: args.value,
    valueType: args.valueType
});

// Copyright (c) Microsoft Corporation.
/**
 * Keeps track of the listeners assigned to a particular call because when we get an event from SDK, it doesn't tell us
 * which call it is for. If we keep track of this then we know which call in the state that needs an update and also
 * which property of that call. Also we can use this when unregistering to a call.
 */
class CallSubscriber {
    constructor(call, context, internalContext) {
        this.subscribe = () => {
            this._call.on('stateChanged', this.stateChanged);
            this._call.on('idChanged', this.idChanged);
            this._call.on('isScreenSharingOnChanged', this.isScreenSharingOnChanged);
            this._call.on('remoteParticipantsUpdated', this.remoteParticipantsUpdated);
            this._call.on('localVideoStreamsUpdated', this.localVideoStreamsUpdated);
            this._call.on('isMutedChanged', this.isMuteChanged);
            this._call.feature(communicationCalling.Features.DominantSpeakers).on('dominantSpeakersChanged', this.dominantSpeakersChanged);
            // At time of writing only one LocalVideoStream is supported by SDK.
            if (this._call.localVideoStreams.length > 0) {
                this._internalContext.setLocalRenderInfo(this._callIdRef.callId, this._call.localVideoStreams[0], 'NotRendered', undefined);
            }
            if (this._call.remoteParticipants.length > 0) {
                this._call.remoteParticipants.forEach((participant) => {
                    this.addParticipantListener(participant);
                });
                this._context.setCallRemoteParticipants(this._callIdRef.callId, this._call.remoteParticipants.map(convertSdkParticipantToDeclarativeParticipant), []);
            }
        };
        this.unsubscribe = () => {
            this._call.off('stateChanged', this.stateChanged);
            this._call.off('idChanged', this.idChanged);
            this._call.off('isScreenSharingOnChanged', this.isScreenSharingOnChanged);
            this._call.off('remoteParticipantsUpdated', this.remoteParticipantsUpdated);
            this._call.off('localVideoStreamsUpdated', this.localVideoStreamsUpdated);
            this._call.off('isMutedChanged', this.isMuteChanged);
            this._participantSubscribers.forEach((participantSubscriber) => {
                participantSubscriber.unsubscribe();
            });
            this._participantSubscribers.clear();
            // If we are unsubscribing that means we no longer want to display any video for this call (callEnded or callAgent
            // disposed) and we should not be updating it any more. So if video is rendering we stop rendering.
            if (this._call.localVideoStreams && this._call.localVideoStreams[0]) {
                disposeView(this._context, this._internalContext, this._callIdRef.callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(this._call.localVideoStreams[0]));
            }
            this._internalContext.deleteLocalRenderInfo(this._callIdRef.callId);
            this._diagnosticsSubscriber.unsubscribe();
            this._recordingSubscriber.unsubscribe();
            this._transcriptionSubscriber.unsubscribe();
        };
        this.stateChanged = () => {
            this._context.setCallState(this._callIdRef.callId, this._call.state);
        };
        this.idChanged = () => {
            this._internalContext.setCallId(this._call.id, this._callIdRef.callId);
            this._context.setCallId(this._call.id, this._callIdRef.callId);
            this._callIdRef.callId = this._call.id;
        };
        this.isScreenSharingOnChanged = () => {
            this._context.setCallIsScreenSharingOn(this._callIdRef.callId, this._call.isScreenSharingOn);
        };
        this.isMuteChanged = () => {
            this._context.setCallIsMicrophoneMuted(this._callIdRef.callId, this._call.isMuted);
        };
        this.remoteParticipantsUpdated = (event) => {
            event.added.forEach((participant) => {
                this.addParticipantListener(participant);
            });
            event.removed.forEach((participant) => {
                this.removeParticipantListener(participant);
            });
            // Remove any added participants from remoteParticipantsEnded if they are there and add any removed participants to
            // remoteParticipantsEnded.
            this._context.setCallRemoteParticipantsEnded(this._callIdRef.callId, event.removed.map(convertSdkParticipantToDeclarativeParticipant), event.added.map((participant) => {
                return toFlatCommunicationIdentifier(participant.identifier);
            }));
            // Add added participants to remoteParticipants and remove removed participants from remoteParticipants.
            this._context.setCallRemoteParticipants(this._callIdRef.callId, event.added.map(convertSdkParticipantToDeclarativeParticipant), event.removed.map((participant) => {
                return toFlatCommunicationIdentifier(participant.identifier);
            }));
        };
        this.localVideoStreamsUpdated = (event) => {
            // At time of writing only one LocalVideoStream is supported by SDK.
            if (event.added.length > 0) {
                const localVideoStreams = [convertSdkLocalStreamToDeclarativeLocalStream(this._call.localVideoStreams[0])];
                // IMPORTANT: The internalContext should be set before context. This is done to ensure that the internal context
                // has the required data when component re-renders due to external state changes.
                this._internalContext.setLocalRenderInfo(this._callIdRef.callId, this._call.localVideoStreams[0], 'NotRendered', undefined);
                this._context.setCallLocalVideoStream(this._callIdRef.callId, [...localVideoStreams]);
            }
            if (event.removed.length > 0) {
                disposeView(this._context, this._internalContext, this._callIdRef.callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(event.removed[0]));
                this._internalContext.deleteLocalRenderInfo(this._callIdRef.callId);
                this._context.setCallLocalVideoStream(this._callIdRef.callId, []);
            }
        };
        this.dominantSpeakersChanged = () => {
            const dominantSpeakers = this._call.feature(communicationCalling.Features.DominantSpeakers).dominantSpeakers;
            this._context.setCallDominantSpeakers(this._callIdRef.callId, dominantSpeakers);
        };
        this._call = call;
        this._callIdRef = { callId: call.id };
        this._context = context;
        this._internalContext = internalContext;
        this._diagnosticsSubscriber = new UserFacingDiagnosticsSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.UserFacingDiagnostics));
        this._participantSubscribers = new Map();
        this._recordingSubscriber = new RecordingSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.Recording));
        this._transcriptionSubscriber = new TranscriptionSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.Transcription));
        this.subscribe();
    }
    addParticipantListener(participant) {
        var _a;
        const participantKey = toFlatCommunicationIdentifier(participant.identifier);
        (_a = this._participantSubscribers.get(participantKey)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this._participantSubscribers.set(participantKey, new ParticipantSubscriber$1(this._callIdRef, participant, this._context, this._internalContext));
    }
    removeParticipantListener(participant) {
        const participantKey = toFlatCommunicationIdentifier(participant.identifier);
        const participantSubscriber = this._participantSubscribers.get(participantKey);
        if (participantSubscriber) {
            participantSubscriber.unsubscribe();
            this._participantSubscribers.delete(participantKey);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Keeps track of the listeners assigned to a particular incoming call because when we get an event from SDK, it doesn't
 * tell us which incoming call it is for. If we keep track of this then we know which incoming call in the state that
 * needs an update and also which property of that incoming call. Also we can use this when unregistering to a incoming
 * call.
 */
class IncomingCallSubscriber {
    constructor(incomingCall, 
    // setIncomingCallEnded callback is used so parent can clean up IncomingCallSubscriber.
    setIncomingCallEnded) {
        this.subscribe = () => {
            this._incomingCall.on('callEnded', this.callEnded);
        };
        this.unsubscribe = () => {
            this._incomingCall.off('callEnded', this.callEnded);
        };
        this.callEnded = (event) => {
            this._setIncomingCallEnded(this._incomingCall.id, event.callEndReason);
        };
        this._incomingCall = incomingCall;
        this._setIncomingCallEnded = setIncomingCallEnded;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * ProxyCallAgent proxies CallAgent and saves any returned state in the given context. It will subscribe to all state
 * updates in the CallAgent and in the contained Calls and RemoteParticipants. When dispose is called it will
 * unsubscribe from all state updates.
 */
class ProxyCallAgent {
    constructor(callAgent, context, internalContext) {
        this.subscribe = () => {
            this._callAgent.on('callsUpdated', this.callsUpdated);
            this._callAgent.on('incomingCall', this.incomingCall);
            // There could be scenario that when ProxyCallAgent is created that the given CallAgent already has Calls. In this
            // case we need to make sure to subscribe to those already existing Calls.
            for (const call of this._callAgent.calls) {
                this.addCall(call);
            }
        };
        this.unsubscribe = () => {
            this._callAgent.off('callsUpdated', this.callsUpdated);
            this._callAgent.off('incomingCall', this.incomingCall);
            // Unsubscribe is called when CallAgent is disposed. This should mean no more updating of existing call but we don't
            // remove any existing state.
            for (const [_, callSubscriber] of this._callSubscribers.entries()) {
                callSubscriber.unsubscribe();
            }
            this._callSubscribers.clear();
            for (const [_, incomingCallSubscriber] of this._incomingCallSubscribers.entries()) {
                incomingCallSubscriber.unsubscribe();
            }
            this._incomingCallSubscribers.clear();
            for (const [_, declarativeCall] of this._declarativeCalls.entries()) {
                declarativeCall.unsubscribe();
            }
            this._declarativeCalls.clear();
        };
        this.callsUpdated = (event) => {
            const addedStatefulCall = [];
            for (const call of event.added) {
                const statefulCall = this.addCall(call);
                addedStatefulCall.push(statefulCall);
            }
            const removedStatefulCall = [];
            for (const call of event.removed) {
                disposeAllViewsFromCall(this._context, this._internalContext, call.id);
                const callSubscriber = this._callSubscribers.get(call);
                if (callSubscriber) {
                    callSubscriber.unsubscribe();
                    this._callSubscribers.delete(call);
                }
                this._context.setCallEnded(call.id, call.callEndReason);
                const declarativeCall = this._declarativeCalls.get(call);
                if (declarativeCall) {
                    declarativeCall.unsubscribe();
                    removedStatefulCall.push(declarativeCall);
                    this._declarativeCalls.delete(call);
                }
                else {
                    removedStatefulCall.push(callDeclaratify(call, this._context));
                }
            }
            for (const externalCallsUpdatedListener of this._externalCallsUpdatedListeners) {
                externalCallsUpdatedListener({ added: addedStatefulCall, removed: removedStatefulCall });
            }
        };
        this.setIncomingCallEnded = (incomingCallId, callEndReason) => {
            const incomingCallSubscriber = this._incomingCallSubscribers.get(incomingCallId);
            if (incomingCallSubscriber) {
                incomingCallSubscriber.unsubscribe();
                this._incomingCallSubscribers.delete(incomingCallId);
            }
            this._context.setIncomingCallEnded(incomingCallId, callEndReason);
        };
        this.incomingCall = (event) => {
            // Make sure to not subscribe to the incoming call if we are already subscribed to it.
            if (!this._incomingCallSubscribers.has(event.incomingCall.id)) {
                this._incomingCallSubscribers.set(event.incomingCall.id, new IncomingCallSubscriber(event.incomingCall, this.setIncomingCallEnded));
            }
            this._context.setIncomingCall(convertSdkIncomingCallToDeclarativeIncomingCall(event.incomingCall));
        };
        this.addCall = (call) => {
            var _a;
            (_a = this._callSubscribers.get(call)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            // For API extentions we need to have the call in the state when we are subscribing as we may want to update the
            // state during the subscription process in the subscriber so we add the call to state before subscribing.
            this._context.setCall(convertSdkCallToDeclarativeCall(call));
            this._callSubscribers.set(call, new CallSubscriber(call, this._context, this._internalContext));
            return this.getOrCreateDeclarativeCall(call);
        };
        this.getOrCreateDeclarativeCall = (call) => {
            const declarativeCall = this._declarativeCalls.get(call);
            if (declarativeCall) {
                return declarativeCall;
            }
            const newDeclarativeCall = callDeclaratify(call, this._context);
            this._declarativeCalls.set(call, newDeclarativeCall);
            return newDeclarativeCall;
        };
        this._callAgent = callAgent;
        this._context = context;
        this._internalContext = internalContext;
        this._callSubscribers = new Map();
        this._incomingCallSubscribers = new Map();
        this._declarativeCalls = new Map();
        this._externalCallsUpdatedListeners = new Set();
        this.subscribe();
    }
    get(target, prop) {
        switch (prop) {
            case 'startCall': {
                return this._context.withErrorTeedToState((...args) => {
                    const call = target.startCall(...args);
                    this.addCall(call);
                    return this.getOrCreateDeclarativeCall(call);
                }, 'CallAgent.startCall');
            }
            case 'join': {
                return this._context.withErrorTeedToState((...args) => {
                    const call = target.join(...args);
                    this.addCall(call);
                    return this.getOrCreateDeclarativeCall(call);
                }, 'CallAgent.join');
            }
            case 'calls': {
                return Array.from(this._declarativeCalls.values());
            }
            case 'on': {
                return (...args) => {
                    const isCallsUpdated = args[0] === 'callsUpdated';
                    if (isCallsUpdated) {
                        const listener = args[1];
                        this._externalCallsUpdatedListeners.add(listener);
                    }
                    else {
                        target.on(...args);
                    }
                };
            }
            case 'off': {
                return (...args) => {
                    const isCallsUpdated = args[0] === 'callsUpdated';
                    if (isCallsUpdated) {
                        const listener = args[1];
                        this._externalCallsUpdatedListeners.delete(listener);
                    }
                    else {
                        target.off(...args);
                    }
                };
            }
            case 'dispose': {
                return () => {
                    return target.dispose().then(() => {
                        this.unsubscribe();
                    });
                };
            }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a declarative CallAgent by proxying CallAgent with ProxyCallAgent which will track state updates by updating
 * the given context.
 *
 * @param callAgent - CallAgent from SDK
 * @param context - CallContext from StatefulCallClient
 * @param internalContext- InternalCallContext from StatefulCallClient
 */
const callAgentDeclaratify = (callAgent, context, internalContext) => {
    // Make sure there are no existing call data if creating a new CallAgentDeclarative (if creating a new
    // CallAgentDeclarative after disposing of the hold one will mean context have old call state). TODO: should we stop
    // rendering when the previous callAgent is disposed?
    disposeAllViews(context, internalContext);
    context.clearCallRelatedState();
    internalContext.clearCallRelatedState();
    return new Proxy(callAgent, new ProxyCallAgent(callAgent, context, internalContext));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Contains internal data used between different Declarative components to share data.
 */
class InternalCallContext {
    constructor() {
        // <CallId, <ParticipantKey, <StreamId, RemoteRenderInfo>>
        this._remoteRenderInfos = new Map();
        // <CallId, LocalRenderInfo>.
        this._localRenderInfos = new Map();
        // Used for keeping track of rendered LocalVideoStreams that are not part of a Call.
        // The key is the stream ID. We assume each stream ID to only have one owning render info
        this._unparentedRenderInfos = new Map();
    }
    setCallId(newCallId, oldCallId) {
        const remoteRenderInfos = this._remoteRenderInfos.get(oldCallId);
        if (remoteRenderInfos) {
            this._remoteRenderInfos.delete(oldCallId);
            this._remoteRenderInfos.set(newCallId, remoteRenderInfos);
        }
        const localRenderInfos = this._localRenderInfos.get(oldCallId);
        if (localRenderInfos) {
            this._localRenderInfos.delete(oldCallId);
            this._localRenderInfos.set(newCallId, localRenderInfos);
        }
    }
    getRemoteRenderInfos() {
        return this._remoteRenderInfos;
    }
    getRemoteRenderInfoForCall(callId) {
        return this._remoteRenderInfos.get(callId);
    }
    getRemoteRenderInfoForParticipant(callId, participantKey, streamId) {
        const callRenderInfos = this._remoteRenderInfos.get(callId);
        if (!callRenderInfos) {
            return undefined;
        }
        const participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            return undefined;
        }
        return participantRenderInfos.get(streamId);
    }
    setRemoteRenderInfo(callId, participantKey, streamId, stream, status, renderer) {
        let callRenderInfos = this._remoteRenderInfos.get(callId);
        if (!callRenderInfos) {
            callRenderInfos = new Map();
            this._remoteRenderInfos.set(callId, callRenderInfos);
        }
        let participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            participantRenderInfos = new Map();
            callRenderInfos.set(participantKey, participantRenderInfos);
        }
        participantRenderInfos.set(streamId, { stream, status, renderer });
    }
    deleteRemoteRenderInfo(callId, participantKey, streamId) {
        const callRenderInfos = this._remoteRenderInfos.get(callId);
        if (!callRenderInfos) {
            return;
        }
        const participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            return;
        }
        participantRenderInfos.delete(streamId);
    }
    setLocalRenderInfo(callId, stream, status, renderer) {
        this._localRenderInfos.set(callId, { stream, status, renderer });
    }
    getLocalRenderInfo(callId) {
        return this._localRenderInfos.get(callId);
    }
    deleteLocalRenderInfo(callId) {
        this._localRenderInfos.delete(callId);
    }
    getUnparentedRenderInfo(localVideoStream) {
        return this._unparentedRenderInfos.get(localVideoStream.source.id);
    }
    setUnparentedRenderInfo(statefulStream, stream, status, renderer) {
        this._unparentedRenderInfos.set(statefulStream.source.id, { stream, status, renderer });
    }
    deleteUnparentedRenderInfo(localVideoStream) {
        this._unparentedRenderInfos.delete(localVideoStream.source.id);
    }
    // UnparentedRenderInfos are not cleared as they are not part of the Call state.
    clearCallRelatedState() {
        this._remoteRenderInfos.clear();
        this._localRenderInfos.clear();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$b = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * ProxyCallClient proxies CallClient {@link @azure/communication-calling#CallClient} and subscribes to all events that
 * affect state. ProxyCallClient keeps its own copy of the call state and when state is updated, ProxyCallClient emits
 * the event 'stateChanged'.
 */
class ProxyCallClient {
    constructor(context, internalContext) {
        this._context = context;
        this._internalContext = internalContext;
    }
    get(target, prop) {
        switch (prop) {
            case 'createCallAgent': {
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$b(this, void 0, void 0, function* () {
                    // createCallAgent will throw an exception if the previous callAgent was not disposed. If the previous
                    // callAgent was disposed then it would have unsubscribed to events so we can just create a new declarative
                    // callAgent if the createCallAgent succeeds.
                    const callAgent = yield target.createCallAgent(...args);
                    this._callAgent = callAgentDeclaratify(callAgent, this._context, this._internalContext);
                    this._context.setCallAgent({ displayName: this._callAgent.displayName });
                    return this._callAgent;
                }), 'CallClient.createCallAgent');
            }
            case 'getDeviceManager': {
                return this._context.withAsyncErrorTeedToState(() => __awaiter$b(this, void 0, void 0, function* () {
                    // As of writing, the SDK always returns the same instance of DeviceManager so we keep a reference of
                    // DeviceManager and if it does not change we return the cached DeclarativeDeviceManager. If it does not we'll
                    // throw an error that indicate we need to fix this issue as our implementation has diverged from the SDK.
                    const deviceManager = yield target.getDeviceManager();
                    if (this._sdkDeviceManager) {
                        if (this._sdkDeviceManager === deviceManager) {
                            return this._deviceManager;
                        }
                        else {
                            throw new Error('Multiple DeviceManager not supported. This means a incompatible version of communication-calling is ' +
                                'used OR calling declarative was not properly updated to communication-calling version.');
                        }
                    }
                    else {
                        this._sdkDeviceManager = deviceManager;
                    }
                    this._deviceManager = deviceManagerDeclaratify(deviceManager, this._context);
                    return this._deviceManager;
                }), 'CallClient.getDeviceManager');
            }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a StatefulCallClient {@link StatefulCallClient} by proxying CallClient
 * {@link @azure/communication-calling#CallClient} with ProxyCallClient {@link ProxyCallClient} which then allows access
 * to state in a declarative way.
 *
 * It is important to use the {@link @azure/communication-calling#DeviceManager} and
 * {@link @azure/communication-calling#CallAgent} and {@link @azure/communication-calling#Call} (and etc.) that are
 * obtained from the StatefulCallClient in order for their state changes to be proxied properly.
 *
 * @param args - {@link StatefulCallClientArgs}
 * @param options - {@link StatefulCallClientOptions}
 *
 * @public
 */
const createStatefulCallClient = (args, options) => {
    return createStatefulCallClientWithDeps(new communicationCalling.CallClient(withTelemetryTag(options === null || options === void 0 ? void 0 : options.callClientOptions)), new CallContext$1(communicationCommon.getIdentifierKind(args.userId), options === null || options === void 0 ? void 0 : options.maxStateChangeListeners), new InternalCallContext());
};
/**
 * Package-internal version of createStatefulCallClient that allows dependency injection.
 *
 * This function should not be exported from the package.
 */
const createStatefulCallClientWithDeps = (callClient, context, internalContext) => {
    Object.defineProperty(callClient, 'getState', {
        configurable: false,
        value: () => context.getState()
    });
    Object.defineProperty(callClient, 'onStateChange', {
        configurable: false,
        value: (handler) => context.onStateChange(handler)
    });
    Object.defineProperty(callClient, 'offStateChange', {
        configurable: false,
        value: (handler) => context.offStateChange(handler)
    });
    Object.defineProperty(callClient, 'createView', {
        configurable: false,
        value: (callId, participantId, stream, options) => {
            const participantIdKind = participantId ? communicationCommon.getIdentifierKind(participantId) : undefined;
            return createView(context, internalContext, callId, participantIdKind, stream, options);
        }
    });
    Object.defineProperty(callClient, 'disposeView', {
        configurable: false,
        value: (callId, participantId, stream) => {
            const participantIdKind = participantId ? communicationCommon.getIdentifierKind(participantId) : undefined;
            disposeView(context, internalContext, callId, participantIdKind, stream);
        }
    });
    return new Proxy(callClient, new ProxyCallClient(context, internalContext));
};
const withTelemetryTag = (options) => {
    var _a, _b;
    const tags = (_b = (_a = options === null || options === void 0 ? void 0 : options.diagnostics) === null || _a === void 0 ? void 0 : _a.tags) !== null && _b !== void 0 ? _b : [];
    tags.push(_getApplicationId());
    return Object.assign(Object.assign({}, options), { diagnostics: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.diagnostics), { tags }) });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Error thrown from failed {@link StatefulChatClient} methods.
 *
 * @public
 */
class ChatError extends Error {
    constructor(target, innerError, timestamp) {
        super();
        this.target = target;
        this.innerError = innerError;
        // Testing note: It is easier to mock Date::now() than the Date() constructor.
        this.timestamp = timestamp !== null && timestamp !== void 0 ? timestamp : new Date(Date.now());
        this.name = 'ChatError';
        this.message = `${this.target}: ${this.innerError.message}`;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const Constants = {
    TYPING_INDICATOR_MAINTAIN_TIME: 8 * 1000,
    DUMMY_DATE: new Date(0)
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$a = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
produce.enableMapSet();
/**
 * @private
 */
class ChatContext$1 {
    constructor(maxListeners) {
        this._state = {
            userId: { id: '' },
            displayName: '',
            threads: {},
            latestErrors: {}
        };
        this._batchMode = false;
        this.typingIndicatorInterval = undefined;
        this._emitter = new EventEmitter__default['default']();
        if (maxListeners) {
            this._emitter.setMaxListeners(maxListeners);
        }
    }
    setState(state) {
        this._state = state;
        if (!this._batchMode) {
            this._emitter.emit('stateChanged', this._state);
        }
    }
    getState() {
        return this._state;
    }
    modifyState(modifier) {
        this.batch(() => {
            this.setState(produce__default['default'](this._state, (draft) => {
                modifier(draft);
            }));
        });
    }
    setThread(threadId, threadState) {
        this.setState(produce__default['default'](this._state, (draft) => {
            draft.threads[threadId] = threadState;
        }));
    }
    createThread(threadId, properties) {
        this.setState(produce__default['default'](this._state, (draft) => {
            draft.threads[threadId] = {
                chatMessages: {},
                threadId: threadId,
                properties: properties,
                participants: {},
                readReceipts: [],
                typingIndicators: [],
                latestReadTime: new Date(0)
            };
        }));
    }
    updateChatConfig(userId, displayName) {
        this.setState(produce__default['default'](this._state, (draft) => {
            draft.displayName = displayName;
            draft.userId = userId;
        }));
    }
    createThreadIfNotExist(threadId, properties) {
        const exists = Object.prototype.hasOwnProperty.call(this.getState().threads, threadId);
        if (!exists) {
            this.createThread(threadId, properties);
            return true;
        }
        return false;
    }
    updateThread(threadId, properties) {
        this.setState(produce__default['default'](this._state, (draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                thread.properties = properties;
            }
        }));
    }
    updateThreadTopic(threadId, topic) {
        this.setState(produce__default['default'](this._state, (draft) => {
            if (topic === undefined) {
                return;
            }
            const thread = draft.threads[threadId];
            if (thread && !thread.properties) {
                thread.properties = { topic: topic };
            }
            else if (thread && thread.properties) {
                thread.properties.topic = topic;
            }
        }));
    }
    deleteThread(threadId) {
        this.setState(produce__default['default'](this._state, (draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                delete draft.threads[threadId];
            }
        }));
    }
    setChatMessages(threadId, messages) {
        this.setState(produce__default['default'](this._state, (draft) => {
            const threadState = draft.threads[threadId];
            if (threadState) {
                threadState.chatMessages = messages;
            }
            // remove typing indicator when receive messages
            const thread = draft.threads[threadId];
            if (thread) {
                for (const message of Object.values(messages)) {
                    this.filterTypingIndicatorForUser(thread, message.sender);
                }
            }
        }));
    }
    updateChatMessageContent(threadId, messagesId, content) {
        this.setState(produce__default['default'](this._state, (draft) => {
            var _a;
            const chatMessage = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages[messagesId];
            if (chatMessage) {
                if (!chatMessage.content) {
                    chatMessage.content = {};
                }
                chatMessage.content.message = content;
            }
        }));
    }
    deleteLocalMessage(threadId, localId) {
        let localMessageDeleted = false;
        this.setState(produce__default['default'](this._state, (draft) => {
            var _a;
            const chatMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
            const message = chatMessages ? chatMessages[localId] : undefined;
            if (chatMessages && message && message.clientMessageId) {
                delete chatMessages[message.clientMessageId];
                localMessageDeleted = true;
            }
        }));
        return localMessageDeleted;
    }
    deleteMessage(threadId, id) {
        this.setState(produce__default['default'](this._state, (draft) => {
            var _a;
            const chatMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
            if (chatMessages) {
                delete chatMessages[id];
            }
        }));
    }
    setParticipant(threadId, participant) {
        this.setState(produce__default['default'](this._state, (draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                participants[toFlatCommunicationIdentifier(participant.id)] = participant;
            }
        }));
    }
    setParticipants(threadId, participants) {
        this.setState(produce__default['default'](this._state, (draft) => {
            var _a;
            const participantsMap = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participantsMap) {
                for (const participant of participants) {
                    participantsMap[toFlatCommunicationIdentifier(participant.id)] = participant;
                }
            }
        }));
    }
    deleteParticipants(threadId, participantIds) {
        this.setState(produce__default['default'](this._state, (draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                participantIds.forEach((id) => {
                    delete participants[toFlatCommunicationIdentifier(id)];
                });
            }
        }));
    }
    deleteParticipant(threadId, participantId) {
        this.setState(produce__default['default'](this._state, (draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                delete participants[toFlatCommunicationIdentifier(participantId)];
            }
        }));
    }
    addReadReceipt(threadId, readReceipt) {
        this.setState(produce__default['default'](this._state, (draft) => {
            const thread = draft.threads[threadId];
            const readReceipts = thread === null || thread === void 0 ? void 0 : thread.readReceipts;
            if (thread && readReceipts) {
                // TODO(prprabhu): Replace `this.getState()` with `draft`?
                if (readReceipt.sender !== this.getState().userId && thread.latestReadTime < readReceipt.readOn) {
                    thread.latestReadTime = readReceipt.readOn;
                }
                readReceipts.push(readReceipt);
            }
        }));
    }
    startTypingIndicatorCleanUp() {
        if (!this.typingIndicatorInterval) {
            this.typingIndicatorInterval = window.setInterval(() => {
                let isTypingActive = false;
                let isStateChanged = false;
                const newState = produce__default['default'](this._state, (draft) => {
                    for (const thread of Object.values(draft.threads)) {
                        const filteredTypingIndicators = thread.typingIndicators.filter((typingIndicator) => {
                            const timeGap = Date.now() - typingIndicator.receivedOn.getTime();
                            return timeGap < Constants.TYPING_INDICATOR_MAINTAIN_TIME;
                        });
                        if (thread.typingIndicators.length !== filteredTypingIndicators.length) {
                            isStateChanged = true;
                            thread.typingIndicators = filteredTypingIndicators;
                        }
                        if (thread.typingIndicators.length > 0) {
                            isTypingActive = true;
                        }
                    }
                });
                if (isStateChanged) {
                    this.setState(newState);
                }
                if (!isTypingActive && this.typingIndicatorInterval) {
                    window.clearInterval(this.typingIndicatorInterval);
                    this.typingIndicatorInterval = undefined;
                }
            }, 1000);
        }
    }
    addTypingIndicator(threadId, typingIndicator) {
        this.setState(produce__default['default'](this._state, (draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                const typingIndicators = thread.typingIndicators;
                typingIndicators.push(typingIndicator);
            }
        }));
        // Make sure we only maintain a period of typing indicator for perf purposes
        this.startTypingIndicatorCleanUp();
    }
    setChatMessage(threadId, message) {
        const { id: messageId, clientMessageId } = message;
        if (messageId || clientMessageId) {
            this.setState(produce__default['default'](this._state, (draft) => {
                var _a;
                const threadMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
                const isLocalIdInMap = threadMessages && clientMessageId && threadMessages[clientMessageId];
                const messageKey = !messageId || isLocalIdInMap ? clientMessageId : messageId;
                if (threadMessages && messageKey) {
                    threadMessages[messageKey] = message;
                }
                // remove typing indicator when receive a message from a user
                const thread = draft.threads[threadId];
                if (thread) {
                    this.filterTypingIndicatorForUser(thread, message.sender);
                }
            }));
        }
    }
    /**
     * Tees any errors encountered in an async function to the state.
     *
     * @param f Async function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws ChatError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withAsyncErrorTeedToState(f, target) {
        return (...args) => __awaiter$a(this, void 0, void 0, function* () {
            try {
                return yield f(...args);
            }
            catch (error) {
                const chatError = toChatError(target, error);
                this.setLatestError(target, chatError);
                throw chatError;
            }
        });
    }
    /**
     * Tees any errors encountered in an function to the state.
     *
     * @param f Function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws ChatError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withErrorTeedToState(f, target) {
        return (...args) => {
            try {
                return f(...args);
            }
            catch (error) {
                const chatError = toChatError(target, error);
                this.setLatestError(target, chatError);
                throw chatError;
            }
        };
    }
    setLatestError(target, error) {
        this.setState(produce__default['default'](this._state, (draft) => {
            draft.latestErrors[target] = error;
        }));
    }
    // This is a mutating function, only use it inside of a produce() function
    filterTypingIndicatorForUser(thread, userId) {
        if (!userId) {
            return;
        }
        const typingIndicators = thread.typingIndicators;
        const userIdAsKey = toFlatCommunicationIdentifier(userId);
        const filteredTypingIndicators = typingIndicators.filter((typingIndicator) => toFlatCommunicationIdentifier(typingIndicator.sender) !== userIdAsKey);
        if (filteredTypingIndicators.length !== typingIndicators.length) {
            thread.typingIndicators = filteredTypingIndicators;
        }
    }
    /**
     * Batch updates to minimize `stateChanged` events across related operations.
     *
     * - A maximum of one `stateChanged` event is emitted, at the end of the operations.
     * - No `stateChanged` event is emitted if the state did not change through the operations.
     * - In case of an exception, state is reset to the prior value and no `stateChanged` event is emitted.
     *
     * All operations finished in this batch should be synchronous.
     * This function is not reentrant -- do not call batch() from within another batch().
     */
    batch(operations) {
        if (this._batchMode) {
            throw new Error('batch() called from within another batch()');
        }
        this._batchMode = true;
        const priorState = this._state;
        try {
            operations();
            if (this._state !== priorState) {
                this._emitter.emit('stateChanged', this._state);
            }
        }
        catch (e) {
            this._state = priorState;
            throw e;
        }
        finally {
            this._batchMode = false;
        }
    }
    onStateChange(handler) {
        this._emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this._emitter.off('stateChanged', handler);
    }
}
const toChatError = (target, error) => {
    if (error instanceof Error) {
        return new ChatError(target, error);
    }
    return new ChatError(target, new Error(`${error}`));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const convertChatMessage = (message, status = 'delivered', clientMessageId) => {
    return Object.assign(Object.assign({}, message), { clientMessageId: clientMessageId, status });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$9 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues$1 = (window && window.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
// TODO: When we can get messageId of event from SDK, remove this
// Maximum time to look back message list when we receive a system event
const maxSyncTimeInMs = 10 * 1000;
/**
 * @private
 */
class EventSubscriber {
    constructor(chatClient, chatContext) {
        this.convertEventToChatMessage = (event) => {
            return convertChatMessage({
                id: event.id,
                version: event.version,
                content: { message: event.message },
                type: this.convertEventType(event.type),
                sender: event.sender,
                senderDisplayName: event.senderDisplayName,
                sequenceId: '',
                createdOn: new Date(event.createdOn),
                editedOn: 'editedOn' in event ? event.editedOn : undefined
            });
        };
        // convert event type to chatMessage type, only possible type is 'html' and 'text' in chat event
        this.convertEventType = (type) => {
            const lowerCaseType = type.toLowerCase();
            if (lowerCaseType === 'richtext/html' || lowerCaseType === 'html') {
                return 'html';
            }
            else {
                return 'text';
            }
        };
        this.onChatMessageReceived = (event) => {
            var _a;
            // Today we are avoiding how to render these messages. In the future we can
            // remove this condition and handle this message appropriately.
            const messageEventType = event.type.toLowerCase();
            if (messageEventType !== 'text' && messageEventType !== 'richtext/html' && messageEventType !== 'html') {
                return;
            }
            const newMessage = this.convertEventToChatMessage(event);
            // Because of bug in chatMessageReceived event, if we already have that particular message in context, we want to
            // make sure to not overwrite the sequenceId when calling setChatMessage.
            const existingMessage = (_a = this.chatContext.getState().threads[event.threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages[event.id];
            if (existingMessage) {
                newMessage.sequenceId = existingMessage.sequenceId;
            }
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.setChatMessage(event.threadId, newMessage);
            });
        };
        this.onChatMessageDeleted = (event) => {
            this.chatContext.deleteMessage(event.threadId, event.id);
        };
        this.onChatMessageEdited = (event) => {
            const editedMessage = this.convertEventToChatMessage(event);
            this.chatContext.setChatMessage(event.threadId, convertChatMessage(editedMessage));
        };
        this.onParticipantsAdded = (event) => {
            const participantsToAdd = event.participantsAdded.map((participant) => (Object.assign(Object.assign({}, participant), { shareHistoryTime: participant.shareHistoryTime ? new Date(participant.shareHistoryTime) : undefined })));
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.setParticipants(event.threadId, participantsToAdd);
            });
            this.fetchLastParticipantMessage(event.threadId, 'participantAdded');
        };
        // This is a hot fix that no participant message is received for onChatMessageReceived event, which should be handled by JS SDK
        this.fetchLastParticipantMessage = (threadId, actionType) => __awaiter$9(this, void 0, void 0, function* () {
            var e_1, _a;
            try {
                for (var _b = __asyncValues$1(this.chatClient
                    .getChatThreadClient(threadId)
                    .listMessages({ startTime: new Date(Date.now() - maxSyncTimeInMs) })), _c; _c = yield _b.next(), !_c.done;) {
                    const message = _c.value;
                    if (message.type === actionType) {
                        this.chatContext.setChatMessage(threadId, Object.assign(Object.assign({}, message), { status: 'delivered' }));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
        this.onParticipantsRemoved = (event) => {
            const participantIds = event.participantsRemoved.map((participant) => {
                return participant.id;
            });
            this.chatContext.deleteParticipants(event.threadId, participantIds);
            this.fetchLastParticipantMessage(event.threadId, 'participantRemoved');
        };
        this.onReadReceiptReceived = (event) => {
            const readReceipt = Object.assign(Object.assign({}, event), { sender: event.sender, readOn: new Date(event.readOn) });
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.addReadReceipt(event.threadId, readReceipt);
            });
        };
        this.onTypingIndicatorReceived = (typingIndicator) => {
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(typingIndicator.threadId);
                this.chatContext.addTypingIndicator(typingIndicator.threadId, typingIndicator);
            });
        };
        this.onChatThreadCreated = (event) => {
            const properties = {
                topic: event.properties.topic
            };
            if (!this.chatContext.createThreadIfNotExist(event.threadId, properties)) {
                this.chatContext.updateThread(event.threadId, properties);
            }
        };
        this.onChatThreadDeleted = (event) => {
            this.chatContext.deleteThread(event.threadId);
        };
        this.onChatThreadPropertiesUpdated = (event) => {
            this.chatContext.updateThread(event.threadId, { topic: event.properties.topic });
        };
        this.subscribe = () => {
            this.chatClient.on('chatMessageReceived', this.onChatMessageReceived);
            this.chatClient.on('chatMessageDeleted', this.onChatMessageDeleted);
            this.chatClient.on('chatMessageEdited', this.onChatMessageEdited);
            this.chatClient.on('participantsAdded', this.onParticipantsAdded);
            this.chatClient.on('participantsRemoved', this.onParticipantsRemoved);
            this.chatClient.on('readReceiptReceived', this.onReadReceiptReceived);
            this.chatClient.on('typingIndicatorReceived', this.onTypingIndicatorReceived);
            this.chatClient.on('chatThreadCreated', this.onChatThreadCreated);
            this.chatClient.on('chatThreadDeleted', this.onChatThreadDeleted);
            this.chatClient.on('chatThreadPropertiesUpdated', this.onChatThreadPropertiesUpdated);
        };
        this.unsubscribe = () => {
            this.chatClient.off('chatMessageReceived', this.onChatMessageReceived);
            this.chatClient.off('chatMessageDeleted', this.onChatMessageDeleted);
            this.chatClient.off('chatMessageEdited', this.onChatMessageEdited);
            this.chatClient.off('participantsAdded', this.onParticipantsAdded);
            this.chatClient.off('participantsRemoved', this.onParticipantsRemoved);
            this.chatClient.off('readReceiptReceived', this.onReadReceiptReceived);
            this.chatClient.off('typingIndicatorReceived', this.onTypingIndicatorReceived);
            this.chatClient.off('chatThreadCreated', this.onChatThreadCreated);
            this.chatClient.off('chatThreadDeleted', this.onChatThreadDeleted);
            this.chatClient.off('chatThreadPropertiesUpdated', this.onChatThreadPropertiesUpdated);
        };
        this.chatClient = chatClient;
        this.chatContext = chatContext;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$8 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Create a decorated iterator
 * returned iterators.
 *
 * @param iteratorCreator the function to create the original iterator
 * @param context chatContext
 * @param decorateFn the function for the decorating behavior
 */
const createDecoratedIterator = (iteratorCreator, context, decorateFn) => {
    return (...args) => {
        const threadsIterator = iteratorCreator(...args);
        return {
            next() {
                return __awaiter$8(this, void 0, void 0, function* () {
                    const result = yield threadsIterator.next();
                    if (!result.done && result.value) {
                        decorateFn(result.value, context);
                    }
                    return result;
                });
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                const pages = threadsIterator.byPage(settings);
                return {
                    next() {
                        return __awaiter$8(this, void 0, void 0, function* () {
                            const result = yield pages.next();
                            const page = result.value;
                            if (!result.done && result.value) {
                                context.batch(() => {
                                    for (const item of page) {
                                        decorateFn(item, context);
                                    }
                                });
                            }
                            return result;
                        });
                    },
                    [Symbol.asyncIterator]() {
                        return this;
                    }
                };
            }
        };
    };
};
/**
 *
 * @param iteratorCreator Function that creates the base iteartor
 * @param context The ChatContext that stores all internal state.
 * @param target See {@link ChatContext.asyncTeeErrorToState}.
 * @returns A function to create an iterator that handles errors when iterting over the iterator from `iteratorCreator`.
 */
const createErrorHandlingIterator = (iteratorCreator, context, target) => {
    return (...args) => {
        const innerIter = iteratorCreator(...args);
        return {
            next: context.withAsyncErrorTeedToState(innerIter.next.bind(innerIter), target),
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                const pages = innerIter.byPage(settings);
                return {
                    next: context.withAsyncErrorTeedToState(pages.next.bind(pages), target),
                    [Symbol.asyncIterator]() {
                        return this;
                    }
                };
            }
        };
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const createDecoratedListMessages = (chatThreadClient, context) => {
    const setMessage = (message, context) => {
        context.setChatMessage(chatThreadClient.threadId, convertChatMessage(message));
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listMessages.bind(chatThreadClient), 'ChatThreadClient.listMessages'), context, 'ChatThreadClient.listMessages'), context, setMessage);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const createDecoratedListReadReceipts = (chatThreadClient, context) => {
    const setReadReceipt = (readReceipt, context) => {
        context.addReadReceipt(chatThreadClient.threadId, Object.assign({}, readReceipt));
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listReadReceipts.bind(chatThreadClient), 'ChatThreadClient.listReadReceipts'), context, 'ChatThreadClient.listReadReceipts'), context, setReadReceipt);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const createDecoratedListParticipants = (chatThreadClient, context) => {
    const setParticipant = (participant, context) => {
        context.setParticipant(chatThreadClient.threadId, participant);
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listParticipants.bind(chatThreadClient), 'ChatThreadClient.listParticipants'), context, 'ChatThreadClient.listParticipants'), context, setParticipant);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$7 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProxyChatThreadClient {
    constructor(context) {
        this._context = context;
    }
    get(chatThreadClient, prop) {
        switch (prop) {
            case 'listMessages': {
                return createDecoratedListMessages(chatThreadClient, this._context);
            }
            case 'getMessage': {
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$7(this, void 0, void 0, function* () {
                    const message = yield chatThreadClient.getMessage(...args);
                    this._context.setChatMessage(chatThreadClient.threadId, convertChatMessage(message));
                    return message;
                }), 'ChatThreadClient.getMessage');
            }
            case 'sendMessage': {
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$7(this, void 0, void 0, function* () {
                    // Retry logic?
                    const { content } = args[0];
                    const clientMessageId = nanoid.nanoid(); // Generate a local short uuid for message
                    const newMessage = {
                        content: { message: content },
                        clientMessageId,
                        id: '',
                        type: 'text',
                        sequenceId: '',
                        version: '',
                        createdOn: new Date(),
                        status: 'sending',
                        senderDisplayName: this._context.getState().displayName,
                        sender: this._context.getState().userId
                    };
                    this._context.setChatMessage(chatThreadClient.threadId, newMessage);
                    let result = undefined;
                    try {
                        result = yield chatThreadClient.sendMessage(...args);
                    }
                    catch (e) {
                        this._context.setChatMessage(chatThreadClient.threadId, Object.assign(Object.assign({}, newMessage), { status: 'failed' }));
                        throw e;
                    }
                    if (result === null || result === void 0 ? void 0 : result.id) {
                        this._context.batch(() => {
                            if (!result) {
                                return;
                            }
                            this._context.setChatMessage(chatThreadClient.threadId, Object.assign(Object.assign({}, newMessage), { clientMessageId: undefined, status: 'delivered', id: result.id }));
                            this._context.deleteLocalMessage(chatThreadClient.threadId, clientMessageId);
                        });
                    }
                    return result;
                }), 'ChatThreadClient.sendMessage');
            }
            case 'addParticipants': {
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$7(this, void 0, void 0, function* () {
                    const result = yield chatThreadClient.addParticipants(...args);
                    const [addRequest] = args;
                    const participantsToAdd = addRequest.participants;
                    this._context.setParticipants(chatThreadClient.threadId, participantsToAdd);
                    return result;
                }), 'ChatThreadClient.addParticipants');
            }
            case 'deleteMessage': {
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$7(this, void 0, void 0, function* () {
                    // DeleteMessage is able to either delete local one(for failed message) or synced message
                    const [messageId] = args;
                    if (this._context.deleteLocalMessage(chatThreadClient.threadId, messageId)) {
                        return {};
                    }
                    const result = yield chatThreadClient.deleteMessage(...args);
                    this._context.deleteMessage(chatThreadClient.threadId, messageId);
                    return result;
                }), 'ChatThreadClient.deleteMessage');
            }
            case 'listParticipants': {
                return createDecoratedListParticipants(chatThreadClient, this._context);
            }
            case 'listReadReceipts': {
                return createDecoratedListReadReceipts(chatThreadClient, this._context);
            }
            case 'removeParticipant': {
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$7(this, void 0, void 0, function* () {
                    const result = yield chatThreadClient.removeParticipant(...args);
                    const [removeIdentifier] = args;
                    this._context.deleteParticipant(chatThreadClient.threadId, communicationCommon.getIdentifierKind(removeIdentifier));
                    return result;
                }), 'ChatThreadClient.removeParticipant');
            }
            case 'updateMessage': {
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$7(this, void 0, void 0, function* () {
                    const result = yield chatThreadClient.updateMessage(...args);
                    const [messageId, updateOption] = args;
                    this._context.updateChatMessageContent(chatThreadClient.threadId, messageId, updateOption === null || updateOption === void 0 ? void 0 : updateOption.content);
                    return result;
                }), 'ChatThreadClient.updateMessage');
            }
            case 'updateTopic': {
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$7(this, void 0, void 0, function* () {
                    const result = yield chatThreadClient.updateTopic(...args);
                    const [topic] = args;
                    this._context.updateThreadTopic(chatThreadClient.threadId, topic);
                    return result;
                }), 'ChatThreadClient.updateTopic');
            }
            case 'getProperties': {
                return this._context.withAsyncErrorTeedToState((...args) => __awaiter$7(this, void 0, void 0, function* () {
                    const result = yield chatThreadClient.getProperties(...args);
                    this._context.updateThread(chatThreadClient.threadId, result);
                    return result;
                }), 'ChatThreadClient.getProperties');
            }
            default:
                return Reflect.get(chatThreadClient, prop);
        }
    }
}
/**
 * @private
 */
const chatThreadClientDeclaratify = (chatThreadClient, context) => {
    context.createThreadIfNotExist(chatThreadClient.threadId);
    return new Proxy(chatThreadClient, new ProxyChatThreadClient(context));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const createDecoratedListThreads = (chatClient, context) => {
    const setThreadProperties = (chatThreadItem, context) => {
        const properties = {
            topic: chatThreadItem.topic
        };
        if (!context.createThreadIfNotExist(chatThreadItem.id, properties)) {
            context.updateThread(chatThreadItem.id, properties);
        }
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatClient.listChatThreads.bind(chatClient), 'ChatClient.listChatThreads'), context, 'ChatClient.listChatThreads'), context, setThreadProperties);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$6 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const proxyChatClient = {
    get: function (chatClient, prop, receiver) {
        // skip receiver.context call to avoid recursive bugs
        if (prop === 'context') {
            return Reflect.get(chatClient, prop);
        }
        const context = receiver.context;
        switch (prop) {
            case 'createChatThread': {
                return context.withAsyncErrorTeedToState(function (...args) {
                    return __awaiter$6(this, void 0, void 0, function* () {
                        const result = yield chatClient.createChatThread(...args);
                        const thread = result.chatThread;
                        if (thread) {
                            const [request] = args;
                            context.createThread(thread.id, { topic: request.topic });
                        }
                        return result;
                    });
                }, 'ChatClient.createChatThread');
            }
            case 'deleteChatThread': {
                return context.withAsyncErrorTeedToState(function (...args) {
                    return __awaiter$6(this, void 0, void 0, function* () {
                        const result = yield chatClient.deleteChatThread(...args);
                        context.deleteThread(args[0]);
                        return result;
                    });
                }, 'ChatClient.deleteChatThread');
            }
            case 'listChatThreads': {
                return createDecoratedListThreads(chatClient, context);
            }
            case 'getChatThreadClient': {
                return function (...args) {
                    const chatThreadClient = chatClient.getChatThreadClient(...args);
                    // TODO(prprabhu): Ensure that thread properties are fetched into the ChatContext at this point.
                    // A new thread might be created here, but the properties will never be fetched.
                    return chatThreadClientDeclaratify(chatThreadClient, context);
                };
            }
            case 'startRealtimeNotifications': {
                return context.withAsyncErrorTeedToState(function (...args) {
                    return __awaiter$6(this, void 0, void 0, function* () {
                        const ret = yield chatClient.startRealtimeNotifications(...args);
                        if (!receiver.eventSubscriber) {
                            receiver.eventSubscriber = new EventSubscriber(chatClient, context);
                        }
                        return ret;
                    });
                }, 'ChatClient.startRealtimeNotifications');
            }
            case 'stopRealtimeNotifications': {
                return context.withAsyncErrorTeedToState(function (...args) {
                    return __awaiter$6(this, void 0, void 0, function* () {
                        const ret = yield chatClient.stopRealtimeNotifications(...args);
                        if (receiver.eventSubscriber) {
                            receiver.eventSubscriber.unsubscribe();
                            receiver.eventSubscriber = undefined;
                        }
                        return ret;
                    });
                }, 'ChatClient.stopRealtimeNotifications');
            }
            default:
                return Reflect.get(chatClient, prop);
        }
    }
};
/**
 * Creates a stateful ChatClient {@link StatefulChatClient} by proxying ChatClient
 * {@link @azure/communication-chat#ChatClient} with ProxyChatClient {@link ProxyChatClient} which then allows access
 * to state in a declarative way.
 *
 * @public
 */
const createStatefulChatClient = (args, options) => {
    const tweakedOptions = Object.assign(Object.assign({}, options), { chatClientOptions: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.chatClientOptions), { userAgentOptions: { userAgentPrefix: _getApplicationId() } }) });
    return createStatefulChatClientWithDeps(new communicationChat.ChatClient(args.endpoint, args.credential, tweakedOptions.chatClientOptions), args, tweakedOptions);
};
/**
 * Internal implementation of {@link createStatefulChatClient} for dependency injection.
 *
 * Used by tests. Should not be exported out of this package.
 */
const createStatefulChatClientWithDeps = (chatClient, args, options) => {
    const context = new ChatContext$1(options === null || options === void 0 ? void 0 : options.maxStateChangeListeners);
    let eventSubscriber;
    context.updateChatConfig(communicationCommon.getIdentifierKind(args.userId), args.displayName);
    const proxy = new Proxy(chatClient, proxyChatClient);
    Object.defineProperty(proxy, 'context', {
        configurable: false,
        get: () => context
    });
    Object.defineProperty(proxy, 'eventSubscriber', {
        configurable: false,
        get: () => eventSubscriber,
        set: (val) => {
            eventSubscriber = val;
        }
    });
    Object.defineProperty(proxy, 'getState', {
        configurable: false,
        value: () => context === null || context === void 0 ? void 0 : context.getState()
    });
    Object.defineProperty(proxy, 'onStateChange', {
        configurable: false,
        value: (handler) => context === null || context === void 0 ? void 0 : context.onStateChange(handler)
    });
    Object.defineProperty(proxy, 'offStateChange', {
        configurable: false,
        value: (handler) => context === null || context === void 0 ? void 0 : context.offStateChange(handler)
    });
    return proxy;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$5 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (window && window.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
/** Context of Chat, which is a centralized context for all state updates */
class ChatContext {
    constructor(clientState, threadId) {
        this.emitter = new EventEmitter__default['default']();
        const thread = clientState.threads[threadId];
        this.threadId = threadId;
        if (!thread) {
            throw 'Cannot find threadId, please initialize thread before use!';
        }
        this.state = {
            userId: clientState.userId,
            displayName: clientState.displayName,
            thread,
            latestErrors: clientState.latestErrors
        };
    }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    setError(error) {
        this.setState(Object.assign(Object.assign({}, this.state), { error }));
    }
    updateClientState(clientState) {
        const thread = clientState.threads[this.threadId];
        if (!thread) {
            throw 'Cannot find threadId, please make sure thread state is still in Stateful ChatClient.';
        }
        this.setState({
            userId: clientState.userId,
            displayName: clientState.displayName,
            thread,
            latestErrors: clientState.latestErrors
        });
    }
}
/**
 * @private
 */
class AzureCommunicationChatAdapter {
    constructor(chatClient, chatThreadClient) {
        this.emitter = new EventEmitter__default['default']();
        this.bindAllPublicMethods();
        this.chatClient = chatClient;
        this.chatThreadClient = chatThreadClient;
        this.context = new ChatContext(chatClient.getState(), chatThreadClient.threadId);
        const onStateChange = (clientState) => {
            // unsubscribe when the instance gets disposed
            if (!this) {
                chatClient.offStateChange(onStateChange);
                return;
            }
            this.context.updateClientState(clientState);
        };
        this.handlers = createDefaultChatHandlers(chatClient, chatThreadClient);
        this.chatClient.onStateChange(onStateChange);
        this.subscribeAllEvents();
    }
    bindAllPublicMethods() {
        this.onStateChange = this.onStateChange.bind(this);
        this.offStateChange = this.offStateChange.bind(this);
        this.getState = this.getState.bind(this);
        this.dispose = this.dispose.bind(this);
        this.fetchInitialData = this.fetchInitialData.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.sendReadReceipt = this.sendReadReceipt.bind(this);
        this.sendTypingIndicator = this.sendTypingIndicator.bind(this);
        this.updateMessage = this.updateMessage.bind(this);
        this.deleteMessage = this.deleteMessage.bind(this);
        this.removeParticipant = this.removeParticipant.bind(this);
        this.setTopic = this.setTopic.bind(this);
        this.loadPreviousChatMessages = this.loadPreviousChatMessages.bind(this);
        this.on = this.on.bind(this);
        this.off = this.off.bind(this);
    }
    dispose() {
        this.unsubscribeAllEvents();
    }
    fetchInitialData() {
        var e_1, _a;
        return __awaiter$5(this, void 0, void 0, function* () {
            try {
                yield this.chatThreadClient.getProperties();
            }
            catch (e) {
                console.log(e);
            }
            // Fetch all participants who joined before the local user.
            try {
                try {
                    for (var _b = __asyncValues(this.chatThreadClient.listParticipants().byPage({
                        // Fetch 100 participants per page by default.
                        maxPageSize: 100
                        // eslint-disable-next-line curly
                    })), _c; _c = yield _b.next(), !_c.done;) {
                        const _page = _c.value;
                        ;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            catch (e) {
                console.log(e);
            }
        });
    }
    getState() {
        return this.context.getState();
    }
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    sendMessage(content) {
        return __awaiter$5(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.onSendMessage(content);
            }));
        });
    }
    sendReadReceipt(chatMessageId) {
        return __awaiter$5(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.onMessageSeen(chatMessageId);
            }));
        });
    }
    sendTypingIndicator() {
        return __awaiter$5(this, void 0, void 0, function* () {
            yield this.handlers.onTyping();
        });
    }
    removeParticipant(userId) {
        return __awaiter$5(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.onRemoveParticipant(userId);
            }));
        });
    }
    setTopic(topicName) {
        return __awaiter$5(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.updateThreadTopicName(topicName);
            }));
        });
    }
    loadPreviousChatMessages(messagesToLoad) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                return yield this.handlers.onLoadPreviousChatMessages(messagesToLoad);
            }));
        });
    }
    updateMessage(messageId, content) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                return yield this.handlers.onUpdateMessage(messageId, content);
            }));
        });
    }
    deleteMessage(messageId) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                return yield this.handlers.onDeleteMessage(messageId);
            }));
        });
    }
    messageReceivedListener(event) {
        const message = convertEventToChatMessage(event);
        this.emitter.emit('messageReceived', { message });
        const currentUserId = toFlatCommunicationIdentifier(this.chatClient.getState().userId);
        if ((message === null || message === void 0 ? void 0 : message.sender) && toFlatCommunicationIdentifier(message.sender) === currentUserId) {
            this.emitter.emit('messageSent', { message });
        }
    }
    messageReadListener({ chatMessageId, recipient }) {
        const message = this.getState().thread.chatMessages[chatMessageId];
        if (message) {
            this.emitter.emit('messageRead', { message, readBy: recipient });
        }
    }
    participantsAddedListener({ addedBy, participantsAdded }) {
        this.emitter.emit('participantsAdded', { addedBy, participantsAdded });
    }
    participantsRemovedListener({ removedBy, participantsRemoved }) {
        this.emitter.emit('participantsRemoved', { removedBy, participantsRemoved });
    }
    chatThreadPropertiesUpdatedListener(event) {
        this.emitter.emit('topicChanged', { topic: event.properties.topic });
    }
    subscribeAllEvents() {
        this.chatClient.on('chatThreadPropertiesUpdated', this.chatThreadPropertiesUpdatedListener.bind(this));
        this.chatClient.on('participantsAdded', this.participantsAddedListener.bind(this));
        this.chatClient.on('participantsRemoved', this.participantsRemovedListener.bind(this));
        this.chatClient.on('chatMessageReceived', this.messageReceivedListener.bind(this));
        this.chatClient.on('readReceiptReceived', this.messageReadListener.bind(this));
        this.chatClient.on('participantsRemoved', this.participantsRemovedListener.bind(this));
    }
    unsubscribeAllEvents() {
        this.chatClient.off('chatThreadPropertiesUpdated', this.chatThreadPropertiesUpdatedListener.bind(this));
        this.chatClient.off('participantsAdded', this.participantsAddedListener.bind(this));
        this.chatClient.off('participantsRemoved', this.participantsRemovedListener.bind(this));
        this.chatClient.off('chatMessageReceived', this.messageReceivedListener.bind(this));
        this.chatClient.off('readReceiptReceived', this.messageReadListener.bind(this));
        this.chatClient.off('participantsRemoved', this.participantsRemovedListener.bind(this));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    off(event, listener) {
        this.emitter.off(event, listener);
    }
    asyncTeeErrorToEventEmitter(f) {
        return __awaiter$5(this, void 0, void 0, function* () {
            try {
                return yield f();
            }
            catch (error) {
                if (isChatError(error)) {
                    this.emitter.emit('error', error);
                }
                throw error;
            }
        });
    }
}
const convertEventToChatMessage = (event) => {
    return {
        id: event.id,
        version: event.version,
        content: { message: event.message },
        type: convertEventType(event.type),
        sender: event.sender,
        senderDisplayName: event.senderDisplayName,
        sequenceId: '',
        createdOn: new Date(event.createdOn)
    };
};
// only text/html message type will be received from event
const convertEventType = (type) => {
    const lowerCaseType = type.toLowerCase();
    if (lowerCaseType === 'richtext/html' || lowerCaseType === 'html') {
        return 'html';
    }
    else {
        return 'text';
    }
};
/**
 * Create a {@link ChatAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link ChatAdapter} provided by this library.
 *
 * @public
 */
const createAzureCommunicationChatAdapter = ({ endpoint: endpointUrl, userId, displayName, credential, threadId }) => __awaiter$5(void 0, void 0, void 0, function* () {
    const chatClient = createStatefulChatClient({
        userId,
        displayName,
        endpoint: endpointUrl,
        credential: credential
    });
    const chatThreadClient = yield chatClient.getChatThreadClient(threadId);
    yield chatClient.startRealtimeNotifications();
    const adapter = yield createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient);
    yield adapter.fetchInitialData();
    return adapter;
});
/**
 * Create a {@link ChatAdapter} using the provided {@link StatefulChatClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulChatClient}.
 * Consider using {@link createAzureCommunicationChatAdapter} for a simpler API.
 *
 * @public
 */
const createAzureCommunicationChatAdapterFromClient = (chatClient, chatThreadClient) => __awaiter$5(void 0, void 0, void 0, function* () {
    return new AzureCommunicationChatAdapter(chatClient, chatThreadClient);
});
const isChatError = (e) => {
    return e['target'] !== undefined && e['innerError'] !== undefined;
};

var call$d={cameraLabel:"Camera",cameraPermissionDenied:"Your browser is blocking access to your camera",cameraTurnedOff:"Your camera is turned off",close:"Close",complianceBannerNowOnlyRecording:"You are now only recording this meeting.",complianceBannerNowOnlyTranscription:"You are now only transcribing this meeting.",complianceBannerRecordingAndTranscriptionSaved:"Recording and transcription are being saved.",complianceBannerRecordingAndTranscriptionStarted:"Recording and transcription have started.",complianceBannerRecordingAndTranscriptionStopped:"Recording and transcription have stopped.",complianceBannerRecordingSaving:"Recording is being saved.",complianceBannerRecordingStarted:"Recording has started.",complianceBannerRecordingStopped:"Recording has stopped.",complianceBannerTranscriptionStarted:"Transcription has started.",complianceBannerTranscriptionConsent:"By joining, you are giving consent for this meeting to be transcribed.",complianceBannerTranscriptionSaving:"Transcription is being saved.",complianceBannerTranscriptionStopped:"Transcription has stopped.",configurationPageTitle:"Start a call",defaultPlaceHolder:"Select an option",failedToJoinCallDueToNoNetworkMoreDetails:"Call was disconnected due to a network issue. Check your connection and join again.",failedToJoinCallDueToNoNetworkTitle:"Call disconnected",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"You were not granted entry in the call. If this was a mistake, re-join the call.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Dismissed from lobby",learnMore:"Learn more",leftCallMoreDetails:"If this was a mistake, re-join the call.",leftCallTitle:"You left the call",lobbyScreenConnectingToCallTitle:"Joining call",lobbyScreenWaitingToBeAdmittedTitle:"Waiting to be admitted",microphonePermissionDenied:"Your browser is blocking access to your microphone",mutedMessage:"You're muted",networkReconnectMoreDetails:"Looks like something went wrong. We're trying to get back into the call.",networkReconnectTitle:"Hold on",privacyPolicy:"Privacy policy",rejoinCallButtonLabel:"Re-join call",removedFromCallMoreDetails:"Another participant removed you from the call.",removedFromCallTitle:"You were removed",soundLabel:"Sound",startCallButtonLabel:"Start call",microphoneToggleInLobbyNotAllowed:"Cannot mute or unmute while in lobby."};var chat$d={chatListHeader:"In this chat"};var en_US = {call:call$d,chat:chat$d};

var call$c={cameraLabel:"Camera",cameraPermissionDenied:"Your browser is blocking access to your camera",cameraTurnedOff:"Your camera is turned off",close:"Close",complianceBannerNowOnlyRecording:"You are now only recording this meeting.",complianceBannerNowOnlyTranscription:"You are now only transcribing this meeting.",complianceBannerRecordingAndTranscriptionSaved:"Recording and transcription are being saved.",complianceBannerRecordingAndTranscriptionStarted:"Recording and transcription have started.",complianceBannerRecordingAndTranscriptionStopped:"Recording and transcription have stopped.",complianceBannerRecordingSaving:"Recording is being saved.",complianceBannerRecordingStarted:"Recording has started.",complianceBannerRecordingStopped:"Recording has stopped.",complianceBannerTranscriptionStarted:"Transcription has started.",complianceBannerTranscriptionConsent:"By joining, you are giving consent for this meeting to be transcribed.",complianceBannerTranscriptionSaving:"Transcription is being saved.",complianceBannerTranscriptionStopped:"Transcription has stopped.",configurationPageTitle:"Start a call",defaultPlaceHolder:"Select an option",failedToJoinCallDueToNoNetworkMoreDetails:"Call was disconnected due to a network issue. Check your connection and join again.",failedToJoinCallDueToNoNetworkTitle:"Call disconnected",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"You were not granted entry in the call. If this was a mistake, re-join the call.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Dismissed from lobby",learnMore:"Learn more",leftCallMoreDetails:"If this was a mistake, re-join the call.",leftCallTitle:"You left the call",lobbyScreenConnectingToCallTitle:"Joining call",lobbyScreenWaitingToBeAdmittedTitle:"Waiting to be admitted",microphonePermissionDenied:"Your browser is blocking access to your microphone",mutedMessage:"You're muted",networkReconnectMoreDetails:"Looks like something went wrong. We're trying to get back into the call.",networkReconnectTitle:"Hold on",privacyPolicy:"Privacy policy",rejoinCallButtonLabel:"Re-join call",removedFromCallMoreDetails:"Another participant removed you from the call.",removedFromCallTitle:"You were removed",soundLabel:"Sound",startCallButtonLabel:"Start call",microphoneToggleInLobbyNotAllowed:"Cannot mute or unmute while in lobby."};var chat$c={chatListHeader:"In this chat"};var en_GB = {call:call$c,chat:chat$c};

var call$b={cameraLabel:"Kamera",cameraPermissionDenied:"Ihr Browser blockiert den Zugriff auf Ihre Kamera.",cameraTurnedOff:"Ihre Kamera ist deaktiviert.",close:"Schließen",complianceBannerNowOnlyRecording:"Sie zeichnen nun nur diese Besprechung auf.",complianceBannerNowOnlyTranscription:"Sie transkribieren diese Besprechung jetzt nur noch.",complianceBannerRecordingAndTranscriptionSaved:"Aufzeichnung und Transkription werden gespeichert.",complianceBannerRecordingAndTranscriptionStarted:"Die Aufzeichnung und Transkription haben begonnen.",complianceBannerRecordingAndTranscriptionStopped:"Die Aufzeichnung und Transkription wurden beendet.",complianceBannerRecordingSaving:"Aufzeichnung wird gespeichert.",complianceBannerRecordingStarted:"Die Aufzeichnung wurde gestartet.",complianceBannerRecordingStopped:"Aufzeichnung wurde beendet.",complianceBannerTranscriptionStarted:"Die Transkription hat begonnen.",complianceBannerTranscriptionConsent:"Durch Ihre Teilnahme stimmen Sie zu, dass diese Besprechung transkribiert wird.",complianceBannerTranscriptionSaving:"Die Transkription wird gespeichert.",complianceBannerTranscriptionStopped:"Die Transkription wurde beendet.",configurationPageTitle:"Einen Anruf beginnen",defaultPlaceHolder:"Option auswählen",failedToJoinCallDueToNoNetworkMoreDetails:"Der Anruf wurde aufgrund eines Netzwerkproblems getrennt. Überprüfen Sie Ihre Verbindung, und treten Sie erneut bei.",failedToJoinCallDueToNoNetworkTitle:"Anruf unterbrochen",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Ihnen wurde keine Teilnahme am Anruf gewährt. Wenn dies ein Fehler war, treten Sie dem Anruf erneut bei.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Aus Wartebereich entlassen",learnMore:"Weitere Informationen",leftCallMoreDetails:"Wenn dies ein Fehler war, nehmen Sie erneut am Anruf teil.",leftCallTitle:"Sie haben den Anruf verlassen",lobbyScreenConnectingToCallTitle:"Teilnehmen am Anruf",lobbyScreenWaitingToBeAdmittedTitle:"Warten auf die Zulassung",microphonePermissionDenied:"Ihr Browser blockiert den Zugriff auf Ihr Mikrofon.",mutedMessage:"Sie sind stummgeschaltet.",networkReconnectMoreDetails:"Offensichtlich ist etwas schief gegangen. Wir versuchen, Sie wieder mit dem Anruf zu verbinden.",networkReconnectTitle:"Einen Augenblick bitte",privacyPolicy:"Datenschutzrichtlinie",rejoinCallButtonLabel:"Am Anruf erneut teilnehmen",removedFromCallMoreDetails:"Ein anderer Teilnehmer hat Sie aus dem Anruf entfernt.",removedFromCallTitle:"Sie wurden entfernt",soundLabel:"Sound",startCallButtonLabel:"Anruf beginnen",microphoneToggleInLobbyNotAllowed:"Stummschalten oder Aufheben der Stummschaltung im Wartebereich nicht zulässig."};var chat$b={chatListHeader:"In diesem Chat"};var de_DE = {call:call$b,chat:chat$b};

var call$a={cameraLabel:"Cámara",cameraPermissionDenied:"El explorador está bloqueando el acceso a la cámara",cameraTurnedOff:"La cámara está apagada",close:"Cerrar",complianceBannerNowOnlyRecording:"Solo está grabando esta reunión.",complianceBannerNowOnlyTranscription:"Solo está transcribiendo esta reunión.",complianceBannerRecordingAndTranscriptionSaved:"Se están guardando la grabación y la transcripción.",complianceBannerRecordingAndTranscriptionStarted:"Se han iniciado la grabación y la transcripción.",complianceBannerRecordingAndTranscriptionStopped:"Se han detenido la grabación y la transcripción.",complianceBannerRecordingSaving:"La grabación se está guardando.",complianceBannerRecordingStarted:"Se ha iniciado la grabación.",complianceBannerRecordingStopped:"La grabación se ha detenido.",complianceBannerTranscriptionStarted:"La transcripción se ha iniciado.",complianceBannerTranscriptionConsent:"Al unirse, da su consentimiento para que se transcriba esta reunión.",complianceBannerTranscriptionSaving:"Se está guardando la transcripción.",complianceBannerTranscriptionStopped:"La transcripción se ha detenido.",configurationPageTitle:"Iniciar una llamada",defaultPlaceHolder:"Seleccionar una opción",failedToJoinCallDueToNoNetworkMoreDetails:"Se desconectó la llamada debido a un problema de red. Compruebe la conexión y únase de nuevo.",failedToJoinCallDueToNoNetworkTitle:"Llamada desconectada",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"No se te concedió la entrada a la llamada. Si se trata de un error, vuelve a unirte.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Rechazado de la sala de espera",learnMore:"Más información",leftCallMoreDetails:"Si se trata de un error, vuelve a unirte a la llamada.",leftCallTitle:"Has abandonado la llamada",lobbyScreenConnectingToCallTitle:"Uniéndose a la llamada",lobbyScreenWaitingToBeAdmittedTitle:"Esperando a ser admitido",microphonePermissionDenied:"El explorador está bloqueando el acceso al micrófono",mutedMessage:"Estás silenciado",networkReconnectMoreDetails:"Parece que hubo un problema. Estamos intentando reconectar la llamada.",networkReconnectTitle:"Espere",privacyPolicy:"Directiva de privacidad",rejoinCallButtonLabel:"Volver a unirse a la llamada",removedFromCallMoreDetails:"Otro participante te ha eliminado de la llamada.",removedFromCallTitle:"Fuiste eliminado",soundLabel:"Sonido",startCallButtonLabel:"Iniciar llamada",microphoneToggleInLobbyNotAllowed:"No se puede silenciar ni reactivar el audio mientras se está en la sala de espera."};var chat$a={chatListHeader:"En este chat"};var es_ES = {call:call$a,chat:chat$a};

var call$9={cameraLabel:"Appareil photo",cameraPermissionDenied:"Votre navigateur bloque l’accès à votre caméra",cameraTurnedOff:"Votre caméra est désactivée",close:"Fermer",complianceBannerNowOnlyRecording:"Vous n’enregistrez désormais que cette réunion.",complianceBannerNowOnlyTranscription:"À présent, vous ne transcrivez que cette réunion.",complianceBannerRecordingAndTranscriptionSaved:"Sauvegarde en cours de l’enregistrement et de la transcription.",complianceBannerRecordingAndTranscriptionStarted:"Démarrage de l’enregistrement et de la transcription.",complianceBannerRecordingAndTranscriptionStopped:"L’enregistrement et la transcription ont pris fin.",complianceBannerRecordingSaving:"Sauvegarde en cours de l'enregistrement.",complianceBannerRecordingStarted:"L’enregistrement a démarré.",complianceBannerRecordingStopped:"L’enregistrement a pris fin.",complianceBannerTranscriptionStarted:"Démarrage de la transcription.",complianceBannerTranscriptionConsent:"En participant, vous autorisez la transcription de cette réunion.",complianceBannerTranscriptionSaving:"Sauvegarde en cours de la transcription.",complianceBannerTranscriptionStopped:"La transcription a pris fin.",configurationPageTitle:"Lancer un appel",defaultPlaceHolder:"Sélectionnez une option",failedToJoinCallDueToNoNetworkMoreDetails:"L’appel a été déconnecté en raison d’un problème réseau. Vérifiez votre connexion et rejoignez-la à nouveau.",failedToJoinCallDueToNoNetworkTitle:"Appel déconnecté",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Vous n’avez pas reçu d’entrée dans l’appel. S’il s’agissait d’une erreur, rejoignez à nouveau l’appel.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Rejeté de la salle d’attente",learnMore:"En savoir plus",leftCallMoreDetails:"S’il s’agissait d’une erreur, rejoignez à nouveau l’appel.",leftCallTitle:"Vous avez quitté l’appel.",lobbyScreenConnectingToCallTitle:"Connexion à l'appel",lobbyScreenWaitingToBeAdmittedTitle:"En attente d’admission",microphonePermissionDenied:"Votre navigateur bloque l’accès à votre micro",mutedMessage:"Le son de votre micro est désactivé.",networkReconnectMoreDetails:"On dirait qu'une erreur est survenue. Nous tentons de vous reconnecter à l’appel.",networkReconnectTitle:"Patience",privacyPolicy:"Politique de confidentialité",rejoinCallButtonLabel:"Rejoindre l’appel à nouveau.",removedFromCallMoreDetails:"Un autre participant vous a supprimé de l’appel.",removedFromCallTitle:"Vous avez été supprimé.",soundLabel:"Son",startCallButtonLabel:"Lancer l'appel",microphoneToggleInLobbyNotAllowed:"Impossible de désactiver ou d’activer le son dans la salle d’attente."};var chat$9={chatListHeader:"Dans cette conversation"};var fr_FR = {call:call$9,chat:chat$9};

var call$8={cameraLabel:"Fotocamera",cameraPermissionDenied:"Il browser blocca l'accesso alla fotocamera",cameraTurnedOff:"La videocamera è disabilitata",close:"Chiudi",complianceBannerNowOnlyRecording:"È in corso la registrazione solo di questa riunione.",complianceBannerNowOnlyTranscription:"È in corso la trascrizione solo di questa riunione.",complianceBannerRecordingAndTranscriptionSaved:"È in corso il salvataggio della registrazione e della trascrizione.",complianceBannerRecordingAndTranscriptionStarted:"Registrazione e trascrizione avviate.",complianceBannerRecordingAndTranscriptionStopped:"Registrazione e trascrizione interrotte.",complianceBannerRecordingSaving:"Salvataggio della registrazione in corso.",complianceBannerRecordingStarted:"Registrazione avviata.",complianceBannerRecordingStopped:"Registrazione arrestata.",complianceBannerTranscriptionStarted:"Trascrizione avviata.",complianceBannerTranscriptionConsent:"Partecipando, fornisci il consenso per la trascrizione di questa riunione.",complianceBannerTranscriptionSaving:"È in corso il salvataggio della trascrizione.",complianceBannerTranscriptionStopped:"Trascrizione interrotta.",configurationPageTitle:"Avvia una chiamata",defaultPlaceHolder:"Seleziona un'opzione",failedToJoinCallDueToNoNetworkMoreDetails:"La chiamata è stata disconnessa a causa di un problema di rete. Controlla la connessione e partecipa di nuovo.",failedToJoinCallDueToNoNetworkTitle:"Chiamata interrotta",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Non ti è stato concesso l’accesso alla chiamata. Se si è trattato di un errore, partecipa di nuovo alla chiamata.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Ignorato dalla sala di attesa",learnMore:"Ulteriori informazioni",leftCallMoreDetails:"Se si è trattato di un errore, partecipa di nuovo alla chiamata.",leftCallTitle:"Hai abbandonato la chiamata",lobbyScreenConnectingToCallTitle:"Partecipazione alla chiamata",lobbyScreenWaitingToBeAdmittedTitle:"In attesa di essere ammessi",microphonePermissionDenied:"Il browser blocca l'accesso al microfono",mutedMessage:"L'audio è disattivato.",networkReconnectMoreDetails:"Sembra si sia verificato un errore. Stiamo cercando di ristabilire la connessione alla chiamata.",networkReconnectTitle:"Attendi",privacyPolicy:"Informativa sulla privacy",rejoinCallButtonLabel:"Partecipa alla chiamata",removedFromCallMoreDetails:"Un altro partecipante ti ha rimosso dalla chiamata.",removedFromCallTitle:"Sei stato rimosso",soundLabel:"Suono",startCallButtonLabel:"Avvia chiamata",microphoneToggleInLobbyNotAllowed:"Impossibile attivare o disattivare l'audio nella sala di attesa."};var chat$8={chatListHeader:"In questa chat"};var it_IT = {call:call$8,chat:chat$8};

var call$7={cameraLabel:"カメラ",cameraPermissionDenied:"お使いのブラウザーがカメラへのアクセスをブロックしています",cameraTurnedOff:"カメラはオフになっています",close:"閉じる",complianceBannerNowOnlyRecording:"今はこの会議の録画のみを行っています。",complianceBannerNowOnlyTranscription:"この会議のトランスクリプトを作成しています。",complianceBannerRecordingAndTranscriptionSaved:"レコーディングとトランスクリプトを保存されました。",complianceBannerRecordingAndTranscriptionStarted:"レコーディングとトランスクリプトが開始されました。",complianceBannerRecordingAndTranscriptionStopped:"レコーディングとトランスクリプトを停止しました。",complianceBannerRecordingSaving:"レコーディングを保存しています。",complianceBannerRecordingStarted:"レコーディングを開始しました。",complianceBannerRecordingStopped:"レコーディングを停止しました。",complianceBannerTranscriptionStarted:"トランスクリプトが開始しました。",complianceBannerTranscriptionConsent:"参加すると、この会議のトランスクリプトの作成に同意したことになります。",complianceBannerTranscriptionSaving:"トランスクリプトを保存されました。",complianceBannerTranscriptionStopped:"トランスクリプトが停止しました。",configurationPageTitle:"通話を開始",defaultPlaceHolder:"オプションを選択する",failedToJoinCallDueToNoNetworkMoreDetails:"ネットワークの問題により、通話が切断されました。接続を確認して、もう一度参加してください。",failedToJoinCallDueToNoNetworkTitle:"通話が切断されました",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"通話のエントリが許可されませんでした。これが間違いだった場合は、通話に再参加してください。",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"ロビーから消去しました",learnMore:"詳細情報",leftCallMoreDetails:"これが間違いだった場合は、通話に再度参加してください。",leftCallTitle:"通話を終了しました",lobbyScreenConnectingToCallTitle:"通話に参加中",lobbyScreenWaitingToBeAdmittedTitle:"承認待機中",microphonePermissionDenied:"お使いのブラウザーがマイクへのアクセスをブロックしています",mutedMessage:"ミュートになっています",networkReconnectMoreDetails:"問題が発生したようです。通話に戻ろうとしています。",networkReconnectTitle:"お待ちください",privacyPolicy:"プライバシー ポリシー",rejoinCallButtonLabel:"通話に再度参加",removedFromCallMoreDetails:"別の参加者があなたを通話から削除しました。",removedFromCallTitle:"削除されました",soundLabel:"音声",startCallButtonLabel:"通話を開始",microphoneToggleInLobbyNotAllowed:"ロビーにいる間はミュートまたはミュート解除できません。"};var chat$7={chatListHeader:"このチャット内"};var ja_JP = {call:call$7,chat:chat$7};

var call$6={cameraLabel:"카메라",cameraPermissionDenied:"브라우저에서 카메라에 대한 액세스를 차단하고 있습니다.",cameraTurnedOff:"카메라가 꺼져 있음",close:"닫기",complianceBannerNowOnlyRecording:"이제 이 모임의 녹음/녹화만 진행합니다.",complianceBannerNowOnlyTranscription:"이제 이 모임의 전사만 진행합니다.",complianceBannerRecordingAndTranscriptionSaved:"녹음/녹화와 전사를 저장하는 중입니다.",complianceBannerRecordingAndTranscriptionStarted:"녹음/녹화와 전사를 시작했습니다.",complianceBannerRecordingAndTranscriptionStopped:"녹음/녹화와 전사를 중단했습니다.",complianceBannerRecordingSaving:"녹음/녹화를 저장하는 중입니다.",complianceBannerRecordingStarted:"녹음/녹화를 시작했습니다.",complianceBannerRecordingStopped:"녹음/녹화를 중단했습니다.",complianceBannerTranscriptionStarted:"전사를 시작했습니다.",complianceBannerTranscriptionConsent:"참가하면 이 모임이 전사되는 것에 동의하게 됩니다.",complianceBannerTranscriptionSaving:"전사를 저장하는 중입니다.",complianceBannerTranscriptionStopped:"전사를 중단했습니다.",configurationPageTitle:"통화 시작",defaultPlaceHolder:"옵션 선택",failedToJoinCallDueToNoNetworkMoreDetails:"네트워크 문제로 인해 통화 연결이 끊어졌습니다. 연결을 확인하고 다시 참가하세요.",failedToJoinCallDueToNoNetworkTitle:"통화 연결 끊김",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"통화에 참가할 수 있는 권한이 없습니다. 실수라면 통화에 다시 참가하세요.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"대기실에서 해제됐습니다.",learnMore:"자세한 정보",leftCallMoreDetails:"실수라면 통화에 다시 참가하세요.",leftCallTitle:"통화를 종료했습니다.",lobbyScreenConnectingToCallTitle:"통화에 참가",lobbyScreenWaitingToBeAdmittedTitle:"승인을 기다리는 중",microphonePermissionDenied:"브라우저에서 마이크에 대한 액세스를 차단하고 있습니다.",mutedMessage:"음소거 되었습니다.",networkReconnectMoreDetails:"문제가 발생한 것 같습니다. 통화에 다시 연결하려고 합니다.",networkReconnectTitle:"잠시만",privacyPolicy:"개인 정보 취급 방침",rejoinCallButtonLabel:"통화 다시 참가",removedFromCallMoreDetails:"다른 참가자가 귀하를 통화에서 제거했습니다.",removedFromCallTitle:"통화에서 제거됐습니다.",soundLabel:"소리",startCallButtonLabel:"통화 시작",microphoneToggleInLobbyNotAllowed:"대기실에 있는 동안에는 음소거하거나 음소거를 해제할 수 없습니다."};var chat$6={chatListHeader:"채팅 참가자"};var ko_KR = {call:call$6,chat:chat$6};

var call$5={cameraLabel:"Camera",cameraPermissionDenied:"Uw browser blokkeert de toegang tot uw camera",cameraTurnedOff:"Camera is uitgeschakeld",close:"Sluiten",complianceBannerNowOnlyRecording:"U bent nu alleen deze vergadering aan het opnemen.",complianceBannerNowOnlyTranscription:"U bent nu alleen deze vergadering aan het transcriberen.",complianceBannerRecordingAndTranscriptionSaved:"Opname en transcriptie worden opgeslagen.",complianceBannerRecordingAndTranscriptionStarted:"Opname en transcriptie zijn gestart.",complianceBannerRecordingAndTranscriptionStopped:"Opname en transcriptie zijn gestopt.",complianceBannerRecordingSaving:"De opname wordt opgeslagen.",complianceBannerRecordingStarted:"De opname is gestart.",complianceBannerRecordingStopped:"De opname is gestopt.",complianceBannerTranscriptionStarted:"Transcriptie is gestart.",complianceBannerTranscriptionConsent:"Door deel te nemen, geeft u toestemming voor het transcriberen van deze vergadering.",complianceBannerTranscriptionSaving:"Transcriptie wordt opgeslagen.",complianceBannerTranscriptionStopped:"Transcriptie is gestopt.",configurationPageTitle:"Een oproep starten",defaultPlaceHolder:"Een optie selecteren",failedToJoinCallDueToNoNetworkMoreDetails:"De verbinding is verbroken vanwege een netwerkprobleem. Controleer de verbinding en neem opnieuw deel.",failedToJoinCallDueToNoNetworkTitle:"Verbinding verbroken",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"U hebt geen toegang gekregen in het gesprek. Als dit een fout is, neemt u opnieuw deel aan het gesprek.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Verwijderd uit lobby",learnMore:"Meer informatie",leftCallMoreDetails:"Als dit een vergissing was, neemt u opnieuw deel aan het gesprek.",leftCallTitle:"U hebt het gesprek verlaten",lobbyScreenConnectingToCallTitle:"Deelnemen aan oproep",lobbyScreenWaitingToBeAdmittedTitle:"Wachten om te worden toegelaten",microphonePermissionDenied:"Uw browser blokkeert de toegang tot uw microfoon",mutedMessage:"Uw geluid is gedempt",networkReconnectMoreDetails:"Er is iets misgegaan. We proberen terug te gaan naar het gesprek.",networkReconnectTitle:"Wacht even",privacyPolicy:"Privacybeleid",rejoinCallButtonLabel:"Opnieuw deelnemen aan gesprek",removedFromCallMoreDetails:"Een andere deelnemer heeft u uit het gesprek verwijderd.",removedFromCallTitle:"U bent verwijderd",soundLabel:"Geluid",startCallButtonLabel:"Gesprek starten",microphoneToggleInLobbyNotAllowed:"Kan niet dempen of dempen opheffen in de lobby."};var chat$5={chatListHeader:"In deze chat"};var nl_NL = {call:call$5,chat:chat$5};

var call$4={cameraLabel:"Câmera",cameraPermissionDenied:"Seu navegador está bloqueando o acesso à câmera",cameraTurnedOff:"Sua câmera está desativada",close:"Fechar",complianceBannerNowOnlyRecording:"Você agora está apenas gravando esta reunião.",complianceBannerNowOnlyTranscription:"Você agora está apenas transcrevendo esta reunião.",complianceBannerRecordingAndTranscriptionSaved:"A gravação e a transcrição estão sendo salvas.",complianceBannerRecordingAndTranscriptionStarted:"A gravação e a transcrição foram iniciadas.",complianceBannerRecordingAndTranscriptionStopped:"A gravação e a transcrição foram interrompidas.",complianceBannerRecordingSaving:"A gravação está sendo salva.",complianceBannerRecordingStarted:"A gravação foi iniciada.",complianceBannerRecordingStopped:"A gravação foi interrompida.",complianceBannerTranscriptionStarted:"A transcrição foi iniciada.",complianceBannerTranscriptionConsent:"Ao ingressar, você está dando consentimento para que esta reunião seja transcrita.",complianceBannerTranscriptionSaving:"A transcrição está sendo salva.",complianceBannerTranscriptionStopped:"A transcrição foi interrompida.",configurationPageTitle:"Iniciar uma chamada",defaultPlaceHolder:"Selecionar uma opção",failedToJoinCallDueToNoNetworkMoreDetails:"A chamada foi desconectada devido a um problema de rede. Verifique sua conexão e ingresse novamente.",failedToJoinCallDueToNoNetworkTitle:"Chamada desconectada",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Você não recebeu entrada na chamada. Se isso foi um erro, ingresse novamente na chamada.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Ignorado do lobby",learnMore:"Saber mais",leftCallMoreDetails:"Se isso foi um erro, ingresse novamente na chamada.",leftCallTitle:"Você saiu da chamada",lobbyScreenConnectingToCallTitle:"Ingressando na chamada",lobbyScreenWaitingToBeAdmittedTitle:"Esperando para ser admitido",microphonePermissionDenied:"Seu navegador está bloqueando o acesso ao microfone",mutedMessage:"Você está com o mudo ativado",networkReconnectMoreDetails:"Parece que algo deu errado. Estamos tentando retornar à chamada.",networkReconnectTitle:"Em espera",privacyPolicy:"Política de privacidade",rejoinCallButtonLabel:"Reingressar na chamada",removedFromCallMoreDetails:"Outro participante removeu você da chamada.",removedFromCallTitle:"Você foi removido",soundLabel:"Som",startCallButtonLabel:"Iniciar chamada",microphoneToggleInLobbyNotAllowed:"Não é possível ativar ou desativar mudo enquanto estiver no lobby."};var chat$4={chatListHeader:"Neste chat"};var pt_BR = {call:call$4,chat:chat$4};

var call$3={cameraLabel:"Камера",cameraPermissionDenied:"Браузер блокирует доступ к вашей камере",cameraTurnedOff:"Камера выключена",close:"Закрыть",complianceBannerNowOnlyRecording:"Сейчас для этого собрания ведется только запись.",complianceBannerNowOnlyTranscription:"Сейчас для этого собрания ведется только транскрибирование.",complianceBannerRecordingAndTranscriptionSaved:"Сохранение записи и транскрибирования.",complianceBannerRecordingAndTranscriptionStarted:"Начата запись и транскрибирование.",complianceBannerRecordingAndTranscriptionStopped:"Запись и транскрибирование остановлены.",complianceBannerRecordingSaving:"Сохранение записи.",complianceBannerRecordingStarted:"Запись начата.",complianceBannerRecordingStopped:"Запись остановлена.",complianceBannerTranscriptionStarted:"Транскрибирование запущено.",complianceBannerTranscriptionConsent:"Присоединяясь, вы даете согласие на транскрибирование этого собрания.",complianceBannerTranscriptionSaving:"Сохранение транскрибирования.",complianceBannerTranscriptionStopped:"Транскрибирование остановлено.",configurationPageTitle:"Позвонить",defaultPlaceHolder:"Выберите один из вариантов",failedToJoinCallDueToNoNetworkMoreDetails:"Звонок был отключен из-за проблемы с сетью. Проверьте подключение и присоединитесь еще раз.",failedToJoinCallDueToNoNetworkTitle:"Вызов прерван",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Вам не предоставили доступ к беседе. Если это произошло по ошибке, заново присоединитесь к беседе.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Вы были удалены из \"зала ожидания\"",learnMore:"Подробнее",leftCallMoreDetails:"Если это произошло по ошибке, заново присоединитесь к беседе.",leftCallTitle:"Вы покинули беседу",lobbyScreenConnectingToCallTitle:"Подключение к звонку",lobbyScreenWaitingToBeAdmittedTitle:"Ожидание допуска",microphonePermissionDenied:"Браузер блокирует доступ к вашему микрофону",mutedMessage:"Ваш звук отключен",networkReconnectMoreDetails:"Похоже, что-то пошло не так. Мы пытаемся вернуться к звонку.",networkReconnectTitle:"Подождите",privacyPolicy:"Политика конфиденциальности",rejoinCallButtonLabel:"Повторно присоединиться к звонку",removedFromCallMoreDetails:"Другой участник удалил вас из беседы.",removedFromCallTitle:"Вы были удалены",soundLabel:"Звук",startCallButtonLabel:"Начать звонок",microphoneToggleInLobbyNotAllowed:"Невозможно отключить или включить звук, находясь в \"зале ожидания\"."};var chat$3={chatListHeader:"В этом чате"};var ru_RU = {call:call$3,chat:chat$3};

var call$2={cameraLabel:"Kamera",cameraPermissionDenied:"Tarayıcınız kameranıza erişimi engelliyor",cameraTurnedOff:"Kameranız kapatıldı",close:"Kapat",complianceBannerNowOnlyRecording:"Şu anda yalnızca bu toplantıyı kaydediyorsunuz.",complianceBannerNowOnlyTranscription:"Şu anda yalnızca bu toplantının dökümünü oluşturuyorsunuz.",complianceBannerRecordingAndTranscriptionSaved:"Kayıt ve döküm kaydediliyor.",complianceBannerRecordingAndTranscriptionStarted:"Kayıt ve döküm başlatıldı.",complianceBannerRecordingAndTranscriptionStopped:"Kayıt ve döküm durduruldu.",complianceBannerRecordingSaving:"Kayıt kaydediliyor.",complianceBannerRecordingStarted:"Kayıt başladı.",complianceBannerRecordingStopped:"Kayıt durduruldu.",complianceBannerTranscriptionStarted:"Döküm başlatıldı.",complianceBannerTranscriptionConsent:"Katılarak bu toplantının dökümünün çıkarılmasına onay verirsiniz.",complianceBannerTranscriptionSaving:"Döküm kaydediliyor.",complianceBannerTranscriptionStopped:"Döküm durduruldu.",configurationPageTitle:"Arama başlatın",defaultPlaceHolder:"Bir seçenek belirleyin",failedToJoinCallDueToNoNetworkMoreDetails:"Bir ağ sorunu nedeniyle arama bağlantısı kesildi. Bağlantınızı kontrol edin ve yeniden katılın.",failedToJoinCallDueToNoNetworkTitle:"Arama kesildi",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Aramaya katılmanıza izin verilmedi. Bu işlem yanlışlıkla yapıldıysa aramaya yeniden katılın.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Lobiden çıkarıldı",learnMore:"Daha fazla bilgi edinin",leftCallMoreDetails:"Bu bir hataysa aramaya yeniden katılın.",leftCallTitle:"Aramadan ayrıldınız",lobbyScreenConnectingToCallTitle:"Aramaya katılıyorsunuz",lobbyScreenWaitingToBeAdmittedTitle:"Kabul edilmeyi bekliyor",microphonePermissionDenied:"Tarayıcınız mikrofonunuza erişimi engelliyor",mutedMessage:"Sesiniz kapatıldı",networkReconnectMoreDetails:"Bir sorun oluştu gibi görünüyor. Çağrıya geri alınmaya çalışılıyor.",networkReconnectTitle:"Bekleyin",privacyPolicy:"Gizlilik ilkesi",rejoinCallButtonLabel:"Çağrıya yeniden katıl",removedFromCallMoreDetails:"Başka bir katılımcı sizi aramadan çıkardı.",removedFromCallTitle:"Çıkarıldınız",soundLabel:"Ses",startCallButtonLabel:"Arama başlat",microphoneToggleInLobbyNotAllowed:"Lobideyken sesi kapatılamaz veya açılamaz."};var chat$2={chatListHeader:"Bu sohbette"};var tr_TR = {call:call$2,chat:chat$2};

var call$1={cameraLabel:"照相机",cameraPermissionDenied:"你的浏览器正在阻止对相机的访问",cameraTurnedOff:"你的相机已关闭",close:"关闭",complianceBannerNowOnlyRecording:"现在仅录制此会议。",complianceBannerNowOnlyTranscription:"现在仅听录此会议。",complianceBannerRecordingAndTranscriptionSaved:"正在保存录制和听录。",complianceBannerRecordingAndTranscriptionStarted:"录制和听录已开始。",complianceBannerRecordingAndTranscriptionStopped:"录制和听录已停止。",complianceBannerRecordingSaving:"正在保存录制。",complianceBannerRecordingStarted:"录制已开始。",complianceBannerRecordingStopped:"录制已停止。",complianceBannerTranscriptionStarted:"听录已开始。",complianceBannerTranscriptionConsent:"加入即表示你同意转录此会议。",complianceBannerTranscriptionSaving:"正在保存听录。",complianceBannerTranscriptionStopped:"听录已停止。",configurationPageTitle:"开始通话",defaultPlaceHolder:"选择一个选项",failedToJoinCallDueToNoNetworkMoreDetails:"由于网络问题，呼叫已断开连接。请检查你的连接，然后重新加入。",failedToJoinCallDueToNoNetworkTitle:"通话已断开",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"未在通话中向你授予条目。如果这是一个错误，请重新加入呼叫。",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"已从大厅中关闭",learnMore:"了解详细信息",leftCallMoreDetails:"如果这是一个错误，请重新加入呼叫。",leftCallTitle:"你已离开通话",lobbyScreenConnectingToCallTitle:"加入通话",lobbyScreenWaitingToBeAdmittedTitle:"正在等待被拒绝",microphonePermissionDenied:"你的浏览器正在阻止对麦克风的访问",mutedMessage:"你已静音",networkReconnectMoreDetails:"似乎出现了问题。我们正在努力恢复通话。",networkReconnectTitle:"稍等",privacyPolicy:"隐私策略",rejoinCallButtonLabel:"重新加入呼叫",removedFromCallMoreDetails:"另一名参与者已将你从通话中删除。",removedFromCallTitle:"你已被删除",soundLabel:"声音",startCallButtonLabel:"开始通话",microphoneToggleInLobbyNotAllowed:"在大厅中时无法静音或取消静音。"};var chat$1={chatListHeader:"在此聊天中"};var zh_CN = {call:call$1,chat:chat$1};

var call={cameraLabel:"相機",cameraPermissionDenied:"您的瀏覽器禁止存取您的相機",cameraTurnedOff:"您的相機已關閉",close:"關閉",complianceBannerNowOnlyRecording:"您現在只會錄製此會議。",complianceBannerNowOnlyTranscription:"您現在只會轉錄此會議。",complianceBannerRecordingAndTranscriptionSaved:"正在儲存錄製和轉錄。",complianceBannerRecordingAndTranscriptionStarted:"已開始錄製並進行轉錄。",complianceBannerRecordingAndTranscriptionStopped:"已停止錄製與轉錄。",complianceBannerRecordingSaving:"正在儲存錄製內容。",complianceBannerRecordingStarted:"已開始錄製。",complianceBannerRecordingStopped:"已停止錄製。",complianceBannerTranscriptionStarted:"已開始轉錄。",complianceBannerTranscriptionConsent:"一旦加入，即表示您同意轉譯此會議。",complianceBannerTranscriptionSaving:"正在儲存轉錄。",complianceBannerTranscriptionStopped:"已停止轉錄。",configurationPageTitle:"開始通話",defaultPlaceHolder:"選取選項",failedToJoinCallDueToNoNetworkMoreDetails:"由於網路問題，通話已中斷連線。檢查您的連線並再次加入。",failedToJoinCallDueToNoNetworkTitle:"通話已斷線",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"您未被授予加入通話的權限。如果有誤，請重新加入通話。",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"已從大廳關閉",learnMore:"深入了解",leftCallMoreDetails:"如果有誤，請重新加入通話。",leftCallTitle:"您已離開通話",lobbyScreenConnectingToCallTitle:"正在加入通話",lobbyScreenWaitingToBeAdmittedTitle:"正在等候認可",microphonePermissionDenied:"您的瀏覽器禁止存取您的麥克風",mutedMessage:"您已設為靜音",networkReconnectMoreDetails:"似乎發生錯誤。我們正在嘗試讓您返回通話。",networkReconnectTitle:"請稍候",privacyPolicy:"隱私權原則",rejoinCallButtonLabel:"重新加入通話",removedFromCallMoreDetails:"另一名參與者已將您自通話中移除。",removedFromCallTitle:"您已遭移除",soundLabel:"音效",startCallButtonLabel:"開始通話",microphoneToggleInLobbyNotAllowed:"無法在大廳中靜音或取消靜音。"};var chat={chatListHeader:"在此聊天中"};var zh_TW = {call:call,chat:chat};

// Copyright (c) Microsoft Corporation.
const createCompositeStrings = (localizedStrings) => {
    const strings = Object.assign({}, en_US);
    Object.keys(localizedStrings).forEach((key) => {
        strings[key] = Object.assign(Object.assign({}, strings[key]), localizedStrings[key]);
    });
    return strings;
};
/**
 * Locale for English (US)
 *
 * @public
 */
const COMPOSITE_LOCALE_EN_US = {
    component: COMPONENT_LOCALE_EN_US,
    strings: en_US
};
/**
 * Locale for English (British)
 *
 * @public
 */
const COMPOSITE_LOCALE_EN_GB = {
    component: COMPONENT_LOCALE_EN_GB,
    strings: createCompositeStrings(en_GB)
};
/**
 * Locale for German (Germany)
 *
 * @public
 */
const COMPOSITE_LOCALE_DE_DE = {
    component: COMPONENT_LOCALE_DE_DE,
    strings: createCompositeStrings(de_DE)
};
/**
 * Locale for Spanish (Spain)
 *
 * @public
 */
const COMPOSITE_LOCALE_ES_ES = {
    component: COMPONENT_LOCALE_ES_ES,
    strings: createCompositeStrings(es_ES)
};
/**
 * Locale for French (France)
 *
 * @public
 */
const COMPOSITE_LOCALE_FR_FR = {
    component: COMPONENT_LOCALE_FR_FR,
    strings: createCompositeStrings(fr_FR)
};
/**
 * Locale for Italian (Italy)
 *
 * @public
 */
const COMPOSITE_LOCALE_IT_IT = {
    component: COMPONENT_LOCALE_IT_IT,
    strings: createCompositeStrings(it_IT)
};
/**
 * Locale for Japanese (Japan)
 *
 * @public
 */
const COMPOSITE_LOCALE_JA_JP = {
    component: COMPONENT_LOCALE_JA_JP,
    strings: createCompositeStrings(ja_JP)
};
/**
 * Locale for Korean (South Korea)
 *
 * @public
 */
const COMPOSITE_LOCALE_KO_KR = {
    component: COMPONENT_LOCALE_KO_KR,
    strings: createCompositeStrings(ko_KR)
};
/**
 * Locale for Dutch (Netherlands)
 *
 * @public
 */
const COMPOSITE_LOCALE_NL_NL = {
    component: COMPONENT_LOCALE_NL_NL,
    strings: createCompositeStrings(nl_NL)
};
/**
 * Locale for Portuguese (Brazil)
 *
 * @public
 */
const COMPOSITE_LOCALE_PT_BR = {
    component: COMPONENT_LOCALE_PT_BR,
    strings: createCompositeStrings(pt_BR)
};
/**
 * Locale for Russian (Russia)
 *
 * @public
 */
const COMPOSITE_LOCALE_RU_RU = {
    component: COMPONENT_LOCALE_RU_RU,
    strings: createCompositeStrings(ru_RU)
};
/**
 * Locale for Turkish (Turkey)
 *
 * @public
 */
const COMPOSITE_LOCALE_TR_TR = {
    component: COMPONENT_LOCALE_TR_TR,
    strings: createCompositeStrings(tr_TR)
};
/**
 * Locale for Chinese (Mainland China)
 *
 * @public
 */
const COMPOSITE_LOCALE_ZH_CN = {
    component: COMPONENT_LOCALE_ZH_CN,
    strings: createCompositeStrings(zh_CN)
};
/**
 * Locale for Chinese (Taiwan)
 *
 * @public
 */
const COMPOSITE_LOCALE_ZH_TW = {
    component: COMPONENT_LOCALE_ZH_TW,
    strings: createCompositeStrings(zh_TW)
};

// Copyright (c) Microsoft Corporation.
/**
 * Context for providing localized strings to components
 *
 * @private
 */
const LocaleContext = React.createContext(COMPOSITE_LOCALE_EN_US);
/**
 * Provider to provide localized strings for this library's composites.
 *
 * @private
 */
const LocalizationProvider = (props) => {
    const { locale, children } = props;
    return (React__default['default'].createElement(LocaleContext.Provider, { value: locale },
        React__default['default'].createElement(LocalizationProvider$1, { locale: locale.component }, children)));
};
/**
 * @private
 */
const useLocale = () => React.useContext(LocaleContext);

// Copyright (c) Microsoft Corporation.
const CoffeeIcon = () => (React__default['default'].createElement(react.Text, { className: react.mergeStyles(coffeeIconStyle), "aria-hidden": true }, "\u2615"));
const coffeeIconStyle = {
    // Fluent wraps all icons with <i> so we must force the fontStyle back to normal.
    fontStyle: 'normal',
    // By default our icons are 20px x 20px (for 1rem = 16px), make this a bit bigger for lobby.
    fontSize: '2rem'
};
/**
 * The default set of icons used by the composites directly (i.e. not via the components defined in this library).
 *
 * @public
 */
const COMPOSITE_ONLY_ICONS = {
    LobbyScreenConnectingToCall: React__default['default'].createElement(CoffeeIcon, null),
    LobbyScreenWaitingToBeAdmitted: React__default['default'].createElement(CoffeeIcon, null),
    LocalDeviceSettingsCamera: React__default['default'].createElement(reactIcons.Video20Filled, null),
    LocalDeviceSettingsMic: React__default['default'].createElement(reactIcons.MicOn20Filled, null),
    LocalDeviceSettingsSpeaker: React__default['default'].createElement(reactIcons.Speaker220Filled, null),
    LocalPreviewPlaceholder: React__default['default'].createElement(reactIcons.VideoOff20Filled, null),
    Muted: React__default['default'].createElement(reactIcons.MicOff20Filled, null),
    NetworkReconnectIcon: React__default['default'].createElement(reactIcons.CallMissed20Filled, null),
    NoticePageAccessDeniedTeamsMeeting: React__default['default'].createElement(reactIcons.PersonDelete20Filled, null),
    NoticePageJoinCallFailedDueToNoNetwork: React__default['default'].createElement(reactIcons.WifiWarning20Filled, null),
    NoticePageLeftCall: React__default['default'].createElement(reactIcons.CallEnd20Filled, null),
    NoticePageRemovedFromCall: React__default['default'].createElement(reactIcons.Info20Filled, null)
};
/**
 * The default set of icons that are available to used in the Composites.
 *
 * @public
 */
const DEFAULT_COMPOSITE_ICONS = Object.assign(Object.assign({}, DEFAULT_COMPONENT_ICONS), COMPOSITE_ONLY_ICONS);

// Copyright (c) Microsoft Corporation.
/**
 * A base class for composites.
 * Provides common wrappers such as FluentThemeProvider and LocalizationProvider.
 *
 * @private
 */
const BaseComposite = (props) => {
    const { fluentTheme, rtl, locale } = props;
    /**
     * We register the default icon mappings merged with custom icons provided through props
     * to ensure all icons render correctly.
     */
    react.registerIcons({ icons: Object.assign(Object.assign({}, DEFAULT_COMPOSITE_ICONS), props.icons) });
    const CompositeElement = (React__default['default'].createElement(FluentThemeProvider, { fluentTheme: fluentTheme, rtl: rtl },
        React__default['default'].createElement("meta", { name: "viewport", content: "width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" }),
        props.children));
    return locale ? LocalizationProvider({ locale, children: CompositeElement }) : CompositeElement;
};

// Copyright (c) Microsoft Corporation.
const ChatAdapterContext = React.createContext(undefined);
/**
 * @private
 */
const ChatAdapterProvider = (props) => {
    const { adapter } = props;
    return React__default['default'].createElement(ChatAdapterContext.Provider, { value: adapter }, props.children);
};
/**
 * @private
 */
const useAdapter$1 = () => {
    const adapter = React.useContext(ChatAdapterContext);
    if (!adapter) {
        throw 'Cannot find adapter please initialize before usage.';
    }
    return adapter;
};

// Copyright (c) Microsoft Corporation.
const MESSAGE_THREAD_WIDTH = '41.25rem';
/**
 * @private
 */
const chatScreenContainerStyle = react.mergeStyles({
    height: '100%',
    width: '100%',
    minHeight: '20rem',
    minWidth: '19.5rem'
});
/**
 * @private
 */
const chatContainer = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'hidden',
    '*::-webkit-scrollbar': {
        width: '0.3rem',
        height: '0.3rem'
    },
    '.scroll::-webkit-scrollbar-track': {
        background: 'rgba(150, 150, 150)',
        borderRadius: '0.3rem'
    },
    '*::-webkit-scrollbar-thumb': {
        borderRadius: '10px',
        background: 'rgba(150, 150, 150)'
    }
});
/**
 * @private
 */
const chatArea = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'hidden'
});
/**
 * @private
 */
const chatWrapper = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'auto'
});
/**
 * @private
 */
const chatHeaderContainerStyle = react.mergeStyles({
    width: '100%',
    paddingLeft: '1.5rem',
    paddingRight: '1.5rem',
    '@media screen and (max-width: 25rem)': {
        paddingLeft: '5%',
        paddingRight: '5%'
    },
    borderBottom: '0.063rem solid #DDDDDD'
});
/**
 * @private
 */
const topicNameLabelStyle = react.mergeStyles({
    fontSize: '1.1rem',
    lineHeight: '2.5rem',
    fontWeight: 600,
    marginRight: '0.125rem',
    textOverflow: 'ellipsis',
    overflowY: 'hidden'
});
/**
 * @private
 */
react.mergeStyles({
    boxShadow: '0px 0.3px 0.9px rgba(0, 0, 0, 0.1), 0px 1.6px 3.6px rgba(0, 0, 0, 0.13)',
    width: '20rem',
    // max width at 50% of view so the People Pane is not squeezing the Message Pane to almost nothing when on small screen or high zoom in
    maxWidth: '50vw',
    height: '100%'
});
/**
 * @private
 */
const participantListContainerPadding = { childrenGap: '0.5rem' };
/**
 * @private
 */
react.mergeStyles({
    fontSize: '1rem',
    margin: '1rem'
});
/**
 * @private
 */
react.mergeStyles({
    height: '100%'
});
/**
 * @private
 */
react.mergeStyles({
    height: '100%',
    overflow: 'auto'
});
/**
 * @private
 */
const sendBoxChatCompositeStyles = {
    textFieldContainer: { maxWidth: MESSAGE_THREAD_WIDTH }
};
/**
 * @private
 */
const messageThreadChatCompositeStyles = { root: { maxWidth: MESSAGE_THREAD_WIDTH } };
/**
 * @private
 */
const typingIndicatorChatCompositeStyles = {
    typingString: { maxWidth: MESSAGE_THREAD_WIDTH }
};
/**
 * @private
 */
const typingIndicatorContainerStyles = {
    width: '100%',
    maxWidth: MESSAGE_THREAD_WIDTH,
    alignSelf: 'center',
    padding: '0rem 0.5rem'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$4 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * An Avatar component made using the `Persona` component.
 * It allows you to specify a `userId` and a `dataProvider` to retrieve the `AvatarPersonaData`.
 * Read more about `Persona` component at https://developer.microsoft.com/fluentui#/controls/web/persona
 *
 * @private
 */
const AvatarPersona = (props) => {
    var _a, _b, _c, _d, _e, _f;
    const { userId, dataProvider } = props;
    const [data, setData] = React__default['default'].useState();
    React.useEffect(() => {
        (() => __awaiter$4(void 0, void 0, void 0, function* () {
            if (dataProvider && userId) {
                const data = yield dataProvider(userId);
                setData(data);
            }
        }))();
    }, [dataProvider, userId]);
    return (React__default['default'].createElement(react.Persona, Object.assign({}, props, { text: (_a = data === null || data === void 0 ? void 0 : data.text) !== null && _a !== void 0 ? _a : props.text, imageUrl: (_b = data === null || data === void 0 ? void 0 : data.imageUrl) !== null && _b !== void 0 ? _b : props.imageUrl, imageInitials: (_c = data === null || data === void 0 ? void 0 : data.imageInitials) !== null && _c !== void 0 ? _c : props.imageInitials, initialsColor: (_d = data === null || data === void 0 ? void 0 : data.initialsColor) !== null && _d !== void 0 ? _d : props.initialsColor, initialsTextColor: (_f = (_e = data === null || data === void 0 ? void 0 : data.initialsTextColor) !== null && _e !== void 0 ? _e : props.initialsTextColor) !== null && _f !== void 0 ? _f : 'white' })));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatHeader = (props) => {
    return (React__default['default'].createElement(react.Stack, { className: chatHeaderContainerStyle, horizontal: true },
        React__default['default'].createElement(react.Stack.Item, { align: "center" },
            React__default['default'].createElement("div", { className: topicNameLabelStyle }, props.topic))));
};
const getTopicName = (state, props) => {
    var _a, _b;
    return ((_b = (_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.topic) || '';
};
/**
 * @private
 */
const getHeaderProps = reselect__namespace.createSelector([getTopicName], (topic) => {
    return { topic: topic };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const useAdaptedSelector$1 = (selector, selectorProps) => {
    return useSelectorWithAdaptation$1(selector, adaptCompositeState$1, selectorProps);
};
/**
 * @private
 */
const useSelectorWithAdaptation$1 = (selector, adaptState, selectorProps) => {
    const adapter = useAdapter$1();
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const threadId = adapter.getState().thread.threadId;
    const threadConfigProps = React.useMemo(() => ({
        threadId
    }), [threadId]);
    const [props, setProps] = React.useState(selector(adaptState(adapter.getState()), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps));
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(adaptState(state), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        adapter.onStateChange(onStateChange);
        return () => {
            adapter.offStateChange(onStateChange);
        };
    }, [adaptState, adapter, selector, selectorProps, threadConfigProps]);
    return props;
};
const memoizeState$1 = memoizeOne__default['default']((userId, displayName, threads, latestErrors) => ({
    userId,
    displayName,
    threads,
    latestErrors
}));
const memoizeThreads = memoizeOne__default['default']((thread) => ({ [thread.threadId]: thread }));
const adaptCompositeState$1 = (compositeState) => {
    return memoizeState$1(compositeState.userId, compositeState.displayName, memoizeThreads(compositeState.thread), 
    // This is an unsafe type expansion.
    // compositeState.latestErrors can contain properties that are not valid in ChatErrors.
    //
    // But there is no way to check for valid property names at runtime:
    // - The set of valid property names is built from types in the @azure/communication-chat.
    //   Thus we don't have a literal array of allowed strings at runtime.
    // - Due to minification / uglification, the property names from the objects at runtime can't be used
    //   to compare against permissible values inferred from the types.
    //
    // This is not a huge problem -- it simply means that our adapted selector will include some extra operations
    // that are unknown to the UI component and data binding libraries. Generic handling of the errors (e.g.,
    // just displaying them in some UI surface) will continue to work for these operations. Handling of
    // specific operations (e.g., acting on errors related to permission issues) will ignore these operations.
    compositeState.latestErrors);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers$1 = (
// eslint-disable-next-line @typescript-eslint/no-unused-vars
_component) => {
    return createCompositeHandlers$1(useAdapter$1());
};
const createCompositeHandlers$1 = memoizeOne__default['default']((adapter) => ({
    onSendMessage: adapter.sendMessage,
    onLoadPreviousChatMessages: adapter.loadPreviousChatMessages,
    onMessageSeen: adapter.sendReadReceipt,
    onTyping: adapter.sendTypingIndicator,
    onRemoveParticipant: adapter.removeParticipant,
    updateThreadTopicName: adapter.setTopic,
    onUpdateMessage: adapter.updateMessage,
    onDeleteMessage: adapter.deleteMessage
}));

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const usePropsFor$2 = (component) => {
    const selector = getSelector(component);
    if (!selector) {
        throw new Error("Can't find the selector for component, please check supported component list");
    }
    return Object.assign(Object.assign({}, useAdaptedSelector$1(selector)), useHandlers$1());
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatScreen = (props) => {
    const { onFetchAvatarPersonaData, onRenderMessage, onRenderTypingIndicator, 
    // onFetchParticipantMenuItems,  // Removed for GA release
    options, styles } = props;
    const defaultNumberOfChatMessagesToReload = 5;
    const sendBoxParentStyle = react.mergeStyles({ width: '100%' });
    const adapter = useAdapter$1();
    React.useEffect(() => {
        adapter.fetchInitialData();
    }, [adapter]);
    const messageThreadProps = usePropsFor$2(MessageThread);
    const sendBoxProps = usePropsFor$2(SendBox);
    const typingIndicatorProps = usePropsFor$2(TypingIndicator);
    const headerProps = useAdaptedSelector$1(getHeaderProps);
    const errorBarProps = usePropsFor$2(ErrorBar);
    const onRenderAvatarCallback = React.useCallback((userId, defaultOptions) => {
        return (React__default['default'].createElement(AvatarPersona, Object.assign({ userId: userId, hidePersonaDetails: true }, defaultOptions, { dataProvider: onFetchAvatarPersonaData })));
    }, [onFetchAvatarPersonaData]);
    const sendBoxStyles = Object.assign({}, sendBoxChatCompositeStyles, styles === null || styles === void 0 ? void 0 : styles.sendBox);
    const messageThreadStyles = Object.assign({}, messageThreadChatCompositeStyles, styles === null || styles === void 0 ? void 0 : styles.messageThread);
    const typingIndicatorStyles = Object.assign({}, typingIndicatorChatCompositeStyles, styles === null || styles === void 0 ? void 0 : styles.typingIndicator);
    return (React__default['default'].createElement(react.Stack, { className: chatContainer, grow: true },
        (options === null || options === void 0 ? void 0 : options.topic) !== false && React__default['default'].createElement(ChatHeader, Object.assign({}, headerProps)),
        React__default['default'].createElement(react.Stack, { className: chatArea, tokens: participantListContainerPadding, horizontal: true, grow: true },
            React__default['default'].createElement(react.Stack, { className: chatWrapper, grow: true },
                (options === null || options === void 0 ? void 0 : options.errorBar) !== false && React__default['default'].createElement(ErrorBar, Object.assign({}, errorBarProps)),
                React__default['default'].createElement(MessageThread, Object.assign({}, messageThreadProps, { onRenderAvatar: onRenderAvatarCallback, onRenderMessage: onRenderMessage, numberOfChatMessagesToReload: defaultNumberOfChatMessagesToReload, styles: messageThreadStyles })),
                React__default['default'].createElement(react.Stack, { className: sendBoxParentStyle },
                    React__default['default'].createElement("div", { className: react.mergeStyles(typingIndicatorContainerStyles) }, onRenderTypingIndicator ? (onRenderTypingIndicator(typingIndicatorProps.typingUsers)) : (React__default['default'].createElement(TypingIndicator, Object.assign({}, typingIndicatorProps, { styles: typingIndicatorStyles })))),
                    React__default['default'].createElement(SendBox, Object.assign({}, sendBoxProps, { styles: sendBoxStyles })))))));
};

// Copyright (c) Microsoft Corporation.
/**
 * A customizable UI composite for the chat experience.
 *
 * @remarks Chat composite min width and height are respectively 19.5rem and 20rem (312px and 320px, with default rem at 16px)
 *
 * @public
 */
const ChatComposite = (props) => {
    const { adapter, options, onFetchAvatarPersonaData, onRenderTypingIndicator, onRenderMessage, onFetchParticipantMenuItems } = props;
    return (React__default['default'].createElement("div", { className: chatScreenContainerStyle },
        React__default['default'].createElement(BaseComposite, Object.assign({}, props),
            React__default['default'].createElement(ChatAdapterProvider, { adapter: adapter },
                React__default['default'].createElement(ChatScreen, { options: options, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onRenderTypingIndicator: onRenderTypingIndicator, onRenderMessage: onRenderMessage, onFetchParticipantMenuItems: onFetchParticipantMenuItems })))));
};

// Copyright (c) Microsoft Corporation.
const CallAdapterContext = React.createContext(undefined);
/**
 * @private
 */
const CallAdapterProvider = (props) => {
    const { adapter } = props;
    return React__default['default'].createElement(CallAdapterContext.Provider, { value: adapter }, props.children);
};
/**
 * @private
 */
const useAdapter = () => {
    const adapter = React.useContext(CallAdapterContext);
    if (!adapter) {
        throw 'Cannot find adapter please initialize before usage.';
    }
    return adapter;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const useAdaptedSelector = (selector, selectorProps) => {
    return useSelectorWithAdaptation(selector, adaptCompositeState, selectorProps);
};
/**
 * @private
 */
const useSelectorWithAdaptation = (selector, adaptState, selectorProps) => {
    var _a;
    const adapter = useAdapter();
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const callId = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.id;
    const callConfigProps = React.useMemo(() => ({
        callId
    }), [callId]);
    const [props, setProps] = React.useState(selector(adaptState(adapter.getState()), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callConfigProps));
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(adaptState(state), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        adapter.onStateChange(onStateChange);
        return () => {
            adapter.offStateChange(onStateChange);
        };
    }, [adaptState, adapter, selector, selectorProps, callConfigProps]);
    return props;
};
const memoizeState = memoizeOne__default['default']((userId, deviceManager, calls, latestErrors, displayName) => ({
    userId,
    incomingCalls: {},
    incomingCallsEnded: {},
    callsEnded: {},
    deviceManager,
    callAgent: { displayName },
    calls,
    latestErrors
}));
const memoizeCalls = memoizeOne__default['default']((call) => (call ? { [call.id]: call } : {}));
const adaptCompositeState = (compositeState) => {
    return memoizeState(compositeState.userId, compositeState.devices, memoizeCalls(compositeState.call), 
    // This is an unsafe type expansion.
    // compositeState.latestErrors can contain properties that are not valid in CallErrors.
    //
    // But there is no way to check for valid property names at runtime:
    // - The set of valid property names is built from types in the @azure/communication-calling.
    //   Thus we don't have a literal array of allowed strings at runtime.
    // - Due to minification / uglification, the property names from the objects at runtime can't be used
    //   to compare against permissible values inferred from the types.
    //
    // This is not a huge problem -- it simply means that our adapted selector will include some extra operations
    // that are unknown to the UI component and data binding libraries. Generic handling of the errors (e.g.,
    // just displaying them in some UI surface) will continue to work for these operations. Handling of
    // specific operations (e.g., acting on errors related to permission issues) will ignore these operations.
    compositeState.latestErrors, compositeState.displayName);
};

// Copyright (c) Microsoft Corporation.
const ACCESS_DENIED_TEAMS_MEETING_SUB_CODE = 5854;
const REMOVED_FROM_CALL_SUB_CODES = [5000, 5300];
/**
 * @private
 */
const isCameraOn = (state) => {
    if (state.call) {
        const stream = state.call.localVideoStreams.find((stream) => stream.mediaStreamType === 'Video');
        return !!stream;
    }
    else {
        if (state.devices.selectedCamera) {
            const previewOn = _isPreviewOn(state.devices);
            return previewOn;
        }
    }
    return false;
};
/**
 * Reduce the set of call controls visible on mobile.
 * For example do not show screenshare button.
 *
 * @private
 */
const reduceCallControlsForMobile = (callControlOptions) => {
    if (callControlOptions === false) {
        return false;
    }
    // Ensure call controls a valid object.
    const reduceCallControlOptions = callControlOptions === true ? {} : callControlOptions || {};
    // Set to compressed mode when composite is optimized for mobile
    reduceCallControlOptions.displayType = 'compact';
    // Do not show screen share button when composite is optimized for mobile unless the developer
    // has explicitly opted in.
    if (reduceCallControlOptions.screenShareButton !== true) {
        reduceCallControlOptions.screenShareButton = false;
    }
    return reduceCallControlOptions;
};
var CallEndReasons;
(function (CallEndReasons) {
    CallEndReasons[CallEndReasons["LEFT_CALL"] = 0] = "LEFT_CALL";
    CallEndReasons[CallEndReasons["ACCESS_DENIED"] = 1] = "ACCESS_DENIED";
    CallEndReasons[CallEndReasons["REMOVED_FROM_CALL"] = 2] = "REMOVED_FROM_CALL";
})(CallEndReasons || (CallEndReasons = {}));
const getCallEndReason = (call) => {
    var _a, _b;
    if (((_a = call.callEndReason) === null || _a === void 0 ? void 0 : _a.subCode) && call.callEndReason.subCode === ACCESS_DENIED_TEAMS_MEETING_SUB_CODE) {
        return CallEndReasons.ACCESS_DENIED;
    }
    if (((_b = call.callEndReason) === null || _b === void 0 ? void 0 : _b.subCode) && REMOVED_FROM_CALL_SUB_CODES.includes(call.callEndReason.subCode)) {
        return CallEndReasons.REMOVED_FROM_CALL;
    }
    if (call.callEndReason) {
        // No error codes match, assume the user simply left the call regularly
        return CallEndReasons.LEFT_CALL;
    }
    throw new Error('No matching call end reason');
};
/**
 * Get the current call composite page based on the current call composite state
 *
 * @param Call - The current call state
 * @param previousCall - The state of the most recent previous call that has ended.
 *
 * @remarks - The previousCall state is needed to determine if the call has ended.
 * When the call ends a new call object is created, and so we must lookback at the
 * previous call state to understand how the call has ended. If there is no previous
 * call we know that this is a fresh call and can display the configuration page.
 *
 * @private
 */
const getCallCompositePage = (call, previousCall) => {
    // Must check for ongoing call *before* looking at any previous calls.
    // If the composite completes one call and joins another, the previous calls
    // will be populated, but not relevant for determining the page.
    if (call) {
        // `_isInLobbyOrConnecting` needs to be checked first because `_isInCall` also returns true when call is in lobby.
        if (_isInLobbyOrConnecting(call === null || call === void 0 ? void 0 : call.state)) {
            return 'lobby';
        }
        else if (_isInCall(call === null || call === void 0 ? void 0 : call.state)) {
            return 'call';
        }
        else {
            // When the call object has been constructed after clicking , but before 'connecting' has been
            // set on the call object, we continue to show the configuration screen.
            // The call object does not correctly reflect local device state until `call.state` moves to `connecting`.
            // Moving to the 'lobby' page too soon leads to components that depend on the `call` object to show incorrect
            // transitional state.
            return 'configuration';
        }
    }
    if (previousCall) {
        const reason = getCallEndReason(previousCall);
        switch (reason) {
            case CallEndReasons.ACCESS_DENIED:
                return 'accessDeniedTeamsMeeting';
            case CallEndReasons.REMOVED_FROM_CALL:
                return 'removedFromCall';
            case CallEndReasons.LEFT_CALL:
                if (previousCall.diagnostics.network.latest.noNetwork) {
                    return 'joinCallFailedDueToNoNetwork';
                }
                return 'leftCall';
        }
    }
    // No call state - show starting page (configuration)
    return 'configuration';
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$3 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers = (
// eslint-disable-next-line @typescript-eslint/no-unused-vars
_component) => {
    return createCompositeHandlers(useAdapter());
};
const createCompositeHandlers = memoizeOne__default['default']((adapter) => ({
    onCreateLocalStreamView: (options) => __awaiter$3(void 0, void 0, void 0, function* () {
        yield adapter.createStreamView(undefined, options);
    }),
    onCreateRemoteStreamView: (userId, options) => __awaiter$3(void 0, void 0, void 0, function* () {
        yield adapter.createStreamView(userId, options);
    }),
    onHangUp: () => __awaiter$3(void 0, void 0, void 0, function* () {
        yield adapter.leaveCall();
    }),
    onRemoveParticipant: (userId) => __awaiter$3(void 0, void 0, void 0, function* () {
        yield adapter.removeParticipant(userId);
    }),
    onSelectCamera: (deviceInfo, options) => __awaiter$3(void 0, void 0, void 0, function* () {
        yield adapter.setCamera(deviceInfo, options);
    }),
    onSelectMicrophone: (deviceInfo) => __awaiter$3(void 0, void 0, void 0, function* () {
        yield adapter.setMicrophone(deviceInfo);
    }),
    onSelectSpeaker: (deviceInfo) => __awaiter$3(void 0, void 0, void 0, function* () {
        yield adapter.setSpeaker(deviceInfo);
    }),
    onStartCall: (participants) => {
        const rawIds = participants.map((participant) => toFlatCommunicationIdentifier(participant));
        return adapter.startCall(rawIds);
    },
    onStartScreenShare: () => __awaiter$3(void 0, void 0, void 0, function* () {
        yield adapter.startScreenShare();
    }),
    onStopScreenShare: () => __awaiter$3(void 0, void 0, void 0, function* () {
        yield adapter.stopScreenShare();
    }),
    onToggleCamera: (options) => __awaiter$3(void 0, void 0, void 0, function* () {
        isCameraOn(adapter.getState()) ? yield adapter.stopCamera() : yield adapter.startCamera(options);
    }),
    onToggleMicrophone: () => __awaiter$3(void 0, void 0, void 0, function* () {
        var _a;
        return ((_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.isMuted) ? yield adapter.unmute() : yield adapter.mute();
    }),
    onToggleScreenShare: () => __awaiter$3(void 0, void 0, void 0, function* () {
        var _b;
        return ((_b = adapter.getState().call) === null || _b === void 0 ? void 0 : _b.isScreenSharingOn)
            ? yield adapter.stopScreenShare()
            : yield adapter.startScreenShare();
    }),
    onStartLocalVideo: () => __awaiter$3(void 0, void 0, void 0, function* () {
        if (adapter.getState().call) {
            return adapter.startCamera();
        }
    }),
    onDisposeLocalStreamView: () => __awaiter$3(void 0, void 0, void 0, function* () {
        return adapter.disposeStreamView();
    }),
    onDisposeRemoteStreamView: (userId) => __awaiter$3(void 0, void 0, void 0, function* () {
        return adapter.disposeStreamView(userId);
    })
}));

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const usePropsFor$1 = (component) => {
    const selector = getSelector$1(component);
    if (!selector) {
        throw new Error("Can't find the selector for component, please check supported component list");
    }
    return Object.assign(Object.assign({}, useAdaptedSelector(selector)), useHandlers());
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const useSelector$1 = (selector, selectorProps) => {
    // use selector with no adaptation
    return useSelectorWithAdaptation(selector, (state) => state, selectorProps);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const getCallStatus = (state) => { var _a, _b; return (_b = (_a = state.call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None'; };
/**
 * @private
 */
const getDeviceManager = (state) => state.devices;
/**
 * @private
 */
const getIsScreenShareOn = (state) => { var _a, _b; return (_b = (_a = state.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn) !== null && _b !== void 0 ? _b : false; };
/**
 * @private
 */
const getIsPreviewCameraOn = (state) => _isPreviewOn(state.devices);
/**
 * @private
 */
const getPage = (state) => state.page;
/**
 * @private
 */
const getLocalMicrophoneEnabled = (state) => state.isLocalPreviewMicrophoneEnabled;
/**
 * @private
 */
const getLocalVideoStreams = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.localVideoStreams; };
/**
 * @private
 */
const getIsTranscriptionActive = (state) => { var _a; return !!((_a = state.call) === null || _a === void 0 ? void 0 : _a.transcription.isTranscriptionActive); };
/**
 * @private
 */
const getIsRecordingActive = (state) => { var _a; return !!((_a = state.call) === null || _a === void 0 ? void 0 : _a.recording.isRecordingActive); };
/**
 * @private
 */
const getUserFacingDiagnostics = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.diagnostics; };

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const MINIMUM_TOUCH_TARGET_HEIGHT_REM = 3;
/** @private */
const controlBarContainerStyles = {
    paddingTop: '0.25rem',
    paddingBottom: '0.25rem',
    // @TODO: this should be exposed through a custom CallComposite Theme API that extends the fluent theme with semantic values
    boxShadow: `
    0px 6.400000095367432px 14.399999618530273px 0px #00000021;
    0px 1.2000000476837158px 3.5999999046325684px 0px #0000001A;
  `
};
/**
 * @private
 */
const groupCallLeaveButtonStyle = {
    root: {
        border: '0.125rem',
        borderRadius: 2,
        height: '2.1875rem',
        width: '6.5625rem'
    },
    flexContainer: {
        flexFlow: 'row'
    }
};
/**
 * @private
 */
const groupCallLeaveButtonCompressedStyle = {
    root: {
        border: '0',
        borderRadius: '0.5rem'
    },
    flexContainer: {
        flexFlow: 'row'
    }
};
/**
 * Styles that can be applied to ensure flyout items have the minimum touch target size.
 *
 * @private
 */
const buttonFlyoutIncreasedSizeStyles = {
    root: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        maxHeight: 'unset'
    },
    linkContent: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        maxHeight: 'unset'
    },
    icon: {
        maxHeight: 'unset'
    }
};
/**
 * @private
 */
const participantButtonWithIncreasedTouchTargets = {
    menuStyles: {
        menuItemStyles: buttonFlyoutIncreasedSizeStyles,
        participantListStyles: {
            participantItemStyles: {
                root: {
                    height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`
                },
                participantSubMenuItemsStyles: buttonFlyoutIncreasedSizeStyles
            }
        }
    }
};
/**
 * @private
 */
const devicesButtonWithIncreasedTouchTargets = {
    menuStyles: {
        menuItemStyles: buttonFlyoutIncreasedSizeStyles
    }
};
/**
 * @private
 */
const controlButtonBaseStyle = {
    label: {
        minWidth: '2.25rem'
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallControls = (props) => {
    var _a, _b;
    const { callInvitationURL, onFetchParticipantMenuItems } = props;
    const options = typeof props.options === 'boolean' ? {} : props.options;
    const callStatus = useSelector$1(getCallStatus);
    const isLocalMicrophoneEnabled = useSelector$1(getLocalMicrophoneEnabled);
    const strings = useLocale().strings.call;
    /**
     * When call is in Lobby, microphone button should be disabled.
     * This is due to to headless limitation where a call can not be muted/unmuted in lobby.
     */
    const microphoneButtonProps = usePropsFor$1(MicrophoneButton);
    if (_isInLobbyOrConnecting(callStatus)) {
        microphoneButtonProps.disabled = true;
        // Lobby page should show the microphone status that was set on the local preview/configuration
        // page until the user successfully joins the call.
        microphoneButtonProps.checked = isLocalMicrophoneEnabled;
    }
    const microphoneButtonStrings = _isInLobbyOrConnecting(callStatus)
        ? {
            strings: {
                tooltipOffContent: strings.microphoneToggleInLobbyNotAllowed,
                tooltipOnContent: strings.microphoneToggleInLobbyNotAllowed
            }
        }
        : {};
    const cameraButtonProps = usePropsFor$1(CameraButton);
    const screenShareButtonProps = usePropsFor$1(ScreenShareButton);
    const participantsButtonProps = usePropsFor$1(ParticipantsButton);
    const devicesButtonProps = usePropsFor$1(DevicesButton);
    const hangUpButtonProps = usePropsFor$1(EndCallButton);
    const participantsButtonStyles = React.useMemo(() => mergeButtonBaseStyles(props.increaseFlyoutItemSize ? participantButtonWithIncreasedTouchTargets : {}), [props.increaseFlyoutItemSize]);
    const devicesButtonStyles = React.useMemo(() => mergeButtonBaseStyles(props.increaseFlyoutItemSize ? devicesButtonWithIncreasedTouchTargets : {}), [props.increaseFlyoutItemSize]);
    const compactMode = (options === null || options === void 0 ? void 0 : options.displayType) === 'compact';
    const microphoneButton = (options === null || options === void 0 ? void 0 : options.microphoneButton) !== false && (React__default['default'].createElement(MicrophoneButton, Object.assign({ "data-ui-id": "call-composite-microphone-button" }, microphoneButtonProps, { showLabel: !compactMode, styles: controlButtonBaseStyle }, microphoneButtonStrings)));
    const cameraButton = (options === null || options === void 0 ? void 0 : options.cameraButton) !== false && (React__default['default'].createElement(CameraButton, Object.assign({ "data-ui-id": "call-composite-camera-button" }, cameraButtonProps, { showLabel: !compactMode, styles: controlButtonBaseStyle })));
    const screenShareButton = (options === null || options === void 0 ? void 0 : options.screenShareButton) !== false && (React__default['default'].createElement(ScreenShareButton, Object.assign({ "data-ui-id": "call-composite-screenshare-button" }, screenShareButtonProps, { showLabel: !compactMode, disabled: (options === null || options === void 0 ? void 0 : options.screenShareButton) !== true && ((_a = options === null || options === void 0 ? void 0 : options.screenShareButton) === null || _a === void 0 ? void 0 : _a.disabled) })));
    const participantButton = (options === null || options === void 0 ? void 0 : options.participantsButton) !== false && (React__default['default'].createElement(ParticipantsButton, Object.assign({ "data-ui-id": "call-composite-participants-button" }, participantsButtonProps, { showLabel: !compactMode, callInvitationURL: callInvitationURL, onFetchParticipantMenuItems: onFetchParticipantMenuItems, disabled: (options === null || options === void 0 ? void 0 : options.participantsButton) !== true && ((_b = options === null || options === void 0 ? void 0 : options.participantsButton) === null || _b === void 0 ? void 0 : _b.disabled), styles: participantsButtonStyles })));
    const devicesButton = (options === null || options === void 0 ? void 0 : options.devicesButton) !== false && (React__default['default'].createElement(DevicesButton
    /* By setting `persistMenu?` to true, we prevent options menu from getting hidden every time a participant joins or leaves. */
    , Object.assign({ 
        /* By setting `persistMenu?` to true, we prevent options menu from getting hidden every time a participant joins or leaves. */
        persistMenu: true }, devicesButtonProps, { showLabel: !compactMode, styles: devicesButtonStyles })));
    const endCallButton = (options === null || options === void 0 ? void 0 : options.endCallButton) !== false && (React__default['default'].createElement(EndCallButton, Object.assign({ "data-ui-id": "call-composite-hangup-button" }, hangUpButtonProps, { styles: compactMode ? groupCallLeaveButtonCompressedStyle : groupCallLeaveButtonStyle, showLabel: !compactMode })));
    return (React__default['default'].createElement(react.Stack, { horizontalAlign: "center" },
        React__default['default'].createElement(react.Stack.Item, null,
            React__default['default'].createElement(ControlBar, { layout: "horizontal" },
                microphoneButton,
                cameraButton,
                screenShareButton,
                participantButton,
                devicesButton,
                endCallButton))));
};
const mergeButtonBaseStyles = (styles) => react.mergeStyleSets(controlButtonBaseStyle, styles);

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ComplianceBanner = (props) => {
    const strings = useLocale().strings;
    const cachedProps = React.useRef({
        latest: {
            callTranscribeState: false,
            callRecordState: false
        },
        previous: {
            callTranscribeState: false,
            callRecordState: false
        }
    });
    // Only update cached props if there is _some_ change in the latest props.
    // This ensures that state machine is only updated if there is an actual change in the props.
    if (props.callRecordState !== cachedProps.current.latest.callRecordState ||
        props.callTranscribeState !== cachedProps.current.latest.callTranscribeState) {
        cachedProps.current = {
            latest: props,
            previous: cachedProps.current.latest
        };
    }
    const variant = computeVariant(cachedProps.current.previous.callRecordState, cachedProps.current.previous.callTranscribeState, cachedProps.current.latest.callRecordState, cachedProps.current.latest.callTranscribeState);
    return React__default['default'].createElement(DismissableMessageBar, { variant: variant, strings: strings });
};
function DismissableMessageBar(props) {
    const { variant: newVariant, strings } = props;
    const [variant, setVariant] = React.useState(0);
    // We drive the `MessageBar` indirectly via the `variant` state variable.
    // This allows the `onDismiss` handler to set the `variant` state to dismiss the `MessageBar`.
    // This means that when props change, this component renders *twice*: After the first render, this `useEffect` block
    // updates the value of `variant` state variable, which triggers a second render to update the message in the `MessageBar`.
    React.useEffect(() => {
        setVariant(newVariant);
    }, [newVariant, setVariant]);
    return variant === NO_STATE ? (React__default['default'].createElement(React__default['default'].Fragment, null)) : (React__default['default'].createElement(react.MessageBar, { onDismiss: () => {
            setVariant(NO_STATE);
        }, dismissButtonAriaLabel: strings.call.close },
        React__default['default'].createElement(BannerMessage, { variant: variant, strings: strings })));
}
const TRANSCRIPTION_STOPPED_STILL_RECORDING = 1;
const RECORDING_STOPPED_STILL_TRANSCRIBING = 2;
const RECORDING_AND_TRANSCRIPTION_STOPPED = 3;
const RECORDING_AND_TRANSCRIPTION_STARTED = 4;
const TRANSCRIPTION_STARTED = 5;
const RECORDING_STOPPED = 6;
const RECORDING_STARTED = 7;
const TRANSCRIPTION_STOPPED = 8;
const NO_STATE = 0;
function computeVariant(previousCallRecordState, previousCallTranscribeState, callRecordState, callTranscribeState) {
    if (previousCallRecordState && previousCallTranscribeState) {
        if (callRecordState && !callTranscribeState) {
            return TRANSCRIPTION_STOPPED_STILL_RECORDING;
        }
        else if (!callRecordState && callTranscribeState) {
            return RECORDING_STOPPED_STILL_TRANSCRIBING;
        }
        else if (!callRecordState && !callTranscribeState) {
            return RECORDING_AND_TRANSCRIPTION_STOPPED;
        }
        else {
            return NO_STATE;
        }
    }
    else if (previousCallRecordState && !previousCallTranscribeState) {
        if (callRecordState && callTranscribeState) {
            return RECORDING_AND_TRANSCRIPTION_STARTED;
        }
        else if (!callRecordState && callTranscribeState) {
            return TRANSCRIPTION_STARTED;
        }
        else if (!callRecordState && !callTranscribeState) {
            return RECORDING_STOPPED;
        }
        else {
            return NO_STATE;
        }
    }
    else if (!previousCallRecordState && previousCallTranscribeState) {
        if (callRecordState && callTranscribeState) {
            return RECORDING_AND_TRANSCRIPTION_STARTED;
        }
        else if (!callRecordState && callTranscribeState) {
            return RECORDING_STARTED;
        }
        else if (!callRecordState && !callTranscribeState) {
            return TRANSCRIPTION_STOPPED;
        }
        else {
            return NO_STATE;
        }
    }
    else if (!previousCallRecordState && !previousCallTranscribeState) {
        if (callRecordState && callTranscribeState) {
            return RECORDING_AND_TRANSCRIPTION_STARTED;
        }
        else if (callRecordState && !callTranscribeState) {
            return RECORDING_STARTED;
        }
        else if (!callRecordState && callTranscribeState) {
            return TRANSCRIPTION_STARTED;
        }
        else {
            return NO_STATE;
        }
    }
    return NO_STATE;
}
function BannerMessage(props) {
    const { variant, strings } = props;
    switch (variant) {
        case TRANSCRIPTION_STOPPED_STILL_RECORDING:
            return (React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.call.complianceBannerTranscriptionStopped),
                ` ${strings.call.complianceBannerNowOnlyRecording}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.call.privacyPolicy })));
        case RECORDING_STOPPED_STILL_TRANSCRIBING:
            return (React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.call.complianceBannerRecordingStopped),
                ` ${strings.call.complianceBannerNowOnlyTranscription}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.call.privacyPolicy })));
        case RECORDING_AND_TRANSCRIPTION_STOPPED:
            return (React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.call.complianceBannerRecordingAndTranscriptionSaved),
                ` ${strings.call.complianceBannerRecordingAndTranscriptionStopped}`,
                React__default['default'].createElement(LearnMore, { linkText: strings.call.learnMore })));
        case RECORDING_AND_TRANSCRIPTION_STARTED:
            return (React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.call.complianceBannerRecordingAndTranscriptionStarted),
                ` ${strings.call.complianceBannerTranscriptionConsent}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.call.privacyPolicy })));
        case TRANSCRIPTION_STARTED:
            return (React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.call.complianceBannerTranscriptionStarted),
                ` ${strings.call.complianceBannerTranscriptionConsent}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.call.privacyPolicy })));
        case RECORDING_STOPPED:
            return (React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.call.complianceBannerRecordingSaving),
                ` ${strings.call.complianceBannerRecordingStopped}`,
                React__default['default'].createElement(LearnMore, { linkText: strings.call.learnMore })));
        case RECORDING_STARTED:
            return (React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.call.complianceBannerRecordingStarted),
                ` ${strings.call.complianceBannerTranscriptionConsent}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.call.privacyPolicy })));
        case TRANSCRIPTION_STOPPED:
            return (React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.call.complianceBannerTranscriptionSaving),
                ` ${strings.call.complianceBannerTranscriptionStopped}`,
                React__default['default'].createElement(LearnMore, { linkText: strings.call.learnMore })));
    }
    return React__default['default'].createElement(React__default['default'].Fragment, null);
}
function PrivacyPolicy(props) {
    return (React__default['default'].createElement(react.Link, { href: "https://privacy.microsoft.com/privacystatement#mainnoticetoendusersmodule", target: "_blank", underline: true }, props.linkText));
}
function LearnMore(props) {
    return (React__default['default'].createElement(react.Link, { href: "https://support.microsoft.com/office/record-a-meeting-in-teams-34dfbe7f-b07d-4a27-b4c6-de62f1348c24", target: "_blank", underline: true }, props.linkText));
}

// Copyright (c) Microsoft Corporation.
const VIDEO_GALLERY_Z_INDEX = 1;
// The control bar must be in a higher z-band than the video gallery so the drop shadow appears on top of the video gallery
const CONTROL_BAR_Z_INDEX = VIDEO_GALLERY_Z_INDEX + 1;
// The notification container should be in the highest z-band to ensure it shows on top of all other content.
const NOTIFICATION_CONTAINER_Z_INDEX = Math.max(CONTROL_BAR_Z_INDEX, VIDEO_GALLERY_Z_INDEX) + 1;
/**
 * @private
 */
const callControlsContainerStyles = react.mergeStyles(controlBarContainerStyles, {
    zIndex: CONTROL_BAR_Z_INDEX
});
const containerStyle$2 = {
    width: '100%',
    position: 'relative',
    minHeight: '15rem' // linked to minimum space allocated to media gallery
};
/**
 * @private
 */
const containerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, containerStyle$2), { minWidth: '30rem' }));
/**
 * @private
 */
const containerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, containerStyle$2), { minWidth: '19.5rem' }));
/**
 * @private
 */
const galleryParentContainerStyles = (backgroundColor) => ({
    root: {
        zIndex: VIDEO_GALLERY_Z_INDEX,
        width: '100%',
        background: backgroundColor
    }
});
/**
 * @private
 */
const mediaGalleryContainerStyles = {
    root: {
        height: '100%'
    }
};
/**
 * @private
 */
const notificationsContainerStyles = {
    root: {
        width: '100%',
        position: 'absolute',
        top: 0,
        left: 0,
        padding: '1rem',
        zIndex: NOTIFICATION_CONTAINER_Z_INDEX
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * Notify the user that they're muted.
 */
function MutedNotification(props) {
    const locale = useLocale();
    const theme = react.useTheme();
    if (!props.speakingWhileMuted) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    return (React__default['default'].createElement(react.Stack, { horizontal: true, horizontalAlign: "center" },
        React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(stackStyle(theme)) },
            React__default['default'].createElement(react.Icon, { iconName: "Muted", className: react.mergeStyles(iconStyle(theme)) }),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(textStyle(theme)), "aria-live": 'polite' }, locale.strings.call.mutedMessage))));
}
const stackStyle = (theme) => {
    return {
        background: theme.palette.black,
        opacity: 0.8,
        gap: `1rem`,
        padding: `1rem`,
        borderRadius: theme.effects.roundedCorner4,
        width: 'fit-content'
    };
};
const iconStyle = (theme) => {
    return {
        color: theme.palette.white
    };
};
const textStyle = (theme) => {
    return {
        color: theme.palette.white,
        fontSize: `1rem`
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallArrangement = (props) => {
    const containerClassName = React.useMemo(() => {
        return props.mobileView ? containerStyleMobile : containerStyleDesktop;
    }, [props.mobileView]);
    const theme = useTheme();
    const callGalleryStyles = React.useMemo(() => galleryParentContainerStyles(theme.palette.neutralLighterAlt), [theme.palette.neutralLighterAlt]);
    return (React__default['default'].createElement(react.Stack, { verticalFill: true, horizontalAlign: "stretch", className: containerClassName, "data-ui-id": props.dataUiId },
        React__default['default'].createElement(react.Stack.Item, { styles: notificationsContainerStyles },
            React__default['default'].createElement(react.Stack, null,
                React__default['default'].createElement(ComplianceBanner, Object.assign({}, props.complianceBannerProps))),
            props.errorBarProps !== false && (React__default['default'].createElement(react.Stack, null,
                React__default['default'].createElement(ErrorBar, Object.assign({}, props.errorBarProps)))),
            !!props.mutedNotificationProps && React__default['default'].createElement(MutedNotification, Object.assign({}, props.mutedNotificationProps))),
        React__default['default'].createElement(react.Stack.Item, { styles: callGalleryStyles, grow: true }, props.onRenderGalleryContent && (React__default['default'].createElement(react.Stack, { verticalFill: true, styles: mediaGalleryContainerStyles }, props.onRenderGalleryContent()))),
        props.callControlProps !== false && (React__default['default'].createElement(react.Stack.Item, { className: callControlsContainerStyles },
            React__default['default'].createElement(CallControls, Object.assign({}, props.callControlProps))))));
};

// Copyright (c) Microsoft Corporation.
const VideoGalleryStyles = {
    root: {
        height: '100%',
        minHeight: '10rem',
        minWidth: '6rem'
    }
};
const localVideoViewOptions$2 = {
    scalingMode: 'Crop',
    isMirrored: true
};
const remoteVideoViewOptions = {
    scalingMode: 'Crop'
};
/**
 * @private
 */
const MediaGallery = (props) => {
    const videoGalleryProps = usePropsFor$1(VideoGallery);
    useLocalVideoStartTrigger(!!props.isVideoStreamOn);
    const VideoGalleryMemoized = React.useMemo(() => {
        return (React__default['default'].createElement(VideoGallery, Object.assign({}, videoGalleryProps, { localVideoViewOptions: localVideoViewOptions$2, remoteVideoViewOptions: remoteVideoViewOptions, styles: VideoGalleryStyles, layout: "floatingLocalVideo", onRenderAvatar: (userId, options) => (React__default['default'].createElement(react.Stack, { className: react.mergeStyles({ position: 'absolute', height: '100%', width: '100%' }) },
                React__default['default'].createElement(AvatarPersona, Object.assign({ userId: userId }, options, { dataProvider: props.onFetchAvatarPersonaData })))) })));
    }, [props.onFetchAvatarPersonaData, videoGalleryProps]);
    return VideoGalleryMemoized;
};
/**
 * @private
 *
 * `shouldTransition` is an extra predicate that controls whether this hooks actually transitions the call.
 * The rule of hooks disallows calling the hook conditionally, so this predicate can be used to make the decision.
 */
const useLocalVideoStartTrigger = (isLocalVideoAvailable, shouldTransition) => {
    // Once a call is joined, we need to transition the local preview camera setting into the call.
    // This logic is needed on any screen that we might join a call from:
    // - The Media gallery
    // - The lobby page
    // - The networkReconnect interstitial that may show at the start of a call.
    //
    // @TODO: Can we simply have the callHandlers handle this transition logic.
    const [isButtonStatusSynced, setIsButtonStatusSynced] = React.useState(false);
    const isPreviewCameraOn = useSelector$1(getIsPreviewCameraOn);
    const mediaGalleryHandlers = useHandlers();
    React.useEffect(() => {
        if (shouldTransition !== false) {
            if (isPreviewCameraOn && !isLocalVideoAvailable && !isButtonStatusSynced) {
                mediaGalleryHandlers.onStartLocalVideo();
            }
            setIsButtonStatusSynced(true);
        }
    }, [shouldTransition, isButtonStatusSynced, isPreviewCameraOn, isLocalVideoAvailable, mediaGalleryHandlers]);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// By default, absolute positioned elements are overlayed over static ones.
// So we need to explicitly layer the background and contents.
const OVERLAY_BACKGROUND_ZINDEX = 0;
const OVERLAY_CONTENT_ZINDEX = OVERLAY_BACKGROUND_ZINDEX + 1;
/**
 * @private
 */
const containerStyles = {
    root: {
        height: '100%',
        width: '100%',
        position: 'relative'
    }
};
/**
 * @private
 */
const overlayBackgroundStyles = (palette, isVideoReady) => {
    return {
        position: 'absolute',
        height: '100%',
        width: '100%',
        background: isVideoReady ? 'black' : palette.neutralLighterAlt,
        opacity: isVideoReady ? 0.6 : 1,
        zIndex: OVERLAY_BACKGROUND_ZINDEX
    };
};
/**
 * @private
 */
const overlayContentStyles = {
    height: '100%',
    width: '100%',
    zIndex: OVERLAY_CONTENT_ZINDEX
};
/**
 * @private
 */
const videoTileStyles = {
    root: { height: '100%', width: '100%' }
};

// Copyright (c) Microsoft Corporation.
const onRenderEmptyPlaceholder = () => React__default['default'].createElement(React__default['default'].Fragment, null);
const localVideoViewOptions$1 = {
    scalingMode: 'Crop',
    isMirrored: true
};
/**
 * @private
 */
const ExpandedLocalVideoTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const renderElement = videoStream === null || videoStream === void 0 ? void 0 : videoStream.renderElement;
    const palette = useTheme().palette;
    React.useEffect(() => {
        if (videoStream && isVideoReady) {
            props.onCreateLocalStreamView &&
                props.onCreateLocalStreamView(localVideoViewOptions$1).catch((err) => console.log('Can not render video', err));
        }
    }, [isVideoReady, videoStream, props, renderElement]);
    return (React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", styles: containerStyles, grow: true },
        React__default['default'].createElement(VideoTile, { styles: videoTileStyles, renderElement: renderElement ? React__default['default'].createElement(StreamMedia, { videoStreamElement: renderElement }) : undefined, onRenderPlaceholder: onRenderEmptyPlaceholder }, props.overlayContent && (React__default['default'].createElement(React__default['default'].Fragment, null,
            React__default['default'].createElement(react.Stack, { className: react.mergeStyles(overlayBackgroundStyles(palette, isVideoReady)) }),
            React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(overlayContentStyles) }, props.overlayContent))))));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const containerStyle$1 = {
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem',
    gap: `1.5rem`
};
/**
 * @private
 */
const titleContainerStyle = {
    gap: `1rem`
};
/**
 * @private
 */
const titleStyle$1 = (palette, isVideoReady) => ({
    fontSize: '1.25rem',
    fontWeight: react.FontWeights.semibold,
    color: isVideoReady ? 'white' : palette.neutralPrimary,
    textAlign: 'center'
});
/**
 * @private
 */
const moreDetailsStyle$1 = (palette, isVideoReady) => ({
    fontSize: '1rem',
    color: isVideoReady ? 'white' : palette.neutralPrimary,
    textAlign: 'center'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const NetworkReconnectTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const palette = useTheme().palette;
    const strings = useLocale().strings.call;
    const handlers = useHandlers();
    // This tile may be shown at the beginning of a call.
    // So we need to transition local video to the call.
    useLocalVideoStartTrigger(!!props.localParticipantVideoStream.isAvailable);
    return (React__default['default'].createElement(ExpandedLocalVideoTile, Object.assign({ localParticipantVideoStream: props.localParticipantVideoStream, overlayContent: React__default['default'].createElement(react.Stack, { verticalFill: true, horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(containerStyle$1) },
            React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(titleContainerStyle) },
                React__default['default'].createElement(react.Icon, { iconName: "NetworkReconnectIcon", className: react.mergeStyles(titleStyle$1) }),
                React__default['default'].createElement(react.Text, { className: react.mergeStyles(titleStyle$1(palette, isVideoReady)), "aria-live": 'polite' }, strings.networkReconnectTitle)),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(moreDetailsStyle$1(palette, isVideoReady)), "aria-live": 'polite' }, strings.networkReconnectMoreDetails)) }, handlers)));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const callStatusSelector = reselect.createSelector([getCallStatus, getIsScreenShareOn], (callStatus, isScreenShareOn) => {
    return {
        callStatus,
        isScreenShareOn
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const complianceBannerSelector = reselect__namespace.createSelector([getIsTranscriptionActive, getIsRecordingActive], (isTranscriptionActive, isRecordingActive) => {
    return {
        callTranscribeState: isTranscriptionActive,
        callRecordState: isRecordingActive
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mediaGallerySelector = reselect__namespace.createSelector([getLocalVideoStreams], (localVideoStreams) => {
    var _a, _b;
    return {
        isVideoStreamOn: !!((_b = (_a = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find((stream) => stream.mediaStreamType === 'Video')) === null || _a === void 0 ? void 0 : _a.view) === null || _b === void 0 ? void 0 : _b.target)
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mutedNotificationSelector = reselect__namespace.createSelector([getUserFacingDiagnostics], (diagnostics) => {
    var _a;
    return {
        speakingWhileMuted: !!((_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.speakingWhileMicrophoneIsMuted) === null || _a === void 0 ? void 0 : _a.value)
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const lobbySelector = reselect__namespace.createSelector([callStatusSelector, getDeviceManager, getLocalVideoStreams], (callStatus, deviceManager, localVideoStreams) => {
    var _a, _b;
    let localVideoStream;
    if (_isInCall(callStatus.callStatus)) {
        localVideoStream = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find((i) => i.mediaStreamType === 'Video');
    }
    else if (_isPreviewOn(deviceManager)) {
        // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
        // handle cases where 'Preview' view is in progress and not necessary completed.
        localVideoStream = deviceManager.unparentedViews[0];
    }
    return {
        localParticipantVideoStream: {
            isAvailable: !!localVideoStream,
            isMirrored: (_a = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
            renderElement: (_b = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _b === void 0 ? void 0 : _b.target
        }
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const networkReconnectTileSelector = reselect__namespace.createSelector([getUserFacingDiagnostics, lobbySelector], (diagnostics, lobbyProps) => {
    var _a;
    return {
        networkReconnectValue: (_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReconnect) === null || _a === void 0 ? void 0 : _a.value,
        localParticipantVideoStream: lobbyProps.localParticipantVideoStream
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallPage = (props) => {
    const { callInvitationURL, onRenderAvatar, onFetchAvatarPersonaData, onFetchParticipantMenuItems, options, mobileView } = props;
    // To use useProps to get these states, we need to create another file wrapping Call,
    // It seems unnecessary in this case, so we get the updated states using this approach.
    const { callStatus } = useSelector$1(callStatusSelector);
    const mediaGalleryProps = useSelector$1(mediaGallerySelector);
    const mediaGalleryHandlers = useHandlers();
    const complianceBannerProps = useSelector$1(complianceBannerSelector);
    const errorBarProps = usePropsFor$1(ErrorBar);
    const mutedNotificationProps = useSelector$1(mutedNotificationSelector);
    const networkReconnectTileProps = useSelector$1(networkReconnectTileSelector);
    // Reduce the controls shown when mobile view is enabled.
    const callControlOptions = mobileView ? reduceCallControlsForMobile(options === null || options === void 0 ? void 0 : options.callControls) : options === null || options === void 0 ? void 0 : options.callControls;
    return (React__default['default'].createElement(CallArrangement, { complianceBannerProps: Object.assign({}, complianceBannerProps), errorBarProps: (options === null || options === void 0 ? void 0 : options.errorBar) !== false && Object.assign({}, errorBarProps), mutedNotificationProps: mutedNotificationProps, callControlProps: callControlOptions !== false && {
            callInvitationURL: callInvitationURL,
            onFetchParticipantMenuItems: onFetchParticipantMenuItems,
            options: callControlOptions,
            increaseFlyoutItemSize: mobileView
        }, mobileView: mobileView, onRenderGalleryContent: () => callStatus === 'Connected' ? (isNetworkHealthy(networkReconnectTileProps.networkReconnectValue) ? (React__default['default'].createElement(MediaGallery, Object.assign({}, mediaGalleryProps, mediaGalleryHandlers, { onRenderAvatar: onRenderAvatar, onFetchAvatarPersonaData: onFetchAvatarPersonaData }))) : (React__default['default'].createElement(NetworkReconnectTile, Object.assign({}, networkReconnectTileProps)))) : (React__default['default'].createElement(React__default['default'].Fragment, null)), dataUiId: 'call-page' }));
};
/**
 * @private
 */
const isNetworkHealthy = (value) => {
    // We know that the value is actually of type DiagnosticQuality for this diagnostic.
    // We ignore any boolen values, considering the network to still be healthy.
    // Thus, only DiagnosticQuality.Poor or .Bad indicate network problems.
    return value === true || value === false || value === undefined || value === communicationCalling.DiagnosticQuality.Good;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mainStackTokens = {
    childrenGap: '1rem'
};
/**
 * @private
 */
const dropDownStyles = (theme) => ({
    caretDownWrapper: {
        height: '2.5rem',
        lineHeight: '2.5rem'
    },
    dropdownItem: {
        fontSize: '0.875rem',
        height: '2.5rem',
        background: theme.palette.neutralQuaternaryAlt
    },
    dropdown: {
        height: '2.5rem',
        width: '100%',
        svg: {
            verticalAlign: 'top'
        }
    },
    title: {
        fontSize: '0.875rem',
        height: '2.5rem',
        lineHeight: '2.3125rem'
    },
    label: {
        fontWeight: 600,
        fontSize: '0.875rem'
    },
    errorMessage: {
        fontSize: '0.875rem'
    }
});
/**
 * @private
 */
const dropDownTitleIconStyles = react.mergeStyles({
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    minWidth: '0',
    maxWidth: '100%',
    overflowWrap: 'break-word',
    margin: '.063rem'
});
/**
 * @private
 */
const optionIconStyles = react.mergeStyles({
    marginRight: '8px',
    verticalAlign: 'text-top'
});

// Copyright (c) Microsoft Corporation.
const getDropDownList = (list) => {
    // Remove duplicates
    const noDuplicates = new Map();
    for (const item of list) {
        noDuplicates.set(item.id, item);
    }
    const dropdownList = [];
    for (const item of noDuplicates.values()) {
        dropdownList.push({
            key: item.id,
            text: item.name === '' ? item.deviceType : item.name
        });
    }
    return dropdownList;
};
const getOptionIcon = (type) => {
    if (type === 'Camera') {
        return React__default['default'].createElement(react.Icon, { iconName: "LocalDeviceSettingsCamera", className: optionIconStyles });
    }
    else if (type === 'Microphone') {
        return React__default['default'].createElement(react.Icon, { iconName: "LocalDeviceSettingsMic", className: optionIconStyles });
    }
    else if (type === 'Speaker') {
        return React__default['default'].createElement(react.Icon, { iconName: "LocalDeviceSettingsSpeaker", className: optionIconStyles });
    }
    else {
        return undefined;
    }
};
const onRenderTitle = (iconType, props) => {
    const icon = props && getOptionIcon(iconType);
    return props ? (React__default['default'].createElement("div", { className: dropDownTitleIconStyles },
        icon,
        React__default['default'].createElement("span", null, props[0].text))) : (React__default['default'].createElement(React__default['default'].Fragment, null));
};
const localVideoViewOptions = {
    scalingMode: 'Crop',
    isMirrored: true
};
/**
 * @private
 */
const LocalDeviceSettings = (props) => {
    var _a;
    const theme = useTheme();
    const locale = useLocale();
    const defaultPlaceHolder = locale.strings.call.defaultPlaceHolder;
    const cameraLabel = locale.strings.call.cameraLabel;
    const soundLabel = locale.strings.call.soundLabel;
    // TODO: speaker permission is tied to microphone permission (when you request 'audio' permission using the SDK) its
    // actually granting access to query both microphone and speaker. However the browser popup asks you explicity for
    // 'microphone'. This needs investigation on how we want to handle this and maybe needs follow up with SDK team.
    return (React__default['default'].createElement(react.Stack, { "data-ui-id": "call-composite-device-settings", tokens: mainStackTokens },
        React__default['default'].createElement(react.Stack, null,
            React__default['default'].createElement(react.Label, { id: 'call-composite-local-camera-settings-label', className: react.mergeStyles(dropDownStyles(theme).label), disabled: !props.cameraPermissionGranted }, cameraLabel),
            React__default['default'].createElement(react.Dropdown, { "data-ui-id": "call-composite-local-camera-settings", "aria-labelledby": 'call-composite-local-camera-settings-label', placeholder: defaultPlaceHolder, options: props.cameraPermissionGranted ? getDropDownList(props.cameras) : [{ key: 'deniedOrUnknown', text: '' }], styles: dropDownStyles(theme), disabled: !props.cameraPermissionGranted, errorMessage: props.cameraPermissionGranted === undefined || props.cameraPermissionGranted
                    ? undefined
                    : locale.strings.call.cameraPermissionDenied, defaultSelectedKey: props.cameraPermissionGranted
                    ? props.selectedCamera
                        ? props.selectedCamera.id
                        : props.cameras
                            ? (_a = props.cameras[0]) === null || _a === void 0 ? void 0 : _a.id
                            : ''
                    : 'deniedOrUnknown', onChange: (event, option, index) => {
                    props.onSelectCamera(props.cameras[index !== null && index !== void 0 ? index : 0], localVideoViewOptions);
                }, onRenderTitle: (props) => onRenderTitle('Camera', props) })),
        React__default['default'].createElement(react.Stack, null,
            React__default['default'].createElement(react.Label, { id: 'call-composite-local-sound-settings-label', className: react.mergeStyles(dropDownStyles(theme).label), disabled: !props.microphonePermissionGranted }, soundLabel),
            React__default['default'].createElement(react.Stack, { "data-ui-id": "call-composite-sound-settings", tokens: mainStackTokens },
                React__default['default'].createElement(react.Dropdown, { "aria-labelledby": 'call-composite-local-sound-settings-label', placeholder: defaultPlaceHolder, styles: dropDownStyles(theme), disabled: !props.microphonePermissionGranted, errorMessage: props.microphonePermissionGranted === undefined || props.microphonePermissionGranted
                        ? undefined
                        : locale.strings.call.microphonePermissionDenied, options: props.microphonePermissionGranted
                        ? getDropDownList(props.microphones)
                        : [{ key: 'deniedOrUnknown', text: '' }], defaultSelectedKey: props.microphonePermissionGranted
                        ? props.selectedMicrophone
                            ? props.selectedMicrophone.id
                            : defaultDeviceId(props.microphones)
                        : 'deniedOrUnknown', onChange: (event, option, index) => {
                        props.onSelectMicrophone(props.microphones[index !== null && index !== void 0 ? index : 0]);
                    }, onRenderTitle: (props) => onRenderTitle('Microphone', props) }),
                React__default['default'].createElement(react.Dropdown, { "aria-labelledby": 'call-composite-local-sound-settings-label', placeholder: defaultPlaceHolder, styles: dropDownStyles(theme), disabled: props.speakers.length === 0, options: getDropDownList(props.speakers), defaultSelectedKey: props.selectedSpeaker ? props.selectedSpeaker.id : defaultDeviceId(props.speakers), onChange: (event, option, index) => {
                        props.onSelectSpeaker(props.speakers[index !== null && index !== void 0 ? index : 0]);
                    }, onRenderTitle: (props) => onRenderTitle('Speaker', props) })))));
};
const defaultDeviceId = (devices) => {
    if (devices.length === 0) {
        return '';
    }
    const defaultDevice = devices.find((device) => device.isSystemDefault);
    if (defaultDevice) {
        return defaultDevice.id;
    }
    return devices[0].id;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const videoCameraIconStyle = react.mergeStyles({
    marginRight: '0.375rem',
    fontSize: '1.375rem'
});
/**
 * @private
 */
const buttonStyle = react.mergeStyles({
    fontWeight: 600,
    fontSize: '0.875rem',
    height: '2.75rem',
    width: '100%'
});
/**
 * @private
 */
const buttonWithIconStyles = {
    textContainer: {
        display: 'contents'
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const StartCallButton = (props) => {
    const { isDisabled, onClickHandler, rejoinCall } = props;
    const locale = useLocale();
    return (React__default['default'].createElement(react.PrimaryButton, { "data-ui-id": "call-composite-start-call-button", disabled: isDisabled, className: react.mergeStyles(buttonStyle, props.className), styles: buttonWithIconStyles, text: rejoinCall ? locale.strings.call.rejoinCallButtonLabel : locale.strings.call.startCallButtonLabel, onClick: onClickHandler, onRenderIcon: () => React__default['default'].createElement(reactIcons.Video20Filled, { className: videoCameraIconStyle }) }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const devicePermissionSelector = reselect__namespace.createSelector([getDeviceManager], (deviceManager) => {
    return {
        video: deviceManager.deviceAccess ? deviceManager.deviceAccess.video : undefined,
        audio: deviceManager.deviceAccess ? deviceManager.deviceAccess.audio : undefined
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const localPreviewSelector = reselect__namespace.createSelector([getDeviceManager], (deviceManager) => {
    // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
    // handle cases where 'Preview' view is in progress and not necessary completed.
    const view = deviceManager.unparentedViews.length > 0 && deviceManager.unparentedViews[0].view;
    return {
        videoStreamElement: view ? view.target : null
    };
});

// Copyright (c) Microsoft Corporation.
const localPreviewContainerStyle = {
    borderRadius: '.25rem'
};
/**
 * @private
 */
const localPreviewContainerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, localPreviewContainerStyle), { width: '50%', minWidth: '11rem', maxWidth: '25rem', height: '18.75rem', padding: '0.5rem' }));
/**
 * @private
 */
const localPreviewContainerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, localPreviewContainerStyle), { width: '100%', height: '100%' }));
/**
 * @private
 */
const cameraOffLabelStyle = react.mergeStyles({
    fontFamily: 'Segoe UI Regular',
    fontSize: '0.75rem' // 12px
});
/**
 * @private
 */
const localPreviewTileStyle = {
    root: {
        borderRadius: '.25rem'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$2 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const LocalPreview = (props) => {
    const locale = useLocale();
    const cameraButtonProps = usePropsFor$1(CameraButton);
    const localPreviewProps = useSelector$1(localPreviewSelector);
    const devicesButtonProps = usePropsFor$1(DevicesButton);
    const { audio: microphonePermissionGranted, video: cameraPermissionGranted } = useSelector$1(devicePermissionSelector);
    const isLocalMicrophoneEnabled = useSelector$1(getLocalMicrophoneEnabled);
    const adapter = useAdapter();
    const onToggleMic = React.useCallback(() => __awaiter$2(void 0, void 0, void 0, function* () {
        isLocalMicrophoneEnabled ? adapter.mute() : adapter.unmute();
    }), [adapter, isLocalMicrophoneEnabled]);
    const theme = useTheme();
    const onRenderPlaceholder = React.useCallback(() => {
        return (React__default['default'].createElement(react.Stack, { className: react.mergeStyles({ width: '100%', height: '100%' }), verticalAlign: "center", tokens: { childrenGap: '0.25rem' } },
            React__default['default'].createElement(react.Stack.Item, { align: "center" },
                React__default['default'].createElement(react.Icon, { iconName: "LocalPreviewPlaceholder", className: react.mergeStyles(cameraOffLabelStyle, { color: theme.palette.neutralTertiary }) })),
            React__default['default'].createElement(react.Stack.Item, { align: "center" },
                React__default['default'].createElement(react.Text, { className: react.mergeStyles(cameraOffLabelStyle, { color: theme.palette.neutralSecondary }) }, locale.strings.call.cameraTurnedOff))));
    }, [theme, locale.strings.call.cameraTurnedOff]);
    const devicesButtonStyles = props.mobileView
        ? {
            menuStyles: {
                menuItemStyles: buttonFlyoutIncreasedSizeStyles
            }
        }
        : undefined;
    return (React__default['default'].createElement(react.Stack, { "data-ui-id": "call-composite-local-preview", className: props.mobileView ? localPreviewContainerStyleMobile : localPreviewContainerStyleDesktop },
        React__default['default'].createElement(VideoTile, { styles: localPreviewTileStyle, renderElement: (localPreviewProps === null || localPreviewProps === void 0 ? void 0 : localPreviewProps.videoStreamElement) ? (React__default['default'].createElement(StreamMedia, { videoStreamElement: localPreviewProps.videoStreamElement })) : undefined, onRenderPlaceholder: onRenderPlaceholder },
            React__default['default'].createElement(ControlBar, { layout: "floatingBottom" },
                React__default['default'].createElement(MicrophoneButton, { "data-ui-id": "call-composite-local-device-settings-microphone-button", checked: isLocalMicrophoneEnabled, onToggleMicrophone: onToggleMic, disabled: !microphonePermissionGranted, showLabel: true }),
                React__default['default'].createElement(CameraButton, Object.assign({ "data-ui-id": "call-composite-local-device-settings-camera-button" }, cameraButtonProps, { showLabel: true, disabled: !cameraPermissionGranted })),
                props.showDevicesButton && (React__default['default'].createElement(DevicesButton, Object.assign({ "data-ui-id": "call-composite-local-device-settings-options-button" }, devicesButtonProps, { 
                    // disable button whilst all other buttons are disabled
                    disabled: !microphonePermissionGranted || !cameraPermissionGranted, showLabel: true, styles: devicesButtonStyles })))))));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const configurationStackTokensDesktop = {
    childrenGap: '2rem'
};
/**
 * @private
 */
const configurationStackTokensMobile = {
    childrenGap: '1rem'
};
const configurationContainerStyle = {
    height: '100%',
    width: '100%',
    padding: '0.5rem'
};
/**
 * @private
 */
const configurationContainerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, configurationContainerStyle), { minWidth: '25rem', minHeight: '22rem' // max height of SelectionContainer + padding * 2 = 21 + 0.5 * 2
 }));
/**
 * @private
 */
const configurationContainerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, configurationContainerStyle), { minWidth: '16rem', minHeight: '21rem' }));
/**
 * @private
 */
const selectionContainerStyle = react.mergeStyles({
    width: '50%',
    minWidth: '11rem',
    maxWidth: '18.75rem',
    padding: '0.5rem'
});
/**
 * @private
 */
const titleContainerStyleDesktop = react.mergeStyles({
    fontSize: '1.25rem',
    lineHeight: '1.75rem',
    fontWeight: 600
});
/**
 * @private
 */
const titleContainerStyleMobile = react.mergeStyles({
    fontSize: '1.0625rem',
    lineHeight: '1.375rem',
    fontWeight: 600,
    textAlign: 'center'
});
/**
 * @private
 */
const callDetailsContainerStylesDesktop = {
    root: {
        marginBottom: '1.563rem'
    }
};
const callDetailsStyle = {
    fontSize: '0.9375',
    lineHeight: '1.25rem',
    marginTop: '0.25rem'
};
/**
 * @private
 */
const callDetailsStyleDesktop = react.mergeStyles(Object.assign({}, callDetailsStyle));
/**
 * @private
 */
const callDetailsStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, callDetailsStyle), { textAlign: 'center' }));
/**
 * @private
 */
const startCallButtonContainerStyleDesktop = {
    root: {
        paddingTop: '1.125rem'
    }
};
/**
 * @private
 */
const startCallButtonContainerStyleMobile = {
    root: {
        textAlign: 'center'
    }
};
/**
 * @private
 */
const startCallButtonStyleMobile = react.mergeStyles({
    width: '100%',
    maxWidth: 'unset'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ConfigurationPage = (props) => {
    const { startCallHandler, mobileView } = props;
    const options = useAdaptedSelector(getSelector$1(DevicesButton));
    const localDeviceSettingsHandlers = useHandlers();
    const { video: cameraPermissionGranted, audio: microphonePermissionGranted } = useSelector$1(devicePermissionSelector);
    const locale = useLocale();
    const title = (React__default['default'].createElement(react.Stack.Item, { className: mobileView ? titleContainerStyleMobile : titleContainerStyleDesktop }, locale.strings.call.configurationPageTitle));
    const callDescription = locale.strings.call.configurationPageCallDetails && (React__default['default'].createElement(react.Stack.Item, { className: mobileView ? callDetailsStyleMobile : callDetailsStyleDesktop }, locale.strings.call.configurationPageCallDetails));
    return (React__default['default'].createElement(react.Stack, { horizontal: !mobileView, horizontalAlign: mobileView ? 'stretch' : 'center', verticalAlign: "center", tokens: mobileView ? configurationStackTokensMobile : configurationStackTokensDesktop, className: mobileView ? configurationContainerStyleMobile : configurationContainerStyleDesktop },
        mobileView && (React__default['default'].createElement(react.Stack.Item, null,
            title,
            callDescription)),
        React__default['default'].createElement(LocalPreview, { mobileView: mobileView, showDevicesButton: mobileView }),
        React__default['default'].createElement(react.Stack, { className: mobileView ? undefined : selectionContainerStyle },
            !mobileView && (React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement(react.Stack.Item, { styles: callDetailsContainerStylesDesktop },
                    title,
                    callDescription),
                React__default['default'].createElement(LocalDeviceSettings, Object.assign({}, options, localDeviceSettingsHandlers, { cameraPermissionGranted: cameraPermissionGranted, microphonePermissionGranted: microphonePermissionGranted })))),
            React__default['default'].createElement(react.Stack, { styles: mobileView ? startCallButtonContainerStyleMobile : startCallButtonContainerStyleDesktop },
                React__default['default'].createElement(StartCallButton, { className: mobileView ? startCallButtonStyleMobile : undefined, onClickHandler: startCallHandler, isDisabled: !microphonePermissionGranted })))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const containerStyle = {
    maxWidth: '22.5rem',
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem'
};
/**
 * @private
 */
const containerItemGap = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const rejoinCallButtonContainerStyles = {
    root: {
        paddingTop: '1.125rem'
    }
};
/**
 * @private
 */
const titleStyles = {
    fontSize: '1.25rem',
    fontWeight: 600
};
/**
 * @private
 */
const moreDetailsStyles = {
    fontSize: '1rem'
};

// Copyright (c) Microsoft Corporation.
/**
 * Generic page with a title and more details text for serving up a notice to the user.
 *
 * @private
 */
function NoticePage(props) {
    const adapter = useAdapter();
    return (React__default['default'].createElement(react.Stack, { verticalFill: true, verticalAlign: "center", horizontalAlign: "center", "data-ui-id": props.dataUiId },
        React__default['default'].createElement(react.Stack, { className: react.mergeStyles(containerStyle), tokens: containerItemGap },
            props.iconName && React__default['default'].createElement(react.Icon, { iconName: props.iconName }),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(titleStyles) }, props.title),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(moreDetailsStyles) }, props.moreDetails),
            React__default['default'].createElement(react.Stack, { styles: rejoinCallButtonContainerStyles },
                React__default['default'].createElement(StartCallButton, { onClickHandler: () => adapter.joinCall(), isDisabled: false, rejoinCall: true })))));
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const overlayContainerStyle = {
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem'
};
/**
 * @private
 */
const titleStyle = (palette, isVideoReady) => {
    return {
        fontSize: '1.75rem',
        color: isVideoReady ? 'white' : palette.neutralPrimary,
        textAlign: 'center'
    };
};
/**
 * @private
 */
const moreDetailsStyle = (palette, isVideoReady) => ({
    fontSize: '1rem',
    color: isVideoReady ? 'white' : palette.neutralPrimary,
    textAlign: 'center'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const LobbyTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const palette = useTheme().palette;
    const handlers = useHandlers();
    return (React__default['default'].createElement(ExpandedLocalVideoTile, Object.assign({ localParticipantVideoStream: props.localParticipantVideoStream, overlayContent: props.overlayProps ? (React__default['default'].createElement(react.Stack, { verticalFill: true, horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(overlayContainerStyle) },
            React__default['default'].createElement(react.Stack.Item, { className: react.mergeStyles(titleStyle(palette, isVideoReady)) }, props.overlayProps.overlayIcon),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(titleStyle(palette, isVideoReady)), "aria-live": 'polite' }, props.overlayProps.title),
            props.overlayProps.moreDetails && (React__default['default'].createElement(react.Text, { className: react.mergeStyles(moreDetailsStyle(palette, isVideoReady)) }, props.overlayProps.moreDetails)))) : undefined }, handlers)));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const LobbyPage = (props) => {
    var _a, _b, _c;
    const errorBarProps = usePropsFor$1(ErrorBar);
    const lobbyProps = useSelector$1(lobbySelector);
    const strings = useLocale().strings.call;
    const callState = useSelector$1(getCallStatus);
    const inLobby = callState === 'InLobby';
    useLocalVideoStartTrigger(lobbyProps.localParticipantVideoStream.isAvailable, inLobby);
    // Reduce the controls shown when mobile view is enabled.
    let callControlOptions = props.mobileView
        ? reduceCallControlsForMobile((_a = props.options) === null || _a === void 0 ? void 0 : _a.callControls)
        : (_b = props.options) === null || _b === void 0 ? void 0 : _b.callControls;
    callControlOptions = disableLobbyPageControls(callControlOptions);
    return (React__default['default'].createElement(CallArrangement, { complianceBannerProps: {}, errorBarProps: ((_c = props.options) === null || _c === void 0 ? void 0 : _c.errorBar) !== false && Object.assign({}, errorBarProps), callControlProps: callControlOptions !== false && {
            options: callControlOptions,
            increaseFlyoutItemSize: props.mobileView
        }, mobileView: props.mobileView, onRenderGalleryContent: () => React__default['default'].createElement(LobbyTile, Object.assign({}, lobbyProps, { overlayProps: overlayProps(strings, inLobby) })), dataUiId: 'lobby-page' }));
};
const disableLobbyPageControls = (callControlOptions) => {
    let newOptions = callControlOptions;
    if (newOptions !== false) {
        if (newOptions === true || newOptions === undefined) {
            newOptions = {
                participantsButton: { disabled: true },
                screenShareButton: { disabled: true }
            };
        }
        else {
            if (newOptions.participantsButton !== false) {
                newOptions.participantsButton = { disabled: true };
            }
            if (newOptions.screenShareButton !== false) {
                newOptions.screenShareButton = { disabled: true };
            }
        }
    }
    return newOptions;
};
const overlayProps = (strings, inLobby) => inLobby ? overlayPropsWaitingToBeAdmitted(strings) : overlayPropsConnectingToCall(strings);
const overlayPropsConnectingToCall = (strings, inLobby) => ({
    title: strings.lobbyScreenConnectingToCallTitle,
    moreDetails: strings.lobbyScreenConnectingToCallMoreDetails,
    overlayIcon: React__default['default'].createElement(react.Icon, { iconName: "LobbyScreenConnectingToCall" })
});
const overlayPropsWaitingToBeAdmitted = (strings, inLobby) => ({
    title: strings.lobbyScreenWaitingToBeAdmittedTitle,
    moreDetails: strings.lobbyScreenWaitingToBeAdmittedMoreDetails,
    overlayIcon: React__default['default'].createElement(react.Icon, { iconName: "LobbyScreenWaitingToBeAdmitted" })
});

// Copyright (c) Microsoft Corporation.
const mainScreenContainerStyle = {
    height: '100%',
    width: '100%'
};
/**
 * @private
 */
const mainScreenContainerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, mainScreenContainerStyle), { minWidth: '30rem', minHeight: '22rem' // max height of min-height of composite pages (Configuration page)
 }));
/**
 * @private
 */
const mainScreenContainerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, mainScreenContainerStyle), { minWidth: '19.5rem', minHeight: '21rem' // max height of min-height of composite pages (Configuration page)
 }));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$1 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const MainScreen = (props) => {
    const { callInvitationUrl, onRenderAvatar, onFetchAvatarPersonaData, onFetchParticipantMenuItems } = props;
    const page = useSelector$1(getPage);
    const adapter = useAdapter();
    const locale = useLocale();
    switch (page) {
        case 'configuration':
            return (React__default['default'].createElement(ConfigurationPage, { mobileView: props.mobileView, startCallHandler: () => {
                    adapter.joinCall();
                } }));
        case 'accessDeniedTeamsMeeting':
            return (React__default['default'].createElement(NoticePage, { iconName: "NoticePageAccessDeniedTeamsMeeting", title: locale.strings.call.failedToJoinTeamsMeetingReasonAccessDeniedTitle, moreDetails: locale.strings.call.failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails, dataUiId: 'access-denied-teams-meeting-page' }));
        case 'removedFromCall':
            return (React__default['default'].createElement(NoticePage, { iconName: "NoticePageRemovedFromCall", title: locale.strings.call.removedFromCallTitle, moreDetails: locale.strings.call.removedFromCallMoreDetails, dataUiId: 'removed-from-call-page' }));
        case 'joinCallFailedDueToNoNetwork':
            return (React__default['default'].createElement(NoticePage, { iconName: "NoticePageJoinCallFailedDueToNoNetwork", title: locale.strings.call.failedToJoinCallDueToNoNetworkTitle, moreDetails: locale.strings.call.failedToJoinCallDueToNoNetworkMoreDetails, dataUiId: 'join-call-failed-due-to-no-network-page' }));
        case 'leftCall':
            return (React__default['default'].createElement(NoticePage, { iconName: "NoticePageLeftCall", title: locale.strings.call.leftCallTitle, moreDetails: locale.strings.call.leftCallMoreDetails, dataUiId: 'left-call-page' }));
        case 'lobby':
            return React__default['default'].createElement(LobbyPage, { mobileView: props.mobileView, options: props.options });
        case 'call':
            return (React__default['default'].createElement(CallPage, { onRenderAvatar: onRenderAvatar, callInvitationURL: callInvitationUrl, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onFetchParticipantMenuItems: onFetchParticipantMenuItems, mobileView: props.mobileView, options: props.options }));
        default:
            throw new Error('Invalid call composite page');
    }
};
/**
 * A customizable UI composite for calling experience.
 *
 * @remarks Call composite min width/height are as follow:
 * - mobile: 19.5rem x 21rem (312px x 336px, with default rem at 16px)
 * - desktop: 30rem x 22rem (480px x 352px, with default rem at 16px)
 *
 * @public
 */
const CallComposite = (props) => {
    const { adapter, callInvitationUrl, onFetchAvatarPersonaData, onFetchParticipantMenuItems, options, formFactor = 'desktop' } = props;
    React.useEffect(() => {
        (() => __awaiter$1(void 0, void 0, void 0, function* () {
            yield adapter.askDevicePermission({ video: true, audio: true });
            adapter.queryCameras();
            adapter.queryMicrophones();
            adapter.querySpeakers();
        }))();
    }, [adapter]);
    const mobileView = formFactor === 'mobile';
    const mainScreenContainerClassName = React.useMemo(() => {
        return mobileView ? mainScreenContainerStyleMobile : mainScreenContainerStyleDesktop;
    }, [mobileView]);
    return (React__default['default'].createElement("div", { className: mainScreenContainerClassName },
        React__default['default'].createElement(BaseComposite, Object.assign({}, props),
            React__default['default'].createElement(CallAdapterProvider, { adapter: adapter },
                React__default['default'].createElement(MainScreen, { callInvitationUrl: callInvitationUrl, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onFetchParticipantMenuItems: onFetchParticipantMenuItems, mobileView: mobileView, options: options })))));
};

/**
 * @private
 */
class ParticipantSubscriber {
    constructor(participant, emitter) {
        this.isMutedChangedHandler = () => {
            this.emitter.emit('isMutedChanged', {
                participantId: this.participant.identifier,
                isMuted: this.participant.isMuted
            });
        };
        this.displayNameChangedHandler = () => {
            this.emitter.emit('displayNameChanged', {
                participantId: this.participant.identifier,
                displayName: this.participant.displayName
            });
        };
        this.isSpeakingChangedHandler = () => {
            this.emitter.emit('isSpeakingChanged', {
                participantId: this.participant.identifier,
                isSpeaking: this.participant.isSpeaking
            });
        };
        this.videoStreamsUpdatedHandler = (event) => {
            this.emitter.emit('videoStreamsUpdated', event);
        };
        this.participant = participant;
        this.emitter = emitter;
        this.subscribeParticipantEvents();
    }
    subscribeParticipantEvents() {
        this.participant.on('isMutedChanged', this.isMutedChangedHandler);
        this.participant.on('displayNameChanged', this.displayNameChangedHandler);
        this.participant.on('isSpeakingChanged', this.isSpeakingChangedHandler);
        this.participant.on('videoStreamsUpdated', this.videoStreamsUpdatedHandler);
    }
    unsubscribeAll() {
        this.participant.off('isMutedChanged', this.isMutedChangedHandler);
        this.participant.off('displayNameChanged', this.displayNameChangedHandler);
        this.participant.off('isSpeakingChanged', this.isSpeakingChangedHandler);
        this.participant.off('videoStreamsUpdated', this.videoStreamsUpdatedHandler);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
class DiagnosticsForwarder {
    constructor(emitter, call) {
        this.unsubscribe = () => {
            this._diagnostics.network.off('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
            this._diagnostics.media.off('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
        };
        this._diagnostics = call.feature(communicationCalling.Features.UserFacingDiagnostics);
        this._emitter = emitter;
        this.subscribe();
    }
    subscribe() {
        this._diagnostics.network.on('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
        this._diagnostics.media.on('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
    }
    networkDiagnosticsChanged(args) {
        const event = Object.assign({ type: 'network' }, args);
        this._emitter.emit('diagnosticChanged', event);
    }
    mediaDiagnosticsChanged(args) {
        const event = Object.assign({ type: 'media' }, args);
        this._emitter.emit('diagnosticChanged', event);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/** Context of call, which is a centralized context for all state updates */
class CallContext {
    constructor(clientState, isTeamsCall) {
        var _a;
        this.emitter = new EventEmitter.EventEmitter();
        this.state = {
            isLocalPreviewMicrophoneEnabled: false,
            userId: clientState.userId,
            displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName,
            devices: clientState.deviceManager,
            call: undefined,
            page: 'configuration',
            latestErrors: clientState.latestErrors,
            isTeamsCall
        };
    }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    setIsLocalMicrophoneEnabled(isLocalPreviewMicrophoneEnabled) {
        this.setState(Object.assign(Object.assign({}, this.state), { isLocalPreviewMicrophoneEnabled }));
    }
    setCallId(callId) {
        this.callId = callId;
    }
    updateClientState(clientState) {
        var _a;
        const call = this.callId ? clientState.calls[this.callId] : undefined;
        const latestEndedCall = findLatestEndedCall(clientState.callsEnded);
        this.setState(Object.assign(Object.assign({}, this.state), { userId: clientState.userId, displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName, call, page: getCallCompositePage(call, latestEndedCall), endedCall: latestEndedCall, devices: clientState.deviceManager, latestErrors: clientState.latestErrors }));
    }
}
const findLatestEndedCall = (calls) => {
    var _a, _b, _c, _d;
    const callStates = Object.values(calls);
    if (callStates.length === 0) {
        return undefined;
    }
    let latestCall = callStates[0];
    for (const call of callStates.slice(1)) {
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) > ((_d = (_c = latestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            latestCall = call;
        }
    }
    return latestCall;
};
/**
 * @private
 */
class AzureCommunicationCallAdapter {
    constructor(callClient, locator, callAgent, deviceManager) {
        this.participantSubscribers = new Map();
        this.emitter = new EventEmitter.EventEmitter();
        this.isMyMutedChanged = () => {
            var _a;
            this.emitter.emit('isMutedChanged', {
                participantId: this.getState().userId,
                isMuted: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isMuted
            });
        };
        this.bindPublicMethods();
        this.callClient = callClient;
        this.callAgent = callAgent;
        this.locator = locator;
        this.deviceManager = deviceManager;
        const isTeamsMeeting = 'meetingLink' in this.locator;
        this.context = new CallContext(callClient.getState(), isTeamsMeeting);
        const onStateChange = (clientState) => {
            // unsubscribe when the instance gets disposed
            if (!this) {
                callClient.offStateChange(onStateChange);
                return;
            }
            this.context.updateClientState(clientState);
        };
        this.handlers = createDefaultCallingHandlers(callClient, callAgent, deviceManager, undefined);
        this.onClientStateChange = onStateChange;
        this.callClient.onStateChange(onStateChange);
    }
    get call() {
        return this._call;
    }
    set call(newCall) {
        this.resetDiagnosticsForwarder(newCall);
        this._call = newCall;
    }
    bindPublicMethods() {
        this.onStateChange.bind(this);
        this.offStateChange.bind(this);
        this.getState.bind(this);
        this.dispose.bind(this);
        this.joinCall.bind(this);
        this.leaveCall.bind(this);
        this.setCamera.bind(this);
        this.setMicrophone.bind(this);
        this.setSpeaker.bind(this);
        this.askDevicePermission.bind(this);
        this.queryCameras.bind(this);
        this.queryMicrophones.bind(this);
        this.querySpeakers.bind(this);
        this.startCamera.bind(this);
        this.stopCamera.bind(this);
        this.mute.bind(this);
        this.unmute.bind(this);
        this.startCall.bind(this);
        this.startScreenShare.bind(this);
        this.stopScreenShare.bind(this);
        this.removeParticipant.bind(this);
        this.createStreamView.bind(this);
        this.disposeStreamView.bind(this);
        this.on.bind(this);
        this.off.bind(this);
    }
    dispose() {
        this.resetDiagnosticsForwarder();
        this.callClient.offStateChange(this.onClientStateChange);
        this.callAgent.dispose();
    }
    queryCameras() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                return this.deviceManager.getCameras();
            }));
        });
    }
    queryMicrophones() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                return this.deviceManager.getMicrophones();
            }));
        });
    }
    querySpeakers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                return this.deviceManager.isSpeakerSelectionAvailable ? this.deviceManager.getSpeakers() : [];
            }));
        });
    }
    askDevicePermission(constrain) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.deviceManager.askDevicePermission(constrain);
            }));
        });
    }
    joinCall(microphoneOn) {
        var _a, _b;
        if (_isInCall((_b = (_a = this.getState().call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None')) {
            throw new Error('You are already in the call!');
        }
        else {
            const audioOptions = { muted: microphoneOn !== null && microphoneOn !== void 0 ? microphoneOn : !this.getState().isLocalPreviewMicrophoneEnabled };
            // TODO: find a way to expose stream to here
            const videoOptions = { localVideoStreams: this.localStream ? [this.localStream] : undefined };
            const isTeamsMeeting = !('groupId' in this.locator);
            if (isTeamsMeeting) {
                this.call = this.callAgent.join(this.locator, {
                    audioOptions,
                    videoOptions
                });
            }
            else {
                this.call = this.callAgent.join(this.locator, {
                    audioOptions,
                    videoOptions
                });
            }
            this.context.setCallId(this.call.id);
            // Resync state after callId is set
            this.context.updateClientState(this.callClient.getState());
            this.handlers = createDefaultCallingHandlers(this.callClient, this.callAgent, this.deviceManager, this.call);
            this.subscribeCallEvents();
            return this.call;
        }
    }
    createStreamView(remoteUserId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                yield this.handlers.onCreateLocalStreamView(options);
            }
            else {
                yield this.handlers.onCreateRemoteStreamView(remoteUserId, options);
            }
        });
    }
    disposeStreamView(remoteUserId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                yield this.handlers.onDisposeLocalStreamView();
            }
            else {
                yield this.handlers.onDisposeRemoteStreamView(remoteUserId);
            }
        });
    }
    leaveCall() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const callId = (_a = this.call) === null || _a === void 0 ? void 0 : _a.id;
            yield this.handlers.onHangUp();
            this.unsubscribeCallEvents();
            this.call = undefined;
            this.handlers = createDefaultCallingHandlers(this.callClient, this.callAgent, this.deviceManager, undefined);
            this.context.setCallId(undefined);
            // Resync state after callId is set
            this.context.updateClientState(this.callClient.getState());
            this.stopCamera();
            this.mute();
            this.emitter.emit('callEnded', { callId });
        });
    }
    setCamera(device, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.handlers.onSelectCamera(device, options);
            }));
        });
    }
    setMicrophone(device) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.handlers.onSelectMicrophone(device);
            }));
        });
    }
    setSpeaker(device) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.handlers.onSelectSpeaker(device);
            }));
        });
    }
    startCamera(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                if (!isCameraOn(this.getState())) {
                    yield this.handlers.onToggleCamera(options);
                }
            }));
        });
    }
    stopCamera() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                if (isCameraOn(this.getState())) {
                    yield this.handlers.onToggleCamera();
                }
            }));
        });
    }
    mute() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                this.context.setIsLocalMicrophoneEnabled(false);
                if (_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) && !((_b = this.call) === null || _b === void 0 ? void 0 : _b.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    unmute() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                this.context.setIsLocalMicrophoneEnabled(true);
                if (_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) && ((_b = this.call) === null || _b === void 0 ? void 0 : _b.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    startScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (!((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn)) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    stopScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    //TODO: a better way to expose option parameter
    startCall(participants) {
        const idsToAdd = participants.map((participant) => {
            // FIXME: `onStartCall` does not allow a Teams user.
            // Need some way to return an error if a Teams user is provided.
            const backendId = fromFlatCommunicationIdentifier(participant);
            return backendId;
        });
        return this.handlers.onStartCall(idsToAdd);
    }
    removeParticipant(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.handlers.onRemoveParticipant(userId);
        });
    }
    getState() {
        return this.context.getState();
    }
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    subscribeCallEvents() {
        var _a, _b, _c, _d;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.on('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.on('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.on('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.on('idChanged', this.callIdChanged.bind(this));
    }
    unsubscribeCallEvents() {
        var _a, _b, _c, _d;
        for (const subscriber of this.participantSubscribers.values()) {
            subscriber.unsubscribeAll();
        }
        this.participantSubscribers.clear();
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.off('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.off('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.off('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.off('idChanged', this.callIdChanged.bind(this));
    }
    onRemoteParticipantsUpdated({ added, removed }) {
        if (added && added.length > 0) {
            this.emitter.emit('participantsJoined', added);
        }
        if (removed && removed.length > 0) {
            this.emitter.emit('participantsLeft', removed);
        }
        added.forEach((participant) => {
            this.participantSubscribers.set(toFlatCommunicationIdentifier(participant.identifier), new ParticipantSubscriber(participant, this.emitter));
        });
        removed.forEach((participant) => {
            const subscriber = this.participantSubscribers.get(toFlatCommunicationIdentifier(participant.identifier));
            subscriber && subscriber.unsubscribeAll();
            this.participantSubscribers.delete(toFlatCommunicationIdentifier(participant.identifier));
        });
    }
    isScreenSharingOnChanged() {
        var _a;
        this.emitter.emit('isLocalScreenSharingActiveChanged', { isScreenSharingOn: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn });
    }
    callIdChanged() {
        var _a;
        this.context.setCallId((_a = this.call) === null || _a === void 0 ? void 0 : _a.id);
        // Resync state after callId is set
        this.context.updateClientState(this.callClient.getState());
        this.emitter.emit('callIdChanged', { callId: this.callIdChanged.bind(this) });
    }
    resetDiagnosticsForwarder(newCall) {
        if (this.diagnosticsForwarder) {
            this.diagnosticsForwarder.unsubscribe();
        }
        if (newCall) {
            this.diagnosticsForwarder = new DiagnosticsForwarder(this.emitter, newCall);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    off(event, listener) {
        this.emitter.off(event, listener);
    }
    asyncTeeErrorToEventEmitter(f) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield f();
            }
            catch (error) {
                if (isCallError(error)) {
                    this.emitter.emit('error', error);
                }
                throw error;
            }
        });
    }
}
/**
 * Create a {@link CallAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link CallAdapter} provided by this library.
 *
 * Note: `displayName` can be a maximum of 256 characters.
 *
 * @public
 */
const createAzureCommunicationCallAdapter = ({ userId, displayName, credential, locator }) => __awaiter(void 0, void 0, void 0, function* () {
    const callClient = createStatefulCallClient({ userId });
    const callAgent = yield callClient.createCallAgent(credential, { displayName });
    const adapter = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, locator);
    return adapter;
});
/**
 * Create a {@link CallAdapter} using the provided {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulCallClient}.
 * Consider using {@link createAzureCommunicationCallAdapter} for a simpler API.
 *
 * @public
 */
const createAzureCommunicationCallAdapterFromClient = (callClient, callAgent, locator) => __awaiter(void 0, void 0, void 0, function* () {
    const deviceManager = (yield callClient.getDeviceManager());
    return new AzureCommunicationCallAdapter(callClient, locator, callAgent, deviceManager);
});
const isCallError = (e) => {
    return e['target'] !== undefined && e['innerError'] !== undefined;
};

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector = (selector, selectorProps, type) => {
    // Because of react hooks rules, hooks can't be conditionally called
    // We call both call and chat hooks and detect current context
    // Return undefined and skip execution when not in that context
    const callingMode = !type || type === 'calling';
    const chatMode = !type || type === 'chat';
    const callProps = useSelector$3(callingMode ? selector : undefined, selectorProps);
    const chatProps = useSelector$2(chatMode ? selector : undefined, selectorProps);
    return callProps !== null && callProps !== void 0 ? callProps : chatProps;
};
/**
 * Primary hook to get all hooks necessary for a React Component from this library..
 *
 * Most straightforward usage of a components looks like:
 *
 * @example
 * ```
 *     import { ParticipantList, usePropsFor } from '@azure/communication-react';
 *
 *     const App = (): JSX.Element => {
 *         // ... code to setup Providers ...
 *
 *         return <ParticipantList {...usePropsFor(ParticipantList)}/>
 *     }
 * ```
 *
 * @public
 */
const usePropsFor = (component, type) => {
    const callingSelector = type === 'calling' || !type ? getSelector$1(component) : undefined;
    const chatSelector = type === 'chat' || !type ? getSelector(component) : undefined;
    const callProps = useSelector$3(callingSelector);
    const chatProps = useSelector$2(chatSelector);
    const callingHandlers = useHandlers$3();
    const chatHandlers = useHandlers$2();
    if (chatProps) {
        if (!chatHandlers) {
            throw 'Please initialize chatClient and chatThreadClient first!';
        }
        return Object.assign(Object.assign({}, chatProps), chatHandlers);
    }
    if (callProps) {
        if (!callingHandlers) {
            throw 'Please initialize callClient first!';
        }
        return Object.assign(Object.assign({}, callProps), callingHandlers);
    }
    throw "Can't find corresponding selector for this component. Please check the supported components from Azure Communication UI Feature Component List.";
};

exports.COMPONENT_LOCALE_DE_DE = COMPONENT_LOCALE_DE_DE;
exports.COMPONENT_LOCALE_EN_GB = COMPONENT_LOCALE_EN_GB;
exports.COMPONENT_LOCALE_EN_US = COMPONENT_LOCALE_EN_US;
exports.COMPONENT_LOCALE_ES_ES = COMPONENT_LOCALE_ES_ES;
exports.COMPONENT_LOCALE_FR_FR = COMPONENT_LOCALE_FR_FR;
exports.COMPONENT_LOCALE_IT_IT = COMPONENT_LOCALE_IT_IT;
exports.COMPONENT_LOCALE_JA_JP = COMPONENT_LOCALE_JA_JP;
exports.COMPONENT_LOCALE_KO_KR = COMPONENT_LOCALE_KO_KR;
exports.COMPONENT_LOCALE_NL_NL = COMPONENT_LOCALE_NL_NL;
exports.COMPONENT_LOCALE_PT_BR = COMPONENT_LOCALE_PT_BR;
exports.COMPONENT_LOCALE_RU_RU = COMPONENT_LOCALE_RU_RU;
exports.COMPONENT_LOCALE_TR_TR = COMPONENT_LOCALE_TR_TR;
exports.COMPONENT_LOCALE_ZH_CN = COMPONENT_LOCALE_ZH_CN;
exports.COMPONENT_LOCALE_ZH_TW = COMPONENT_LOCALE_ZH_TW;
exports.COMPOSITE_LOCALE_DE_DE = COMPOSITE_LOCALE_DE_DE;
exports.COMPOSITE_LOCALE_EN_GB = COMPOSITE_LOCALE_EN_GB;
exports.COMPOSITE_LOCALE_EN_US = COMPOSITE_LOCALE_EN_US;
exports.COMPOSITE_LOCALE_ES_ES = COMPOSITE_LOCALE_ES_ES;
exports.COMPOSITE_LOCALE_FR_FR = COMPOSITE_LOCALE_FR_FR;
exports.COMPOSITE_LOCALE_IT_IT = COMPOSITE_LOCALE_IT_IT;
exports.COMPOSITE_LOCALE_JA_JP = COMPOSITE_LOCALE_JA_JP;
exports.COMPOSITE_LOCALE_KO_KR = COMPOSITE_LOCALE_KO_KR;
exports.COMPOSITE_LOCALE_NL_NL = COMPOSITE_LOCALE_NL_NL;
exports.COMPOSITE_LOCALE_PT_BR = COMPOSITE_LOCALE_PT_BR;
exports.COMPOSITE_LOCALE_RU_RU = COMPOSITE_LOCALE_RU_RU;
exports.COMPOSITE_LOCALE_TR_TR = COMPOSITE_LOCALE_TR_TR;
exports.COMPOSITE_LOCALE_ZH_CN = COMPOSITE_LOCALE_ZH_CN;
exports.COMPOSITE_LOCALE_ZH_TW = COMPOSITE_LOCALE_ZH_TW;
exports.COMPOSITE_ONLY_ICONS = COMPOSITE_ONLY_ICONS;
exports.CallAgentProvider = CallAgentProvider;
exports.CallClientProvider = CallClientProvider;
exports.CallComposite = CallComposite;
exports.CallProvider = CallProvider;
exports.CameraButton = CameraButton;
exports.ChatClientProvider = ChatClientProvider;
exports.ChatComposite = ChatComposite;
exports.ChatThreadClientProvider = ChatThreadClientProvider;
exports.ControlBar = ControlBar;
exports.ControlBarButton = ControlBarButton;
exports.DEFAULT_COMPONENT_ICONS = DEFAULT_COMPONENT_ICONS;
exports.DEFAULT_COMPOSITE_ICONS = DEFAULT_COMPOSITE_ICONS;
exports.DevicesButton = DevicesButton;
exports.EndCallButton = EndCallButton;
exports.ErrorBar = ErrorBar;
exports.FluentThemeProvider = FluentThemeProvider;
exports.GridLayout = GridLayout;
exports.LocalizationProvider = LocalizationProvider$1;
exports.MessageStatusIndicator = MessageStatusIndicator;
exports.MessageThread = MessageThread;
exports.MicrophoneButton = MicrophoneButton;
exports.ParticipantItem = ParticipantItem;
exports.ParticipantList = ParticipantList;
exports.ParticipantsButton = ParticipantsButton;
exports.ScreenShareButton = ScreenShareButton;
exports.SendBox = SendBox;
exports.StreamMedia = StreamMedia;
exports.TypingIndicator = TypingIndicator;
exports.VideoGallery = VideoGallery;
exports.VideoTile = VideoTile;
exports._IdentifierProvider = _IdentifierProvider;
exports.createAzureCommunicationCallAdapter = createAzureCommunicationCallAdapter;
exports.createAzureCommunicationCallAdapterFromClient = createAzureCommunicationCallAdapterFromClient;
exports.createAzureCommunicationChatAdapter = createAzureCommunicationChatAdapter;
exports.createAzureCommunicationChatAdapterFromClient = createAzureCommunicationChatAdapterFromClient;
exports.createDefaultCallingHandlers = createDefaultCallingHandlers;
exports.createDefaultChatHandlers = createDefaultChatHandlers;
exports.createStatefulCallClient = createStatefulCallClient;
exports.createStatefulChatClient = createStatefulChatClient;
exports.darkTheme = darkTheme;
exports.fromFlatCommunicationIdentifier = fromFlatCommunicationIdentifier;
exports.getCallingSelector = getSelector$1;
exports.getChatSelector = getSelector;
exports.lightTheme = lightTheme;
exports.toFlatCommunicationIdentifier = toFlatCommunicationIdentifier;
exports.useCall = useCall;
exports.useCallAgent = useCallAgent;
exports.useCallClient = useCallClient;
exports.useChatClient = useChatClient;
exports.useChatThreadClient = useChatThreadClient;
exports.useDeviceManager = useDeviceManager;
exports.usePropsFor = usePropsFor;
exports.useSelector = useSelector;
exports.useTheme = useTheme;
//# sourceMappingURL=index.js.map
