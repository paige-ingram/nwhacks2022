// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createDefaultCallingHandlers, _isInCall } from "../../../../../calling-component-bindings/src";
import { createStatefulCallClient } from "../../../../../calling-stateful-client/src";
import { EventEmitter } from 'events';
import { getCallCompositePage, isCameraOn } from '../utils';
import { fromFlatCommunicationIdentifier, toFlatCommunicationIdentifier } from "../../../../../acs-ui-common/src";
import { ParticipantSubscriber } from './ParticipantSubcriber';
import { DiagnosticsForwarder } from './DiagnosticsForwarder';
/** Context of call, which is a centralized context for all state updates */
class CallContext {
    constructor(clientState, isTeamsCall) {
        var _a;
        this.emitter = new EventEmitter();
        this.state = {
            isLocalPreviewMicrophoneEnabled: false,
            userId: clientState.userId,
            displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName,
            devices: clientState.deviceManager,
            call: undefined,
            page: 'configuration',
            latestErrors: clientState.latestErrors,
            isTeamsCall
        };
    }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    setIsLocalMicrophoneEnabled(isLocalPreviewMicrophoneEnabled) {
        this.setState(Object.assign(Object.assign({}, this.state), { isLocalPreviewMicrophoneEnabled }));
    }
    setCallId(callId) {
        this.callId = callId;
    }
    updateClientState(clientState) {
        var _a;
        const call = this.callId ? clientState.calls[this.callId] : undefined;
        const latestEndedCall = findLatestEndedCall(clientState.callsEnded);
        this.setState(Object.assign(Object.assign({}, this.state), { userId: clientState.userId, displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName, call, page: getCallCompositePage(call, latestEndedCall), endedCall: latestEndedCall, devices: clientState.deviceManager, latestErrors: clientState.latestErrors }));
    }
}
const findLatestEndedCall = (calls) => {
    var _a, _b, _c, _d;
    const callStates = Object.values(calls);
    if (callStates.length === 0) {
        return undefined;
    }
    let latestCall = callStates[0];
    for (const call of callStates.slice(1)) {
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) > ((_d = (_c = latestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            latestCall = call;
        }
    }
    return latestCall;
};
/**
 * @private
 */
export class AzureCommunicationCallAdapter {
    constructor(callClient, locator, callAgent, deviceManager) {
        this.participantSubscribers = new Map();
        this.emitter = new EventEmitter();
        this.isMyMutedChanged = () => {
            var _a;
            this.emitter.emit('isMutedChanged', {
                participantId: this.getState().userId,
                isMuted: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isMuted
            });
        };
        this.bindPublicMethods();
        this.callClient = callClient;
        this.callAgent = callAgent;
        this.locator = locator;
        this.deviceManager = deviceManager;
        const isTeamsMeeting = 'meetingLink' in this.locator;
        this.context = new CallContext(callClient.getState(), isTeamsMeeting);
        const onStateChange = (clientState) => {
            // unsubscribe when the instance gets disposed
            if (!this) {
                callClient.offStateChange(onStateChange);
                return;
            }
            this.context.updateClientState(clientState);
        };
        this.handlers = createDefaultCallingHandlers(callClient, callAgent, deviceManager, undefined);
        this.onClientStateChange = onStateChange;
        this.callClient.onStateChange(onStateChange);
    }
    get call() {
        return this._call;
    }
    set call(newCall) {
        this.resetDiagnosticsForwarder(newCall);
        this._call = newCall;
    }
    bindPublicMethods() {
        this.onStateChange.bind(this);
        this.offStateChange.bind(this);
        this.getState.bind(this);
        this.dispose.bind(this);
        this.joinCall.bind(this);
        this.leaveCall.bind(this);
        this.setCamera.bind(this);
        this.setMicrophone.bind(this);
        this.setSpeaker.bind(this);
        this.askDevicePermission.bind(this);
        this.queryCameras.bind(this);
        this.queryMicrophones.bind(this);
        this.querySpeakers.bind(this);
        this.startCamera.bind(this);
        this.stopCamera.bind(this);
        this.mute.bind(this);
        this.unmute.bind(this);
        this.startCall.bind(this);
        this.startScreenShare.bind(this);
        this.stopScreenShare.bind(this);
        this.removeParticipant.bind(this);
        this.createStreamView.bind(this);
        this.disposeStreamView.bind(this);
        this.on.bind(this);
        this.off.bind(this);
    }
    dispose() {
        this.resetDiagnosticsForwarder();
        this.callClient.offStateChange(this.onClientStateChange);
        this.callAgent.dispose();
    }
    queryCameras() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                return this.deviceManager.getCameras();
            }));
        });
    }
    queryMicrophones() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                return this.deviceManager.getMicrophones();
            }));
        });
    }
    querySpeakers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                return this.deviceManager.isSpeakerSelectionAvailable ? this.deviceManager.getSpeakers() : [];
            }));
        });
    }
    askDevicePermission(constrain) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.deviceManager.askDevicePermission(constrain);
            }));
        });
    }
    joinCall(microphoneOn) {
        var _a, _b;
        if (_isInCall((_b = (_a = this.getState().call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None')) {
            throw new Error('You are already in the call!');
        }
        else {
            const audioOptions = { muted: microphoneOn !== null && microphoneOn !== void 0 ? microphoneOn : !this.getState().isLocalPreviewMicrophoneEnabled };
            // TODO: find a way to expose stream to here
            const videoOptions = { localVideoStreams: this.localStream ? [this.localStream] : undefined };
            const isTeamsMeeting = !('groupId' in this.locator);
            if (isTeamsMeeting) {
                this.call = this.callAgent.join(this.locator, {
                    audioOptions,
                    videoOptions
                });
            }
            else {
                this.call = this.callAgent.join(this.locator, {
                    audioOptions,
                    videoOptions
                });
            }
            this.context.setCallId(this.call.id);
            // Resync state after callId is set
            this.context.updateClientState(this.callClient.getState());
            this.handlers = createDefaultCallingHandlers(this.callClient, this.callAgent, this.deviceManager, this.call);
            this.subscribeCallEvents();
            return this.call;
        }
    }
    createStreamView(remoteUserId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                yield this.handlers.onCreateLocalStreamView(options);
            }
            else {
                yield this.handlers.onCreateRemoteStreamView(remoteUserId, options);
            }
        });
    }
    disposeStreamView(remoteUserId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                yield this.handlers.onDisposeLocalStreamView();
            }
            else {
                yield this.handlers.onDisposeRemoteStreamView(remoteUserId);
            }
        });
    }
    leaveCall() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const callId = (_a = this.call) === null || _a === void 0 ? void 0 : _a.id;
            yield this.handlers.onHangUp();
            this.unsubscribeCallEvents();
            this.call = undefined;
            this.handlers = createDefaultCallingHandlers(this.callClient, this.callAgent, this.deviceManager, undefined);
            this.context.setCallId(undefined);
            // Resync state after callId is set
            this.context.updateClientState(this.callClient.getState());
            this.stopCamera();
            this.mute();
            this.emitter.emit('callEnded', { callId });
        });
    }
    setCamera(device, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.handlers.onSelectCamera(device, options);
            }));
        });
    }
    setMicrophone(device) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.handlers.onSelectMicrophone(device);
            }));
        });
    }
    setSpeaker(device) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                yield this.handlers.onSelectSpeaker(device);
            }));
        });
    }
    startCamera(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                if (!isCameraOn(this.getState())) {
                    yield this.handlers.onToggleCamera(options);
                }
            }));
        });
    }
    stopCamera() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                if (isCameraOn(this.getState())) {
                    yield this.handlers.onToggleCamera();
                }
            }));
        });
    }
    mute() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                this.context.setIsLocalMicrophoneEnabled(false);
                if (_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) && !((_b = this.call) === null || _b === void 0 ? void 0 : _b.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    unmute() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                this.context.setIsLocalMicrophoneEnabled(true);
                if (_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) && ((_b = this.call) === null || _b === void 0 ? void 0 : _b.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    startScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (!((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn)) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    stopScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    //TODO: a better way to expose option parameter
    startCall(participants) {
        const idsToAdd = participants.map((participant) => {
            // FIXME: `onStartCall` does not allow a Teams user.
            // Need some way to return an error if a Teams user is provided.
            const backendId = fromFlatCommunicationIdentifier(participant);
            return backendId;
        });
        return this.handlers.onStartCall(idsToAdd);
    }
    removeParticipant(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.handlers.onRemoveParticipant(userId);
        });
    }
    getState() {
        return this.context.getState();
    }
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    subscribeCallEvents() {
        var _a, _b, _c, _d;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.on('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.on('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.on('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.on('idChanged', this.callIdChanged.bind(this));
    }
    unsubscribeCallEvents() {
        var _a, _b, _c, _d;
        for (const subscriber of this.participantSubscribers.values()) {
            subscriber.unsubscribeAll();
        }
        this.participantSubscribers.clear();
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.off('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.off('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.off('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.off('idChanged', this.callIdChanged.bind(this));
    }
    onRemoteParticipantsUpdated({ added, removed }) {
        if (added && added.length > 0) {
            this.emitter.emit('participantsJoined', added);
        }
        if (removed && removed.length > 0) {
            this.emitter.emit('participantsLeft', removed);
        }
        added.forEach((participant) => {
            this.participantSubscribers.set(toFlatCommunicationIdentifier(participant.identifier), new ParticipantSubscriber(participant, this.emitter));
        });
        removed.forEach((participant) => {
            const subscriber = this.participantSubscribers.get(toFlatCommunicationIdentifier(participant.identifier));
            subscriber && subscriber.unsubscribeAll();
            this.participantSubscribers.delete(toFlatCommunicationIdentifier(participant.identifier));
        });
    }
    isScreenSharingOnChanged() {
        var _a;
        this.emitter.emit('isLocalScreenSharingActiveChanged', { isScreenSharingOn: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn });
    }
    callIdChanged() {
        var _a;
        this.context.setCallId((_a = this.call) === null || _a === void 0 ? void 0 : _a.id);
        // Resync state after callId is set
        this.context.updateClientState(this.callClient.getState());
        this.emitter.emit('callIdChanged', { callId: this.callIdChanged.bind(this) });
    }
    resetDiagnosticsForwarder(newCall) {
        if (this.diagnosticsForwarder) {
            this.diagnosticsForwarder.unsubscribe();
        }
        if (newCall) {
            this.diagnosticsForwarder = new DiagnosticsForwarder(this.emitter, newCall);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    off(event, listener) {
        this.emitter.off(event, listener);
    }
    asyncTeeErrorToEventEmitter(f) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield f();
            }
            catch (error) {
                if (isCallError(error)) {
                    this.emitter.emit('error', error);
                }
                throw error;
            }
        });
    }
}
/**
 * Create a {@link CallAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link CallAdapter} provided by this library.
 *
 * Note: `displayName` can be a maximum of 256 characters.
 *
 * @public
 */
export const createAzureCommunicationCallAdapter = ({ userId, displayName, credential, locator }) => __awaiter(void 0, void 0, void 0, function* () {
    const callClient = createStatefulCallClient({ userId });
    const callAgent = yield callClient.createCallAgent(credential, { displayName });
    const adapter = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, locator);
    return adapter;
});
/**
 * Create a {@link CallAdapter} using the provided {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulCallClient}.
 * Consider using {@link createAzureCommunicationCallAdapter} for a simpler API.
 *
 * @public
 */
export const createAzureCommunicationCallAdapterFromClient = (callClient, callAgent, locator) => __awaiter(void 0, void 0, void 0, function* () {
    const deviceManager = (yield callClient.getDeviceManager());
    return new AzureCommunicationCallAdapter(callClient, locator, callAgent, deviceManager);
});
const isCallError = (e) => {
    return e['target'] !== undefined && e['innerError'] !== undefined;
};
//# sourceMappingURL=AzureCommunicationCallAdapter.js.map