// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { fromFlatCommunicationIdentifier } from "../../../acs-ui-common/src";
import memoizeOne from 'memoize-one';
/**
 * Create the default implementation of {@link ChatHandlers}.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * Returned object is memoized to avoid rerenders when used as props for React Components.
 *
 * @public
 */
export const createDefaultChatHandlers = memoizeOne((chatClient, chatThreadClient) => {
    let messageIterator = undefined;
    return {
        onSendMessage: (content) => __awaiter(void 0, void 0, void 0, function* () {
            const sendMessageRequest = {
                content,
                senderDisplayName: chatClient.getState().displayName
            };
            yield chatThreadClient.sendMessage(sendMessageRequest);
        }),
        onUpdateMessage: (messageId, content) => __awaiter(void 0, void 0, void 0, function* () {
            yield chatThreadClient.updateMessage(messageId, { content });
        }),
        onDeleteMessage: (messageId) => __awaiter(void 0, void 0, void 0, function* () {
            yield chatThreadClient.deleteMessage(messageId);
        }),
        // This handler is designed for chatThread to consume
        onMessageSeen: (chatMessageId) => __awaiter(void 0, void 0, void 0, function* () {
            yield chatThreadClient.sendReadReceipt({ chatMessageId });
        }),
        onTyping: () => __awaiter(void 0, void 0, void 0, function* () {
            yield chatThreadClient.sendTypingNotification();
        }),
        onRemoveParticipant: (userId) => __awaiter(void 0, void 0, void 0, function* () {
            yield chatThreadClient.removeParticipant(fromFlatCommunicationIdentifier(userId));
        }),
        updateThreadTopicName: (topicName) => __awaiter(void 0, void 0, void 0, function* () {
            yield chatThreadClient.updateTopic(topicName);
        }),
        onLoadPreviousChatMessages: (messagesToLoad) => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            if (messageIterator === undefined) {
                // Lazy definition so that errors in the method call are reported correctly.
                // Also allows recovery via retries in case of transient errors.
                messageIterator = chatThreadClient.listMessages({ maxPageSize: 50 });
            }
            let remainingMessagesToGet = messagesToLoad;
            let isAllChatMessagesLoaded = false;
            while (remainingMessagesToGet >= 1) {
                const message = yield messageIterator.next();
                if (((_a = message.value) === null || _a === void 0 ? void 0 : _a.type) && message.value.type === 'text') {
                    remainingMessagesToGet--;
                }
                // We have traversed all messages in this thread
                if (message.done) {
                    isAllChatMessagesLoaded = true;
                    break;
                }
            }
            return isAllChatMessagesLoaded;
        })
    };
});
/**
 * Create a set of default handlers for given component.
 *
 * Returned object is memoized (with reference to the arguments) to avoid
 * renders when used as props for React Components.
 *
 * @public
 */
export const createDefaultChatHandlersForComponent = (chatClient, chatThreadClient, _) => {
    return createDefaultChatHandlers(chatClient, chatThreadClient);
};
//# sourceMappingURL=createHandlers.js.map