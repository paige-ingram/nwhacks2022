// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { getChatMessages, getIsLargeGroup, getLatestReadTime, getUserId } from './baseSelectors';
import { toFlatCommunicationIdentifier } from "../../acs-ui-common/src";
import { memoizeFnAll } from "../../acs-ui-common/src";
import { createSelector } from 'reselect';
import { ACSKnownMessageType } from './utils/constants';
import { updateMessagesWithAttached } from './utils/updateMessagesWithAttached';
const memoizedAllConvertChatMessage = memoizeFnAll((_key, chatMessage, userId, isSeen, isLargeGroup) => {
    const messageType = chatMessage.type.toLowerCase();
    if (messageType === ACSKnownMessageType.text ||
        messageType === ACSKnownMessageType.richtextHtml ||
        messageType === ACSKnownMessageType.html) {
        return convertToUiChatMessage(chatMessage, userId, isSeen, isLargeGroup);
    }
    else {
        return convertToUiSystemMessage(chatMessage);
    }
});
const convertToUiChatMessage = (message, userId, isSeen, isLargeGroup) => {
    var _a;
    const messageSenderId = message.sender !== undefined ? toFlatCommunicationIdentifier(message.sender) : userId;
    return {
        messageType: 'chat',
        createdOn: message.createdOn,
        content: (_a = message.content) === null || _a === void 0 ? void 0 : _a.message,
        contentType: sanitizedMessageContentType(message.type),
        status: !isLargeGroup && message.status === 'delivered' && isSeen ? 'seen' : message.status,
        senderDisplayName: message.senderDisplayName,
        senderId: messageSenderId,
        messageId: message.id,
        clientMessageId: message.clientMessageId,
        editedOn: message.editedOn,
        deletedOn: message.deletedOn,
        mine: messageSenderId === userId
    };
};
const convertToUiSystemMessage = (message) => {
    var _a, _b, _c, _d, _e;
    const systemMessageType = message.type;
    if (systemMessageType === 'participantAdded' || systemMessageType === 'participantRemoved') {
        return {
            messageType: 'system',
            systemMessageType,
            createdOn: message.createdOn,
            participants: (_c = (_b = (_a = message.content) === null || _a === void 0 ? void 0 : _a.participants) === null || _b === void 0 ? void 0 : _b.filter((participant) => participant.displayName && participant.displayName !== '').map((participant) => ({
                userId: toFlatCommunicationIdentifier(participant.id),
                displayName: participant.displayName
            }))) !== null && _c !== void 0 ? _c : [],
            messageId: message.id,
            iconName: systemMessageType === 'participantAdded' ? 'PeopleAdd' : 'PeopleBlock'
        };
    }
    else {
        // Only topic updated type left, according to ACSKnown type
        return {
            messageType: 'system',
            systemMessageType: 'topicUpdated',
            createdOn: message.createdOn,
            topic: (_e = (_d = message.content) === null || _d === void 0 ? void 0 : _d.topic) !== null && _e !== void 0 ? _e : '',
            messageId: message.id,
            iconName: 'Edit'
        };
    }
};
/** Returns `true` if the message has participants and at least one participant has a display name. */
const hasValidParticipant = (chatMessage) => { var _a; return !!((_a = chatMessage.content) === null || _a === void 0 ? void 0 : _a.participants) && chatMessage.content.participants.some((p) => !!p.displayName); };
/**
 * Selector for {@link MessageThread} component.
 *
 * @public
 */
export const messageThreadSelector = createSelector([getUserId, getChatMessages, getLatestReadTime, getIsLargeGroup], (userId, chatMessages, latestReadTime, isLargeGroup) => {
    // A function takes parameter above and generate return value
    const convertedMessages = memoizedAllConvertChatMessage((memoizedFn) => Object.values(chatMessages)
        .filter((message) => message.type.toLowerCase() === ACSKnownMessageType.text ||
        message.type.toLowerCase() === ACSKnownMessageType.richtextHtml ||
        message.type.toLowerCase() === ACSKnownMessageType.html ||
        (message.type === ACSKnownMessageType.participantAdded && hasValidParticipant(message)) ||
        (message.type === ACSKnownMessageType.participantRemoved && hasValidParticipant(message)) ||
        // TODO: Add support for topicUpdated system messages in MessageThread component.
        // message.type === ACSKnownMessageType.topicUpdated ||
        message.clientMessageId !== undefined)
        .filter((message) => message.content && message.content.message !== '') // TODO: deal with deleted message and remove
        .map((message) => {
        var _a;
        return memoizedFn((_a = message.id) !== null && _a !== void 0 ? _a : message.clientMessageId, message, userId, message.createdOn <= latestReadTime, isLargeGroup);
    }));
    updateMessagesWithAttached(convertedMessages, userId);
    return {
        userId,
        showMessageStatus: !isLargeGroup,
        messages: convertedMessages
    };
});
const sanitizedMessageContentType = (type) => {
    const lowerCaseType = type.toLowerCase();
    return lowerCaseType === 'text' || lowerCaseType === 'html' || lowerCaseType === 'richtext/html'
        ? lowerCaseType
        : 'unknown';
};
//# sourceMappingURL=messageThreadSelector.js.map