// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { LocalVideoStream } from '@azure/communication-calling';
import { fromFlatCommunicationIdentifier, toFlatCommunicationIdentifier } from "../../../acs-ui-common/src";
import memoizeOne from 'memoize-one';
import { disposeAllLocalPreviewViews, _isInCall, _isPreviewOn } from '../callUtils';
/**
 * @private
 */
export const areStreamsEqual = (prevStream, newStream) => {
    return !!prevStream && !!newStream && prevStream.source.id === newStream.source.id;
};
/**
 * Create the default implementation of {@link CallingHandlers}.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
export const createDefaultCallingHandlers = memoizeOne((callClient, callAgent, deviceManager, call) => {
    const onStartLocalVideo = () => __awaiter(void 0, void 0, void 0, function* () {
        // Before the call object creates a stream, dispose of any local preview streams.
        // @TODO: is there any way to parent the unparented view to the call object instead
        // of disposing and creating a new stream?
        yield onDisposeLocalStreamView();
        const callId = call === null || call === void 0 ? void 0 : call.id;
        let videoDeviceInfo = callClient.getState().deviceManager.selectedCamera;
        if (!videoDeviceInfo) {
            const cameras = yield (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.getCameras());
            videoDeviceInfo = cameras && cameras.length > 0 ? cameras[0] : undefined;
            videoDeviceInfo && (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.selectCamera(videoDeviceInfo));
        }
        if (!callId || !videoDeviceInfo) {
            return;
        }
        const stream = new LocalVideoStream(videoDeviceInfo);
        if (call && !call.localVideoStreams.find((s) => areStreamsEqual(s, stream))) {
            yield call.startVideo(stream);
        }
    });
    const onStopLocalVideo = (stream) => __awaiter(void 0, void 0, void 0, function* () {
        const callId = call === null || call === void 0 ? void 0 : call.id;
        if (!callId) {
            return;
        }
        if (call && call.localVideoStreams.find((s) => areStreamsEqual(s, stream))) {
            yield call.stopVideo(stream);
            yield callClient.disposeView(callId, undefined, {
                source: stream.source,
                mediaStreamType: stream.mediaStreamType
            });
        }
    });
    const onToggleCamera = (options) => __awaiter(void 0, void 0, void 0, function* () {
        if (call && _isInCall(call.state)) {
            const stream = call.localVideoStreams.find((stream) => stream.mediaStreamType === 'Video');
            if (stream) {
                yield onStopLocalVideo(stream);
            }
            else {
                yield onStartLocalVideo();
            }
        }
        else {
            const selectedCamera = callClient.getState().deviceManager.selectedCamera;
            if (selectedCamera) {
                const previewOn = _isPreviewOn(callClient.getState().deviceManager);
                if (previewOn) {
                    yield onDisposeLocalStreamView();
                }
                else {
                    yield callClient.createView(undefined, undefined, {
                        source: selectedCamera,
                        mediaStreamType: 'Video'
                    }, options);
                }
            }
        }
    });
    // FIXME: onStartCall API should use string, not the underlying SDK types.
    const onStartCall = (participants, options) => {
        return callAgent ? callAgent.startCall(participants, options) : undefined;
    };
    const onSelectMicrophone = (device) => __awaiter(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        return deviceManager.selectMicrophone(device);
    });
    const onSelectSpeaker = (device) => __awaiter(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        return deviceManager.selectSpeaker(device);
    });
    const onSelectCamera = (device, options) => __awaiter(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        if (call && _isInCall(call.state)) {
            deviceManager.selectCamera(device);
            const stream = call.localVideoStreams.find((stream) => stream.mediaStreamType === 'Video');
            return stream === null || stream === void 0 ? void 0 : stream.switchSource(device);
        }
        else {
            const previewOn = _isPreviewOn(callClient.getState().deviceManager);
            if (!previewOn) {
                deviceManager.selectCamera(device);
                return;
            }
            yield onDisposeLocalStreamView();
            deviceManager.selectCamera(device);
            yield callClient.createView(undefined, undefined, {
                source: device,
                mediaStreamType: 'Video'
            }, options);
        }
    });
    const onToggleMicrophone = () => __awaiter(void 0, void 0, void 0, function* () {
        if (!call || !_isInCall(call.state)) {
            throw new Error(`Please invoke onToggleMicrophone after call is started`);
        }
        return call.isMuted ? yield call.unmute() : yield call.mute();
    });
    const onStartScreenShare = () => __awaiter(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.startScreenSharing()); });
    const onStopScreenShare = () => __awaiter(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.stopScreenSharing()); });
    const onToggleScreenShare = () => __awaiter(void 0, void 0, void 0, function* () { return (call === null || call === void 0 ? void 0 : call.isScreenSharingOn) ? yield onStopScreenShare() : yield onStartScreenShare(); });
    const onHangUp = () => __awaiter(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.hangUp()); });
    const onCreateLocalStreamView = (options) => __awaiter(void 0, void 0, void 0, function* () {
        if (!call || call.localVideoStreams.length === 0) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            return;
        }
        const localStream = callState.localVideoStreams.find((item) => item.mediaStreamType === 'Video');
        if (!localStream) {
            return;
        }
        return callClient.createView(call.id, undefined, localStream, options);
    });
    const onCreateRemoteStreamView = (userId, options = { scalingMode: 'Crop' }) => __awaiter(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find((participant) => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        const remoteVideoStream = Object.values(participant.videoStreams).find((i) => i.mediaStreamType === 'Video');
        const screenShareStream = Object.values(participant.videoStreams).find((i) => i.mediaStreamType === 'ScreenSharing');
        if (remoteVideoStream && remoteVideoStream.isAvailable && !remoteVideoStream.view) {
            callClient.createView(call.id, participant.identifier, remoteVideoStream, options);
        }
        if (screenShareStream && screenShareStream.isAvailable && !screenShareStream.view) {
            // Hardcoded `scalingMode` since it is highly unlikely that CONTOSO would ever want to use a different scaling mode for screenshare.
            // Using `Crop` would crop the contents of screenshare and `Stretch` would warp it.
            // `Fit` is the only mode that maintains the integrity of the screen being shared.
            callClient.createView(call.id, participant.identifier, screenShareStream, { scalingMode: 'Fit' });
        }
    });
    const onDisposeRemoteStreamView = (userId) => __awaiter(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find((participant) => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        const remoteVideoStream = Object.values(participant.videoStreams).find((i) => i.mediaStreamType === 'Video');
        const screenShareStream = Object.values(participant.videoStreams).find((i) => i.mediaStreamType === 'ScreenSharing');
        if (remoteVideoStream && remoteVideoStream.view) {
            callClient.disposeView(call.id, participant.identifier, remoteVideoStream);
        }
        if (screenShareStream && screenShareStream.view) {
            callClient.disposeView(call.id, participant.identifier, screenShareStream);
        }
    });
    const onDisposeLocalStreamView = () => __awaiter(void 0, void 0, void 0, function* () {
        // TODO: we need to remember which LocalVideoStream was used for LocalPreview and dispose that one. For now
        // assume any unparented view is a LocalPreview and stop all since those are only used for LocalPreview
        // currently.
        yield disposeAllLocalPreviewViews(callClient);
    });
    const onRemoveParticipant = (userId) => __awaiter(void 0, void 0, void 0, function* () {
        yield (call === null || call === void 0 ? void 0 : call.removeParticipant(fromFlatCommunicationIdentifier(userId)));
    });
    return {
        onHangUp,
        onSelectCamera,
        onSelectMicrophone,
        onSelectSpeaker,
        onStartCall,
        onStartScreenShare,
        onStopScreenShare,
        onToggleCamera,
        onToggleMicrophone,
        onToggleScreenShare,
        onCreateLocalStreamView,
        onCreateRemoteStreamView,
        onRemoveParticipant,
        onStartLocalVideo,
        onDisposeRemoteStreamView,
        onDisposeLocalStreamView
    };
});
/**
 * Create a set of default handlers for given component. Memoization is applied to the result. Multiple invocations with
 * the same arguments will return the same handler instances. DeclarativeCallAgent, DeclarativeDeviceManager, and
 * DeclarativeCall may be undefined. If undefined, their associated handlers will not be created and returned.
 *
 * @param callClient - StatefulCallClient returned from
 *   {@link @azure/communication-react#createStatefulCallClient}.
 * @param callAgent - Instance of {@link @azure/communication-calling#CallClient}.
 * @param deviceManager - Instance of {@link @azure/communication-calling#DeviceManager}.
 * @param call - Instance of {@link @azure/communication-calling#Call}.
 * @param _ - React component that you want to generate handlers for.
 *
 * @public
 */
export const createDefaultCallingHandlersForComponent = (callClient, callAgent, deviceManager, call, _Component) => {
    return createDefaultCallingHandlers(callClient, callAgent, deviceManager, call);
};
//# sourceMappingURL=createHandlers.js.map