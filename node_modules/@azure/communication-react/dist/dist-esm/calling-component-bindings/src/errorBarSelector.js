// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { getDeviceManager, getDiagnostics, getLatestErrors } from './baseSelectors';
import { createSelector } from 'reselect';
import { DiagnosticQuality } from '@azure/communication-calling';
/**
 * Select the first 3 active errors from the state for the `ErrorBar` component.
 *
 * In case there are many errors, only the first three errors are returned to avoid
 * filling up the UI with too many errors.
 *
 * Invariants:
 *   - `ErrorType` is never repeated in the returned errors.
 *   - Errors are returned in a fixed order by `ErrorType`.
 *
 * @public
 */
export const errorBarSelector = createSelector([getLatestErrors, getDiagnostics, getDeviceManager], (latestErrors, diagnostics, deviceManager) => {
    var _a, _b, _c, _d;
    // The order in which the errors are returned is significant: The `ErrorBar` shows errors on the UI in that order.
    // There are several options for the ordering:
    //   - Sorted by when the errors happened (latest first / oldest first).
    //   - Stable sort by error type.
    //
    // We chose to stable sort by error type: We intend to show only a small number of errors on the UI and we do not
    // have timestamps for errors.
    const activeErrorMessages = [];
    // Errors reported via diagnostics are more reliable than from API method failures, so process those first.
    if (((_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReceiveQuality) === null || _a === void 0 ? void 0 : _a.value) === DiagnosticQuality.Bad ||
        ((_b = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReceiveQuality) === null || _b === void 0 ? void 0 : _b.value) == DiagnosticQuality.Poor) {
        activeErrorMessages.push({ type: 'callNetworkQualityLow' });
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.noSpeakerDevicesEnumerated) {
        activeErrorMessages.push({ type: 'callNoSpeakerFound' });
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.noMicrophoneDevicesEnumerated) {
        activeErrorMessages.push({ type: 'callNoMicrophoneFound' });
    }
    if (((_c = deviceManager.deviceAccess) === null || _c === void 0 ? void 0 : _c.audio) === false || (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphoneNotFunctioning)) {
        activeErrorMessages.push({ type: 'callMicrophoneAccessDenied' });
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphoneMuteUnexpectedly) {
        activeErrorMessages.push({ type: 'callMicrophoneMutedBySystem' });
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphonePermissionDenied) {
        activeErrorMessages.push({ type: 'callMacOsMicrophoneAccessDenied' });
    }
    if (((_d = deviceManager.deviceAccess) === null || _d === void 0 ? void 0 : _d.video) === false) {
        activeErrorMessages.push({ type: 'callCameraAccessDenied' });
    }
    else {
        if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraFreeze) {
            activeErrorMessages.push({ type: 'callCameraAlreadyInUse' });
        }
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraPermissionDenied) {
        activeErrorMessages.push({ type: 'callMacOsCameraAccessDenied' });
    }
    if (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.screenshareRecordingDisabled) {
        activeErrorMessages.push({ type: 'callMacOsScreenShareAccessDenied' });
    }
    // Prefer to show errors with privacy implications.
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.stopVideo', 'stopVideoGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.mute', 'muteGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.stopScreenSharing', 'stopScreenShareGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.startVideo', 'startVideoGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.unmute', 'unmuteGeneric');
    // We only return the first few errors to avoid filling up the UI with too many `MessageBar`s.
    activeErrorMessages.splice(maxErrorCount);
    return { activeErrorMessages: activeErrorMessages };
});
const appendActiveErrorIfDefined = (activeErrorMessages, latestErrors, target, activeErrorType) => {
    if (latestErrors[target] === undefined) {
        return;
    }
    activeErrorMessages.push({
        type: activeErrorType,
        timestamp: latestErrors[target].timestamp
    });
};
const maxErrorCount = 3;
//# sourceMappingURL=errorBarSelector.js.map