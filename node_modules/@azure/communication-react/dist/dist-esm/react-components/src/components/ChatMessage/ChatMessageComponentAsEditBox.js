// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { concatStyleSets, Icon, mergeStyles } from '@fluentui/react';
import { _formatString } from "../../../../acs-ui-common/src";
import { useTheme } from '../../theming/FluentThemeProvider';
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { editBoxStyle, inputBoxIcon, editingButtonStyle, editBoxStyleSet } from '../styles/EditBox.styles';
import { InputBoxButton, InputBoxComponent } from '../InputBoxComponent';
const MAXIMUM_LENGTH_OF_MESSAGE = 8000;
const onRenderCancelIcon = (color) => {
    const className = mergeStyles(inputBoxIcon, { color });
    return React.createElement(Icon, { iconName: 'EditBoxCancel', className: className });
};
const onRenderSubmitIcon = (color) => {
    const className = mergeStyles(inputBoxIcon, { color });
    return React.createElement(Icon, { iconName: 'EditBoxSubmit', className: className });
};
/**
 * @private
 */
export const ChatMessageComponentAsEditBox = (props) => {
    const { onCancel, onSubmit, initialValue, strings } = props;
    const [textValue, setTextValue] = useState(initialValue);
    const [textValueOverflow, setTextValueOverflow] = useState(false);
    const editTextFieldRef = React.useRef(null);
    const theme = useTheme();
    useEffect(() => {
        var _a;
        (_a = editTextFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, []);
    const setText = (event, newValue) => {
        if (newValue === undefined) {
            return;
        }
        if (newValue.length > MAXIMUM_LENGTH_OF_MESSAGE) {
            setTextValueOverflow(true);
        }
        else {
            setTextValueOverflow(false);
        }
        setTextValue(newValue);
    };
    const textTooLongMessage = textValueOverflow
        ? _formatString(strings.editBoxTextLimit, { limitNumber: `${MAXIMUM_LENGTH_OF_MESSAGE}` })
        : undefined;
    const onRenderThemedCancelIcon = useCallback(() => onRenderCancelIcon(theme.palette.neutralSecondary), [theme.palette.neutralSecondary]);
    const onRenderThemedSubmitIcon = useCallback(() => onRenderSubmitIcon(theme.palette.neutralSecondary), [theme.palette.neutralSecondary]);
    const editBoxStyles = useMemo(() => {
        return concatStyleSets(editBoxStyleSet, { textField: { borderColor: theme.palette.themePrimary } });
    }, [theme.palette.themePrimary]);
    return (React.createElement(InputBoxComponent, { inlineChildren: props.inlineEditButtons, id: 'editbox', textFieldRef: editTextFieldRef, inputClassName: editBoxStyle(props.inlineEditButtons), placeholderText: strings.editBoxPlaceholderText, textValue: textValue, onChange: setText, onEnterKeyDown: () => {
            onSubmit(textValue);
        }, supportNewline: false, maxLength: MAXIMUM_LENGTH_OF_MESSAGE, errorMessage: textTooLongMessage, styles: editBoxStyles },
        React.createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxCancelButton, onRenderIcon: onRenderThemedCancelIcon, onClick: () => {
                onCancel && onCancel();
            }, id: 'dismissIconWrapper' }),
        React.createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxSubmitButton, onRenderIcon: onRenderThemedSubmitIcon, onClick: (e) => {
                if (!textValueOverflow && textValue !== '') {
                    onSubmit(textValue);
                }
                e.stopPropagation();
            }, id: 'submitIconWrapper' })));
};
//# sourceMappingURL=ChatMessageComponentAsEditBox.js.map