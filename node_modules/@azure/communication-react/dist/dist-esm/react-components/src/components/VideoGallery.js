// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { concatStyleSets, ContextualMenu, mergeStyles, Modal, Stack } from '@fluentui/react';
import React, { useCallback, useMemo, useRef, useEffect } from 'react';
import { smartDominantSpeakerParticipants } from '../gallery';
import { useIdentifiers } from '../identifiers/IdentifierProvider';
import { useLocale } from '../localization';
import { useTheme } from '../theming';
import { GridLayout } from './GridLayout';
import { RemoteVideoTile } from './RemoteVideoTile';
import { ResponsiveHorizontalGallery } from './ResponsiveHorizontalGallery';
import { StreamMedia } from './StreamMedia';
import { HORIZONTAL_GALLERY_BUTTON_WIDTH, HORIZONTAL_GALLERY_GAP } from './styles/HorizontalGallery.styles';
import { floatingLocalVideoTileStyle, horizontalGalleryContainerStyle, horizontalGalleryStyle, LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM, localVideoTileContainerStyle, floatingLocalVideoModalStyle, SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM, videoGalleryContainerStyle, videoGalleryContainerTokens, videoGalleryOuterDivStyle } from './styles/VideoGallery.styles';
import { isNarrowWidth, useContainerWidth } from './utils/responsive';
import { LocalScreenShare } from './VideoGallery/LocalScreenShare';
import { RemoteScreenShare } from './VideoGallery/RemoteScreenShare';
import { VideoTile } from './VideoTile';
import { v4 as uuidv4 } from 'uuid';
// Currently the Calling JS SDK supports up to 4 remote video streams
const DEFAULT_MAX_REMOTE_VIDEO_STREAMS = 4;
// Set aside only 6 dominant speakers for remaining audio participants
const MAX_AUDIO_DOMINANT_SPEAKERS = 6;
const DRAG_OPTIONS = {
    moveMenuItemText: 'Move',
    closeMenuItemText: 'Close',
    menu: ContextualMenu,
    keepInBounds: true
};
/**
 * VideoGallery represents a layout of video tiles for a specific call.
 * It displays a {@link VideoTile} for the local user as well as for each remote participant who has joined the call.
 *
 * @public
 */
export const VideoGallery = (props) => {
    var _a, _b, _c, _d, _e;
    const { localParticipant, remoteParticipants = [], localVideoViewOptions, remoteVideoViewOptions, dominantSpeakers, onRenderLocalVideoTile, onRenderRemoteVideoTile, onCreateLocalStreamView, onCreateRemoteStreamView, onDisposeRemoteStreamView, styles, layout, onRenderAvatar, showMuteIndicator, maxRemoteVideoStreams = DEFAULT_MAX_REMOTE_VIDEO_STREAMS } = props;
    const ids = useIdentifiers();
    const theme = useTheme();
    const localeStrings = useLocale().strings.videoGallery;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const shouldFloatLocalVideo = !!(layout === 'floatingLocalVideo' && remoteParticipants.length > 0);
    const containerRef = useRef(null);
    const containerWidth = useContainerWidth(containerRef);
    const isNarrow = isNarrowWidth(containerWidth);
    const visibleVideoParticipants = useRef([]);
    const visibleAudioParticipants = useRef([]);
    visibleVideoParticipants.current = smartDominantSpeakerParticipants({
        participants: (_a = remoteParticipants === null || remoteParticipants === void 0 ? void 0 : remoteParticipants.filter((p) => { var _a; return (_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable; })) !== null && _a !== void 0 ? _a : [],
        dominantSpeakers,
        lastVisibleParticipants: visibleVideoParticipants.current,
        maxDominantSpeakers: maxRemoteVideoStreams
    }).slice(0, maxRemoteVideoStreams);
    // This set will be used to filter out participants already in visibleVideoParticipants
    const visibleVideoParticipantsSet = new Set(visibleVideoParticipants.current.map((p) => p.userId));
    visibleAudioParticipants.current = smartDominantSpeakerParticipants({
        participants: (_b = remoteParticipants === null || remoteParticipants === void 0 ? void 0 : remoteParticipants.filter((p) => !visibleVideoParticipantsSet.has(p.userId))) !== null && _b !== void 0 ? _b : [],
        dominantSpeakers,
        lastVisibleParticipants: visibleAudioParticipants.current,
        maxDominantSpeakers: MAX_AUDIO_DOMINANT_SPEAKERS
    });
    /**
     * Utility function for memoized rendering of LocalParticipant.
     */
    const localVideoTile = useMemo(() => {
        const localVideoStream = localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.videoStream;
        if (onRenderLocalVideoTile) {
            return onRenderLocalVideoTile(localParticipant);
        }
        const localVideoTileStyles = shouldFloatLocalVideo ? floatingLocalVideoTileStyle : {};
        const localVideoTileStylesThemed = concatStyleSets(localVideoTileStyles, {
            root: { borderRadius: theme.effects.roundedCorner4 }
        }, styles === null || styles === void 0 ? void 0 : styles.localVideo);
        if (localVideoStream && !localVideoStream.renderElement) {
            onCreateLocalStreamView && onCreateLocalStreamView(localVideoViewOptions);
        }
        return (React.createElement(VideoTile, { key: localParticipant.userId, userId: localParticipant.userId, renderElement: (localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.renderElement) ? (React.createElement(StreamMedia, { videoStreamElement: localVideoStream.renderElement })) : undefined, showLabel: !(shouldFloatLocalVideo && isNarrow), displayName: isNarrow ? '' : strings.localVideoLabel, initialsName: localParticipant.displayName, styles: localVideoTileStylesThemed, onRenderPlaceholder: onRenderAvatar, isMuted: localParticipant.isMuted, showMuteIndicator: showMuteIndicator }));
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        localParticipant,
        localParticipant.isScreenSharingOn,
        localParticipant.videoStream,
        (_c = localParticipant.videoStream) === null || _c === void 0 ? void 0 : _c.renderElement,
        isNarrow,
        onCreateLocalStreamView,
        onRenderLocalVideoTile,
        onRenderAvatar,
        shouldFloatLocalVideo
    ]);
    const defaultOnRenderVideoTile = useCallback((participant, isVideoParticipant) => {
        const remoteVideoStream = participant.videoStream;
        return (React.createElement(RemoteVideoTile, Object.assign({ key: participant.userId }, participant, { onCreateRemoteStreamView: isVideoParticipant ? onCreateRemoteStreamView : undefined, onDisposeRemoteStreamView: isVideoParticipant ? onDisposeRemoteStreamView : undefined, isAvailable: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.isAvailable : false, renderElement: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.renderElement : undefined, remoteVideoViewOptions: isVideoParticipant ? remoteVideoViewOptions : undefined, onRenderAvatar: onRenderAvatar, showMuteIndicator: showMuteIndicator })));
    }, [onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions, onRenderAvatar, showMuteIndicator]);
    const videoTiles = onRenderRemoteVideoTile
        ? visibleVideoParticipants.current.map((participant) => onRenderRemoteVideoTile(participant))
        : visibleVideoParticipants.current.map((participant) => {
            return defaultOnRenderVideoTile(participant, true);
        });
    const audioTiles = onRenderRemoteVideoTile
        ? visibleAudioParticipants.current.map((participant) => onRenderRemoteVideoTile(participant))
        : visibleAudioParticipants.current.map((participant) => {
            return defaultOnRenderVideoTile(participant, false);
        });
    const screenShareParticipant = remoteParticipants.find((participant) => { var _a; return (_a = participant.screenShareStream) === null || _a === void 0 ? void 0 : _a.isAvailable; });
    const screenShareActive = screenShareParticipant || (localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isScreenSharingOn);
    let gridTiles = [];
    let horizontalGalleryTiles = [];
    if (screenShareActive) {
        // If screen sharing is active, assign video and audio participants as horizontal gallery participants
        horizontalGalleryTiles = videoTiles.concat(audioTiles);
    }
    else {
        // If screen sharing is not active, then assign all video tiles as grid tiles.
        // If there are no video tiles, then assign audio tiles as grid tiles.
        gridTiles = videoTiles.length > 0 ? videoTiles : audioTiles;
        horizontalGalleryTiles = videoTiles.length > 0 ? audioTiles : [];
    }
    if (!shouldFloatLocalVideo && localParticipant) {
        gridTiles.push(localVideoTile);
    }
    const localScreenShareStreamComponent = React.createElement(LocalScreenShare, { localParticipant: localParticipant });
    const remoteScreenShareComponent = screenShareParticipant && (React.createElement(RemoteScreenShare, Object.assign({}, screenShareParticipant, { renderElement: (_d = screenShareParticipant.screenShareStream) === null || _d === void 0 ? void 0 : _d.renderElement, onCreateRemoteStreamView: onCreateRemoteStreamView, onDisposeRemoteStreamView: onDisposeRemoteStreamView })));
    useEffect(() => {
        if (containerRef.current) {
            containerRef.current.id = `video-gallery-${uuidv4()}`;
        }
    }, [containerRef]);
    const horizontalGalleryPresent = horizontalGalleryTiles && horizontalGalleryTiles.length > 0;
    return (React.createElement("div", { "data-ui-id": ids.videoGallery, ref: containerRef, className: mergeStyles(videoGalleryOuterDivStyle, styles === null || styles === void 0 ? void 0 : styles.root) },
        shouldFloatLocalVideo &&
            localParticipant &&
            (horizontalGalleryPresent ? (React.createElement(Stack, { className: mergeStyles(localVideoTileContainerStyle(theme, isNarrow)) }, localVideoTile)) : (React.createElement(Modal, { isOpen: true, isModeless: true, dragOptions: DRAG_OPTIONS, styles: floatingLocalVideoModalStyle(theme, isNarrow), layerProps: { hostId: (_e = containerRef.current) === null || _e === void 0 ? void 0 : _e.id } }, localVideoTile))),
        React.createElement(Stack, { horizontal: false, styles: videoGalleryContainerStyle, tokens: videoGalleryContainerTokens },
            screenShareParticipant ? (remoteScreenShareComponent) : (localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isScreenSharingOn) ? (localScreenShareStreamComponent) : (React.createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles)),
            horizontalGalleryPresent && (React.createElement(ResponsiveHorizontalGallery, { key: "responsive-horizontal-gallery", containerStyles: horizontalGalleryContainerStyle(shouldFloatLocalVideo, isNarrow), horizontalGalleryStyles: concatStyleSets(horizontalGalleryStyle(isNarrow), styles === null || styles === void 0 ? void 0 : styles.horizontalGallery), childWidthRem: isNarrow ? SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width : LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.width, buttonWidthRem: HORIZONTAL_GALLERY_BUTTON_WIDTH, gapWidthRem: HORIZONTAL_GALLERY_GAP }, horizontalGalleryTiles)))));
};
//# sourceMappingURL=VideoGallery.js.map