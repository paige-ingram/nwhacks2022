// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { ContextualMenuItemType, Icon, merge } from '@fluentui/react';
import React from 'react';
import { useLocale } from '../localization';
import { ControlBarButton } from './ControlBarButton';
import { buttonFlyoutItemStyles } from './styles/ControlBar.styles';
/**
 * Generates default menuprops for an DevicesButton if the props contain device
 * information and device change handlers.
 * @param props DevicesButtonProps
 * @returns MenuProps
 */
const generateDefaultMenuProps = (props, strings) => {
    var _a, _b, _c, _d;
    const { microphones, speakers, cameras, selectedMicrophone, selectedSpeaker, selectedCamera, onSelectCamera, onSelectMicrophone, onSelectSpeaker } = props;
    const defaultMenuProps = {
        items: [],
        styles: (_a = props.styles) === null || _a === void 0 ? void 0 : _a.menuStyles,
        calloutProps: {
            styles: {
                root: {
                    // Confine the menu to the parents bounds.
                    // More info: https://github.com/microsoft/fluentui/issues/18835
                    // NB: 95% to keep some space for margin, drop shadow etc around the Callout.
                    maxWidth: '95%'
                }
            },
            // Disable dismiss on resize to work around a couple Fluent UI bugs
            // - The Callout is dismissed whenever *any child of window (inclusive)* is resized. In practice, this
            //   happens when we change the VideoGallery layout, or even when the video stream element is internally resized
            //   by the headless SDK.
            // - There is a `preventDismissOnEvent` prop that we could theoretically use to only dismiss when the target of
            //   of the 'resize' event is the window itself. But experimentation shows that setting that prop doesn't
            //   deterministically avoid dismissal.
            //
            // A side effect of this workaround is that the context menu stays open when window is resized, and may
            // get detached from original target visually. That bug is preferable to the bug when this value is not set -
            // The Callout (frequently) gets dismissed automatically.
            preventDismissOnResize: true
        }
    };
    const menuItemStyles = merge(buttonFlyoutItemStyles, (_d = (_c = (_b = props.styles) === null || _b === void 0 ? void 0 : _b.menuStyles) === null || _c === void 0 ? void 0 : _c.menuItemStyles) !== null && _d !== void 0 ? _d : {});
    if (cameras && selectedCamera && onSelectCamera) {
        defaultMenuProps.items.push({
            key: 'sectionCamera',
            title: strings.cameraMenuTooltip,
            itemType: ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.cameraMenuTitle,
                items: cameras.map((camera) => ({
                    key: camera.id,
                    text: camera.name,
                    title: camera.name,
                    iconProps: { iconName: 'OptionsCamera', styles: { root: { lineHeight: 0 } } },
                    itemProps: {
                        styles: menuItemStyles
                    },
                    canCheck: true,
                    isChecked: camera.id === (selectedCamera === null || selectedCamera === void 0 ? void 0 : selectedCamera.id),
                    onClick: () => {
                        if (camera.id !== (selectedCamera === null || selectedCamera === void 0 ? void 0 : selectedCamera.id)) {
                            onSelectCamera(camera);
                        }
                    }
                }))
            }
        });
    }
    if (microphones && selectedMicrophone && onSelectMicrophone) {
        defaultMenuProps.items.push({
            key: 'sectionMicrophone',
            title: strings.microphoneMenuTooltip,
            itemType: ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.microphoneMenuTitle,
                items: microphones.map((microphone) => ({
                    key: microphone.id,
                    text: microphone.name,
                    title: microphone.name,
                    iconProps: { iconName: 'OptionsMic', styles: { root: { lineHeight: 0 } } },
                    itemProps: {
                        styles: menuItemStyles
                    },
                    canCheck: true,
                    isChecked: microphone.id === (selectedMicrophone === null || selectedMicrophone === void 0 ? void 0 : selectedMicrophone.id),
                    onClick: () => {
                        if (microphone.id !== (selectedMicrophone === null || selectedMicrophone === void 0 ? void 0 : selectedMicrophone.id)) {
                            onSelectMicrophone(microphone);
                        }
                    }
                }))
            }
        });
    }
    if (speakers && selectedSpeaker && onSelectSpeaker) {
        defaultMenuProps.items.push({
            key: 'sectionSpeaker',
            title: strings.speakerMenuTooltip,
            itemType: ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.speakerMenuTitle,
                items: speakers.map((speaker) => ({
                    key: speaker.id,
                    text: speaker.name,
                    title: speaker.name,
                    iconProps: { iconName: 'OptionsSpeaker', styles: { root: { lineHeight: 0 } } },
                    itemProps: {
                        styles: menuItemStyles
                    },
                    canCheck: true,
                    isChecked: speaker.id === (selectedSpeaker === null || selectedSpeaker === void 0 ? void 0 : selectedSpeaker.id),
                    onClick: () => {
                        if (speaker.id !== (selectedSpeaker === null || selectedSpeaker === void 0 ? void 0 : selectedSpeaker.id)) {
                            onSelectSpeaker(speaker);
                        }
                    }
                }))
            }
        });
    }
    if (defaultMenuProps.items.length === 0) {
        // Avoids creating an empty context menu.
        return undefined;
    }
    return defaultMenuProps;
};
const onRenderOptionsIcon = () => React.createElement(Icon, { iconName: "ControlButtonOptions" });
/**
 * A button to open a menu that controls device options.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
export const DevicesButton = (props) => {
    var _a, _b;
    const { onRenderIcon } = props;
    const localeStrings = useLocale().strings.devicesButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const devicesButtonMenu = (_a = props.menuProps) !== null && _a !== void 0 ? _a : generateDefaultMenuProps(props, strings);
    return (React.createElement(ControlBarButton, Object.assign({}, props, { menuProps: devicesButtonMenu, menuIconProps: { hidden: true }, onRenderIcon: onRenderIcon !== null && onRenderIcon !== void 0 ? onRenderIcon : onRenderOptionsIcon, strings: strings, labelKey: (_b = props.labelKey) !== null && _b !== void 0 ? _b : 'devicesButtonLabel' })));
};
//# sourceMappingURL=DevicesButton.js.map