// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { ContextualMenu, DirectionalHint, Icon, mergeStyles, Persona, PersonaSize, Stack } from '@fluentui/react';
import React, { useMemo, useRef, useState } from 'react';
import { useIdentifiers } from '../identifiers';
import { useLocale } from '../localization';
import { useTheme } from '../theming';
import { iconContainerStyle, iconStyles, meContainerStyle, menuButtonContainerStyle, participantItemContainerStyle } from './styles/ParticipantItem.styles';
/**
 * Component to render a calling or chat participant.
 *
 * Displays the participant's avatar, displayName and status as well as optional icons and context menu.
 *
 * @public
 */
export const ParticipantItem = (props) => {
    var _a, _b, _c, _d;
    const { userId, displayName, onRenderAvatar, menuItems, onRenderIcon, presence, styles, me } = props;
    const [itemHovered, setItemHovered] = useState(false);
    const [menuHidden, setMenuHidden] = useState(true);
    const containerRef = useRef(null);
    const theme = useTheme();
    const localeStrings = useLocale().strings.participantItem;
    const ids = useIdentifiers();
    const isMeText = (_b = (_a = props.strings) === null || _a === void 0 ? void 0 : _a.isMeText) !== null && _b !== void 0 ? _b : localeStrings.isMeText;
    const menuTitle = (_d = (_c = props.strings) === null || _c === void 0 ? void 0 : _c.menuTitle) !== null && _d !== void 0 ? _d : localeStrings.menuTitle;
    const avatarOptions = {
        text: displayName,
        size: PersonaSize.size32,
        presence: presence,
        initialsTextColor: 'white'
    };
    const avatar = onRenderAvatar ? (onRenderAvatar(userId !== null && userId !== void 0 ? userId : '', avatarOptions)) : (React.createElement(Persona, Object.assign({ className: mergeStyles({
            // Prevents persona text from being vertically truncated if a global line height is less than 1.15.
            lineHeight: '1.15rem'
        }, styles === null || styles === void 0 ? void 0 : styles.avatar) }, avatarOptions)));
    const meTextStyle = useMemo(() => mergeStyles(meContainerStyle, { color: theme.palette.neutralTertiary }, styles === null || styles === void 0 ? void 0 : styles.me), [theme.palette.neutralTertiary, styles === null || styles === void 0 ? void 0 : styles.me]);
    const contextualMenuStyle = useMemo(() => mergeStyles({ background: theme.palette.neutralLighterAlt }, styles === null || styles === void 0 ? void 0 : styles.menu), [theme.palette.neutralLighterAlt, styles === null || styles === void 0 ? void 0 : styles.menu]);
    const infoContainerStyle = useMemo(() => mergeStyles(iconContainerStyle, { color: theme.palette.neutralTertiary }, styles === null || styles === void 0 ? void 0 : styles.iconContainer), [theme.palette.neutralTertiary, styles === null || styles === void 0 ? void 0 : styles.iconContainer]);
    const menuButton = useMemo(() => (React.createElement(Stack, { horizontal: true, horizontalAlign: "end", className: mergeStyles(menuButtonContainerStyle), title: menuTitle, "data-ui-id": ids.participantItemMenuButton },
        React.createElement(Icon, { iconName: itemHovered ? 'ParticipantItemOptionsHovered' : 'ParticipantItemOptions', className: iconStyles }))), [itemHovered, menuTitle, ids.participantItemMenuButton]);
    const onDismissMenu = () => {
        setItemHovered(false);
        setMenuHidden(true);
    };
    return (React.createElement("div", { ref: containerRef, role: 'menuitem', "data-is-focusable": true, className: mergeStyles(participantItemContainerStyle, styles === null || styles === void 0 ? void 0 : styles.root), onMouseEnter: () => setItemHovered(true), onMouseLeave: () => setItemHovered(false), onClick: () => {
            setItemHovered(true);
            setMenuHidden(false);
        } },
        React.createElement(Stack, { horizontal: true, className: mergeStyles({ width: `calc(100% - ${menuButtonContainerStyle.width})`, alignItems: 'center' }) },
            avatar,
            me && React.createElement(Stack, { className: meTextStyle }, isMeText),
            React.createElement(Stack, { horizontal: true, className: mergeStyles(infoContainerStyle) }, onRenderIcon && onRenderIcon(props))),
        menuItems && menuItems.length > 0 && (React.createElement(React.Fragment, null,
            menuButton,
            React.createElement(ContextualMenu, { items: menuItems, hidden: menuHidden, target: containerRef, onItemClick: onDismissMenu, onDismiss: onDismissMenu, directionalHint: DirectionalHint.bottomRightEdge, className: contextualMenuStyle, calloutProps: {
                    // Disable dismiss on resize to work around a couple Fluent UI bugs
                    // - The Callout is dismissed whenever *any child of window (inclusive)* is resized. In practice, this
                    //   happens when we change the VideoGallery layout, or even when the video stream element is internally resized
                    //   by the headless SDK.
                    // - There is a `preventDismissOnEvent` prop that we could theoretically use to only dismiss when the target of
                    //   of the 'resize' event is the window itself. But experimentation shows that setting that prop doesn't
                    //   deterministically avoid dismissal.
                    //
                    // A side effect of this workaround is that the context menu stays open when window is resized, and may
                    // get detached from original target visually. That bug is preferable to the bug when this value is not set -
                    // The Callout (frequently) gets dismissed automatically.
                    preventDismissOnResize: true
                } })))));
};
//# sourceMappingURL=ParticipantItem.js.map