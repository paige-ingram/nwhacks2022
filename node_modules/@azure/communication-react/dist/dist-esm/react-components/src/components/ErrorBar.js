// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import React, { useEffect, useState } from 'react';
import { MessageBar, MessageBarType, Stack } from '@fluentui/react';
import { useLocale } from '../localization';
/**
 * A component to show error messages on the UI.
 * All strings that can be shown are accepted as the {@link ErrorBarProps.strings} so that they can be localized.
 * Active errors are selected by {@link ErrorBarProps.activeErrorMessages}.
 *
 * This component internally tracks dismissed by the user.
 *   * Errors that have an associated timestamp: The error is shown on the UI again if it occurs after being dismissed.
 *   * Errors that do not have a timestamp: The error is dismissed until it disappears from the props.
 *         If the error recurs, it is shown in the UI.
 *
 * Uses {@link @fluentui/react#MessageBar} UI element.
 *
 * @public
 */
export const ErrorBar = (props) => {
    var _a;
    const localeStrings = useLocale().strings.errorBar;
    const strings = (_a = props.strings) !== null && _a !== void 0 ? _a : localeStrings;
    const [dismissedErrors, setDismissedErrors] = useState([]);
    // dropDismissalsForInactiveErrors only returns a new object if `dismissedErrors` actually changes.
    // Without this behaviour, this `useEffect` block would cause a render loop.
    useEffect(() => setDismissedErrors(dropDismissalsForInactiveErrors(props.activeErrorMessages, dismissedErrors)), [props.activeErrorMessages, dismissedErrors]);
    const toShow = errorsToShow(props.activeErrorMessages, dismissedErrors);
    return (React.createElement(Stack, null, toShow.map((error) => (React.createElement(MessageBar, Object.assign({}, props, { key: error.type, messageBarType: messageBarType(error.type), messageBarIconProps: messageBarIconProps(error.type), onDismiss: () => setDismissedErrors(dismissError(dismissedErrors, error)) }), strings[error.type])))));
};
// Always returns a new Array so that the state variable is updated, trigerring a render.
const dismissError = (dismissedErrors, toDismiss) => {
    const now = new Date(Date.now());
    for (const error of dismissedErrors) {
        if (error.type === toDismiss.type) {
            // Bump the timestamp for latest dismissal of this error to now.
            error.dismissedAt = now;
            error.activeSince = toDismiss.timestamp;
            return Array.from(dismissedErrors);
        }
    }
    // Record that this error was dismissed for the first time right now.
    return [
        ...dismissedErrors,
        {
            type: toDismiss.type,
            dismissedAt: now,
            activeSince: toDismiss.timestamp
        }
    ];
};
// Returns a new Array if and only if contents change, to avoid re-rendering when nothing was dropped.
const dropDismissalsForInactiveErrors = (activeErrorMessages, dismissedErrors) => {
    const active = new Map();
    for (const message of activeErrorMessages) {
        active.set(message.type, message);
    }
    // For an error such that:
    // * It was previously active, and dismissed.
    // * It did not have a timestamp associated with it.
    // * It is no longer active.
    //
    // We remove it from dismissals. When it becomes active again next time, it will be shown again on the UI.
    const shouldDeleteDismissal = (dismissed) => dismissed.activeSince === undefined && active.get(dismissed.type) === undefined;
    if (dismissedErrors.some((dismissed) => shouldDeleteDismissal(dismissed))) {
        return dismissedErrors.filter((dismissed) => !shouldDeleteDismissal(dismissed));
    }
    return dismissedErrors;
};
const errorsToShow = (activeErrorMessages, dismissedErrors) => {
    const dismissed = new Map();
    for (const error of dismissedErrors) {
        dismissed.set(error.type, error);
    }
    return activeErrorMessages.filter((error) => {
        const dismissal = dismissed.get(error.type);
        if (!dismissal) {
            // This error was never dismissed.
            return true;
        }
        if (!error.timestamp) {
            // No timestamp associated with the error. In this case, the existence of a dismissal is enough to suppress the error.
            return false;
        }
        // Error has an associated timestamp, so compare with last dismissal.
        return error.timestamp > dismissal.dismissedAt;
    });
};
const messageBarType = (errorType) => {
    switch (errorType) {
        case 'callNetworkQualityLow':
        case 'callNoSpeakerFound':
        case 'callNoMicrophoneFound':
        case 'callMicrophoneAccessDenied':
        case 'callMicrophoneMutedBySystem':
        case 'callMacOsMicrophoneAccessDenied':
        case 'callLocalVideoFreeze':
        case 'callCameraAccessDenied':
        case 'callCameraAlreadyInUse':
        case 'callMacOsCameraAccessDenied':
        case 'callMacOsScreenShareAccessDenied':
            return MessageBarType.warning;
        default:
            return MessageBarType.error;
    }
};
const messageBarIconProps = (errorType) => {
    const iconName = customIconName[errorType];
    return iconName ? { iconName } : undefined;
};
const customIconName = {
    callNetworkQualityLow: 'ErrorBarCallNetworkQualityLow',
    callNoSpeakerFound: 'ErrorBarCallNoSpeakerFound',
    callNoMicrophoneFound: 'ErrorBarCallNoMicrophoneFound',
    callMicrophoneAccessDenied: 'ErrorBarCallMicrophoneAccessDenied',
    callMicrophoneMutedBySystem: 'ErrorBarCallMicrophoneMutedBySystem',
    callMacOsMicrophoneAccessDenied: 'ErrorBarCallMacOsMicrophoneAccessDenied',
    callLocalVideoFreeze: 'ErrorBarCallLocalVideoFreeze',
    callCameraAccessDenied: 'ErrorBarCallCameraAccessDenied',
    callCameraAlreadyInUse: 'ErrorBarCallCameraAlreadyInUse',
    callMacOsCameraAccessDenied: 'ErrorBarCallMacOsCameraAccessDenied'
};
//# sourceMappingURL=ErrorBar.js.map