/**
 * `@azure/communication-react` is an npm package that exports the functionality of the Azure Communication Services - UI Library.
 *
 * This package makes it easy for you to build modern communications user experiences using Azure Communication Services. It gives you a library of production-ready UI components that you can drop into your applications:
 *   - Composites: These components are turn-key solutions that implement common communication scenarios. You can quickly add video calling or chat experiences to your applications. Composites are open-source higher order components built using UI components.
 *   - UI Components - These components are open-source building blocks that let you build custom communications experience. Components are offered for both calling and chat capabilities that can be combined to build experiences.
 *
 * These UI client libraries all use Microsoft's Fluent design language and assets. Fluent UI provides a foundational layer for the UI Library and is actively used across Microsoft products.
 *
 * In conjunction with the UI components, the UI Library exposes a stateful client library for calling and chat. This client is agnostic to any specific state management framework and can be integrated with common state managers like Redux or React Context.
 * This stateful client library can be used with the UI Components to pass props and methods for the UI Components to render data. For more information, see Stateful Client Overview.
 *
 * For more information visit: https://aka.ms/acsstorybook
 *
 * @packageDocumentation
 */

/// <reference types="react" />

import { AudioDeviceInfo } from '@azure/communication-calling';
import { Call } from '@azure/communication-calling';
import { CallAgent } from '@azure/communication-calling';
import { CallClient } from '@azure/communication-calling';
import { CallClientOptions } from '@azure/communication-calling';
import { CallDirection } from '@azure/communication-calling';
import { CallEndReason } from '@azure/communication-calling';
import { CallerInfo } from '@azure/communication-calling';
import { CallState as CallState_2 } from '@azure/communication-calling';
import { ChatClient } from '@azure/communication-chat';
import { ChatClientOptions } from '@azure/communication-chat';
import { ChatMessage as ChatMessage_2 } from '@azure/communication-chat';
import { ChatMessageReadReceipt } from '@azure/communication-chat';
import { ChatParticipant } from '@azure/communication-chat';
import { ChatThreadClient } from '@azure/communication-chat';
import { CommunicationIdentifier } from '@azure/communication-common';
import { CommunicationIdentifierKind } from '@azure/communication-common';
import { CommunicationTokenCredential } from '@azure/communication-common';
import { CommunicationUserIdentifier } from '@azure/communication-common';
import { CommunicationUserKind } from '@azure/communication-common';
import { ComponentSlotStyle } from '@fluentui/react-northstar';
import { CreateViewOptions } from '@azure/communication-calling';
import { DeviceAccess } from '@azure/communication-calling';
import { DeviceManager } from '@azure/communication-calling';
import { DominantSpeakersInfo } from '@azure/communication-calling';
import { GroupCallLocator } from '@azure/communication-calling';
import { IButtonProps } from '@fluentui/react';
import { IButtonStyles } from '@fluentui/react';
import { IContextualMenuItem } from '@fluentui/react';
import { IContextualMenuItemStyles } from '@fluentui/react';
import { IContextualMenuStyles } from '@fluentui/react';
import { IMessageBarProps } from '@fluentui/react';
import { IPersonaStyleProps } from '@fluentui/react';
import { IPersonaStyles } from '@fluentui/react';
import { IRenderFunction } from '@fluentui/react';
import { IStyle } from '@fluentui/react';
import { IStyleFunctionOrObject } from '@fluentui/react';
import { LatestMediaDiagnostics } from '@azure/communication-calling';
import { LatestNetworkDiagnostics } from '@azure/communication-calling';
import type { MediaDiagnosticChangedEventArgs } from '@azure/communication-calling';
import { MediaStreamType } from '@azure/communication-calling';
import { MicrosoftTeamsUserKind } from '@azure/communication-common';
import type { NetworkDiagnosticChangedEventArgs } from '@azure/communication-calling';
import { PartialTheme } from '@fluentui/react';
import type { PermissionConstraints } from '@azure/communication-calling';
import { PersonaInitialsColor } from '@fluentui/react';
import { PersonaPresence } from '@fluentui/react';
import { PersonaSize } from '@fluentui/react';
import { PhoneNumberIdentifier } from '@azure/communication-common';
import { PhoneNumberKind } from '@azure/communication-common';
import { default as React_2 } from 'react';
import type { RemoteParticipant } from '@azure/communication-calling';
import { RemoteParticipantState as RemoteParticipantState_2 } from '@azure/communication-calling';
import { ScalingMode } from '@azure/communication-calling';
import { StartCallOptions } from '@azure/communication-calling';
import { TeamsMeetingLinkLocator } from '@azure/communication-calling';
import { Theme } from '@fluentui/react';
import { TypingIndicatorReceivedEvent } from '@azure/communication-signaling';
import { UnknownIdentifier } from '@azure/communication-common';
import { UnknownIdentifierKind } from '@azure/communication-common';
import { VideoDeviceInfo } from '@azure/communication-calling';

/**
 * Active error messages to be shown via {@link ErrorBar}.
 *
 * @public
 */
export declare interface ActiveErrorMessage {
    /**
     * Type of error that is active.
     */
    type: ErrorType;
    /**
     * The latest timestamp when this error was observed.
     *
     * When available, this is used to track errors that have already been seen and dismissed
     * by the user.
     */
    timestamp?: Date;
}

/**
 * Error reported via error events and stored in adapter state.
 *
 * @public
 */
export declare interface AdapterError extends Error {
    /**
     * The operation that failed.
     */
    target: string;
    /**
     * Error thrown by the failed operation.
     */
    innerError: Error;
    /**
     * Timestamp added to the error in the adapter implementation.
     */
    timestamp: Date;
}

/**
 * Adapters stores the latest error for each operation in the state.
 *
 * `target` is an adapter defined string for each unique operation performed by the adapter.
 *
 * @public
 */
export declare type AdapterErrors = {
    [target: string]: AdapterError;
};

/**
 * Functionality for interfacing with Composite adapter state.
 *
 * @public
 */
export declare interface AdapterState<TState> {
    /** Subscribes the handler to stateChanged events. */
    onStateChange(handler: (state: TState) => void): void;
    /** Unsubscribes the handler to stateChanged events. */
    offStateChange(handler: (state: TState) => void): void;
    /** Get the current State */
    getState(): TState;
}

/**
 * Compare if 2 react components are exact equal, result type will be true/false
 *
 * @public
 */
export declare type AreEqual<A extends (props: any) => JSX.Element | undefined, B extends (props: any) => JSX.Element | undefined> = true extends AreTypeEqual<A, B> & AreParamEqual<A, B> ? true : false;

/**
 * Compare if props of 2 react components are equal, result type will be true/false
 *
 * @public
 */
export declare type AreParamEqual<A extends (props: any) => JSX.Element | undefined, B extends (props: any) => JSX.Element | undefined> = AreTypeEqual<Required<Parameters<A>[0]>, Required<Parameters<B>[0]>>;

/**
 * Compare if two types are equal, result type will be true/false
 *
 * @public
 */
export declare type AreTypeEqual<A, B> = A extends B ? (B extends A ? true : false) : false;

/**
 * Custom data attributes for displaying avatar for a user.
 *
 * @public
 */
export declare type AvatarPersonaData = {
    /**
     * Primary text to display, usually the name of the person.
     */
    text?: string;
    /**
     * Image URL to use, should be a square aspect ratio and big enough to fit in the image area.
     */
    imageUrl?: string;
    /**
     * The user's initials to display in the image area when there is no image.
     * @defaultvalue Derived from `text`
     */
    imageInitials?: string;
    /**
     * The background color when the user's initials are displayed.
     * @defaultvalue Derived from `text`
     */
    initialsColor?: PersonaInitialsColor | string;
    /**
     * The text color when the user's initials are displayed
     * @defaultvalue `white`
     */
    initialsTextColor?: string;
};

/**
 * Callback function used to provide custom data to build an avatar for a user.
 *
 * @public
 */
export declare type AvatarPersonaDataCallback = (userId: string) => Promise<AvatarPersonaData>;

/**
 * Arguments for creating the Azure Communication Services implementation of {@link CallAdapter}.
 *
 * Note: `displayName` can be a maximum of 256 characters.
 *
 * @public
 */
export declare type AzureCommunicationCallAdapterArgs = {
    userId: CommunicationUserIdentifier;
    displayName: string;
    credential: CommunicationTokenCredential;
    locator: TeamsMeetingLinkLocator | GroupCallLocator;
};

/**
 * Arguments for creating the Azure Communication Services implementation of {@link ChatAdapter}.
 *
 * @public
 */
export declare type AzureCommunicationChatAdapterArgs = {
    endpoint: string;
    userId: CommunicationUserIdentifier;
    displayName: string;
    credential: CommunicationTokenCredential;
    threadId: string;
};

/**
 * Properties common to all composites exported from this library.
 *
 * @public
 */
export declare interface BaseCompositeProps<TIcons extends Record<string, JSX.Element>> {
    /**
     * Fluent theme for the composite.
     *
     * @defaultValue light theme
     */
    fluentTheme?: PartialTheme | Theme;
    /**
     * Custom Icon override for the composite.
     * A JSX element can be provided to override the default icon.
     */
    icons?: TIcons;
    /**
     * Locale for the composite.
     *
     * @defaultValue English (US)
     */
    locale?: CompositeLocale;
    /**
     * Whether composite is displayed right-to-left.
     *
     * @defaultValue false
     */
    rtl?: boolean;
    /**
     * A callback function that can be used to provide custom data to Avatars rendered
     * in Composite.
     */
    onFetchAvatarPersonaData?: AvatarPersonaDataCallback;
    /**
     * A callback function that can be used to provide custom menu items for a participant in
     * participant list.
     */
    onFetchParticipantMenuItems?: ParticipantMenuItemsCallback;
}

/**
 * Basic fluent styles props for all components exported from this libray.
 *
 * @public
 */
export declare interface BaseCustomStyles {
    /** Styles for the root container. */
    root?: IStyle;
}

/**
 * {@link CallComposite} Adapter interface.
 *
 * @public
 */
export declare interface CallAdapter extends AdapterState<CallAdapterState>, Disposable, CallAdapterCallManagement, CallAdapterDeviceManagement, CallAdapterSubscribers {
}

/**
 * Functionality for managing the current call.
 *
 * @public
 */
export declare interface CallAdapterCallManagement {
    /**
     * Join the call with microphone initially on/off.
     *
     * @param microphoneOn - Whether microphone is initially enabled
     *
     * @public
     */
    joinCall(microphoneOn?: boolean): Call | undefined;
    /**
     * Leave the call
     *
     * @param forEveryone - Whether to remove all participants when leaving
     *
     * @public
     */
    leaveCall(forEveryone?: boolean): Promise<void>;
    /**
     * Start the camera
     * This method will start rendering a local camera view when the call is not active
     *
     * @param options - Options to control how video streams are rendered {@link @azure/communication-calling#VideoStreamOptions }
     *
     * @public
     */
    startCamera(options?: VideoStreamOptions): Promise<void>;
    /**
     * Stop the camera
     * This method will stop rendering a local camera view when the call is not active
     *
     * @public
     */
    stopCamera(): Promise<void>;
    /**
     * Mute the current user during the call or disable microphone locally
     *
     * @public
     */
    mute(): Promise<void>;
    /**
     * Unmute the current user during the call or enable microphone locally
     *
     * @public
     */
    unmute(): Promise<void>;
    /**
     * Start the call.
     *
     * @param participants - An array of participant ids to join
     *
     * @public
     */
    startCall(participants: string[]): Call | undefined;
    /**
     * Start sharing the screen during a call.
     *
     * @public
     */
    startScreenShare(): Promise<void>;
    /**
     * Stop sharing the screen
     *
     * @public
     */
    stopScreenShare(): Promise<void>;
    /**
     * Remove a participant from the call.
     *
     * @param userId - Id of the participant to be removed
     *
     * @public
     */
    removeParticipant(userId: string): Promise<void>;
    /**
     * Create the html view for a stream.
     *
     * @remarks
     * This method is implemented for composite
     *
     * @param remoteUserId - Id of the participant to render, leave it undefined to create the local camera view
     * @param options - Options to control how video streams are rendered {@link @azure/communication-calling#VideoStreamOptions }
     *
     * @public
     */
    createStreamView(remoteUserId?: string, options?: VideoStreamOptions): Promise<void>;
    /**
     * Dispose the html view for a stream.
     *
     * @remarks
     * This method is implemented for composite
     *
     * @param remoteUserId - Id of the participant to render, leave it undefined to dispose the local camera view
     * @param options - Options to control how video streams are rendered {@link @azure/communication-calling#VideoStreamOptions }
     *
     * @public
     */
    disposeStreamView(remoteUserId?: string, options?: VideoStreamOptions): Promise<void>;
}

/**
 * {@link CallAdapter} state inferred from Azure Communication Services backend.
 *
 * @public
 */
export declare type CallAdapterClientState = {
    userId: CommunicationIdentifierKind;
    displayName?: string;
    call?: CallState;
    devices: DeviceManagerState;
    endedCall?: CallState;
    isTeamsCall: boolean;
    /**
     * Latest error encountered for each operation performed via the adapter.
     */
    latestErrors: AdapterErrors;
};

/**
 * Functionality for managing devices within a call.
 *
 * @public
 */
export declare interface CallAdapterDeviceManagement {
    /**
     * Ask for permissions of devices.
     *
     * @remarks
     * Browser permission window will pop up if permissions are not granted yet
     *
     * @param constrain - Define constraints for accessing local devices {@link @azure/communication-calling#PermissionConstraints }
     *
     * @public
     */
    askDevicePermission(constrain: PermissionConstraints): Promise<void>;
    /**
     * Query for available camera devices.
     *
     * @remarks
     * This method should be called after askDevicePermission()
     *
     * @return An array of video device information entities {@link @azure/communication-calling#VideoDeviceInfo }
     *
     * @public
     */
    queryCameras(): Promise<VideoDeviceInfo[]>;
    /**
     * Query for available microphone devices.
     *
     * @remarks
     * This method should be called after askDevicePermission()
     *
     * @return An array of audio device information entities {@link @azure/communication-calling#AudioDeviceInfo }
     *
     * @public
     */
    queryMicrophones(): Promise<AudioDeviceInfo[]>;
    /**
     * Query for available microphone devices.
     *
     * @remarks
     * This method should be called after askDevicePermission()
     *
     * @return An array of audio device information entities {@link @azure/communication-calling#AudioDeviceInfo }
     *
     * @public
     */
    querySpeakers(): Promise<AudioDeviceInfo[]>;
    /**
     * Set the camera to use in the call.
     *
     * @param sourceInfo - Camera device to choose, pick one returned by  {@link CallAdapterDeviceManagement#queryCameras }
     * @param options - Options to control how the camera stream is rendered {@link @azure/communication-calling#VideoStreamOptions }
     *
     * @public
     */
    setCamera(sourceInfo: VideoDeviceInfo, options?: VideoStreamOptions): Promise<void>;
    /**
     * Set the microphone to use in the call.
     *
     * @param sourceInfo - Microphone device to choose, pick one returned by {@link CallAdapterDeviceManagement#queryMicrophones }
     *
     * @public
     */
    setMicrophone(sourceInfo: AudioDeviceInfo): Promise<void>;
    /**
     * Set the speaker to use in the call.
     *
     * @param sourceInfo - Speaker device to choose, pick one returned by {@link CallAdapterDeviceManagement#querySpeakers }
     *
     * @public
     */
    setSpeaker(sourceInfo: AudioDeviceInfo): Promise<void>;
}

/**
 * {@link CallAdapter} state.
 *
 * @public
 */
export declare type CallAdapterState = CallAdapterUiState & CallAdapterClientState;

/**
 * Call composite events that can be subscribed to.
 *
 * @public
 */
export declare interface CallAdapterSubscribers {
    /**
     * Subscribe function for 'participantsJoined' event.
     */
    on(event: 'participantsJoined', listener: ParticipantsJoinedListener): void;
    /**
     * Subscribe function for 'participantsLeft' event.
     */
    on(event: 'participantsLeft', listener: ParticipantsLeftListener): void;
    /**
     * Subscribe function for 'isMutedChanged' event.
     *
     * @remarks
     * The event will be triggered whenever current user or remote user mute state changed
     *
     */
    on(event: 'isMutedChanged', listener: IsMutedChangedListener): void;
    /**
     * Subscribe function for 'callIdChanged' event.
     *
     * @remarks
     * The event will be triggered when callId of current user changed.
     *
     */
    on(event: 'callIdChanged', listener: CallIdChangedListener): void;
    /**
     * Subscribe function for 'isLocalScreenSharingActiveChanged' event.
     */
    on(event: 'isLocalScreenSharingActiveChanged', listener: IsLocalScreenSharingActiveChangedListener): void;
    /**
     * Subscribe function for 'displayNameChanged' event.
     */
    on(event: 'displayNameChanged', listener: DisplayNameChangedListener): void;
    /**
     * Subscribe function for 'isSpeakingChanged' event.
     */
    on(event: 'isSpeakingChanged', listener: IsSpeakingChangedListener): void;
    /**
     * Subscribe function for 'callEnded' event.
     */
    on(event: 'callEnded', listener: CallEndedListener): void;
    /**
     * Subscribe function for 'diagnosticChanged' event.
     *
     * This event fires whenever there is a change in user facing diagnostics about the ongoing call.
     */
    on(event: 'diagnosticChanged', listener: DiagnosticChangedEventListner): void;
    /**
     * Subscribe function for 'error' event.
     */
    on(event: 'error', listener: (e: AdapterError) => void): void;
    /**
     * Unsubscribe function for 'participantsJoined' event.
     */
    off(event: 'participantsJoined', listener: ParticipantsJoinedListener): void;
    /**
     * Unsubscribe function for 'participantsLeft' event.
     */
    off(event: 'participantsLeft', listener: ParticipantsLeftListener): void;
    /**
     * Unsubscribe function for 'isMutedChanged' event.
     */
    off(event: 'isMutedChanged', listener: IsMutedChangedListener): void;
    /**
     * Unsubscribe function for 'callIdChanged' event.
     */
    off(event: 'callIdChanged', listener: CallIdChangedListener): void;
    /**
     * Unsubscribe function for 'isLocalScreenSharingActiveChanged' event.
     */
    off(event: 'isLocalScreenSharingActiveChanged', listener: IsLocalScreenSharingActiveChangedListener): void;
    /**
     * Unsubscribe function for 'displayNameChanged' event.
     */
    off(event: 'displayNameChanged', listener: DisplayNameChangedListener): void;
    /**
     * Unsubscribe function for 'isSpeakingChanged' event.
     */
    off(event: 'isSpeakingChanged', listener: IsSpeakingChangedListener): void;
    /**
     * Unsubscribe function for 'callEnded' event.
     */
    off(event: 'callEnded', listener: CallEndedListener): void;
    /**
     * Unsubscribe function for 'diagnosticChanged' event.
     */
    off(event: 'diagnosticChanged', listener: DiagnosticChangedEventListner): void;
    /**
     * Unsubscribe function for 'error' event.
     */
    off(event: 'error', listener: (e: AdapterError) => void): void;
}

/**
 * {@link CallAdapter} state for pure UI purposes.
 *
 * @public
 */
export declare type CallAdapterUiState = {
    isLocalPreviewMicrophoneEnabled: boolean;
    page: CallCompositePage;
};

/**
 * A {@link React.Context} that stores a {@link @azure/communication-calling#CallAgent}.
 *
 * Calling components from this package must be wrapped with a {@link CallAgentProvider}.
 *
 * @public
 */
export declare const CallAgentProvider: (props: CallAgentProviderProps) => JSX.Element;

/**
 * Arguments to initialize a {@link CallAgentProvider}.
 *
 * @public
 */
export declare interface CallAgentProviderProps {
    children: React_2.ReactNode;
    callAgent?: CallAgent;
}

/**
 * State only version of {@link @azure/communication-calling#CallAgent} except calls is moved to be a child directly of
 * {@link CallClientState} and not included here. The reason to have CallAgent's state proxied is to provide access to
 * displayName. We don't flatten CallAgent.displayName and put it in CallClientState because it would be ambiguious that
 * displayName is actually reliant on the creation/existence of CallAgent to be available.
 *
 * @public
 */
export declare interface CallAgentState {
    /**
     * Proxy of {@link @azure/communication-calling#CallAgent.displayName}.
     */
    displayName?: string;
}

/**
 * A {@link React.Context} that stores a {@link StatefulCallClient}.
 *
 * Calling components from this package must be wrapped with a {@link CallClientProvider}.
 *
 * @public
 */
export declare const CallClientProvider: (props: CallClientProviderProps) => JSX.Element;

/**
 * Arguments to initialize a {@link CallClientProvider}.
 *
 * @public
 */
export declare interface CallClientProviderProps {
    children: React_2.ReactNode;
    callClient: StatefulCallClient;
}

/**
 * Container for all of the state data proxied by {@link StatefulCallClient}. The calls, callsEnded, incomingCalls, and
 * incomingCallsEnded states will be automatically provided if a callAgent has been created. The deviceManager will be
 * empty initially until populated see {@link DeviceManagerState}. The userId state is provided as a convenience for the
 * developer and is completely controled and set by the developer.
 *
 * @public
 */
export declare interface CallClientState {
    /**
     * Proxy of {@link @azure/communication-calling#CallAgent.calls} as an object with CallState {@link CallState} fields.
     * It is keyed by {@link @azure/communication-calling#Call.id}. Please note that
     * {@link @azure/communication-calling#Call.id} could change. You should not cache the id itself but the entire
     * {@link @azure/communication-calling#Call} and then use the id contained to look up data in this map.
     */
    calls: {
        [key: string]: CallState;
    };
    /**
     * Calls that have ended are stored here so the callEndReason could be checked.
     * It is an object with {@link @azure/communication-calling#Call.id} keys and {@link CallState} values.
     *
     * Only {@link MAX_CALL_HISTORY_LENGTH} Calls are kept in the history. Oldest calls are evicted if required.
     */
    callsEnded: {
        [key: string]: CallState;
    };
    /**
     * Proxy of {@link @azure/communication-calling#IncomingCall} as an object with {@link IncomingCall} fields.
     * It is keyed by {@link @azure/communication-calling#IncomingCall.id}.
     */
    incomingCalls: {
        [key: string]: IncomingCallState;
    };
    /**
     * Incoming Calls that have ended are stored here so the callEndReason could be checked.
     * It is an as an object with {@link @azure/communication-calling#Call.id} keys and {@link IncomingCall} values.
     *
     * Only {@link MAX_CALL_HISTORY_LENGTH} Calls are kept in the history. Oldest calls are evicted if required.
     */
    incomingCallsEnded: {
        [key: string]: IncomingCallState;
    };
    /**
     * Proxy of {@link @azure/communication-calling#DeviceManager}. Please review {@link DeviceManagerState}.
     */
    deviceManager: DeviceManagerState;
    /**
     * Proxy of {@link @azure/communication-calling#CallAgent}. Please review {@link CallAgentState}.
     */
    callAgent?: CallAgentState;
    /**
     * Stores a userId. This is not used by the {@link StatefulCallClient} and is provided here as a convenience for the
     * developer for easier access to userId. Must be passed in at initialization of the {@link StatefulCallClient}.
     * Completely controlled by the developer.
     */
    userId: CommunicationIdentifierKind;
    /**
     * Stores the latest error for each API method.
     *
     * See documentation of {@Link CallErrors} for details.
     */
    latestErrors: CallErrors;
}

/**
 * A customizable UI composite for calling experience.
 *
 * @remarks Call composite min width/height are as follow:
 * - mobile: 19.5rem x 21rem (312px x 336px, with default rem at 16px)
 * - desktop: 30rem x 22rem (480px x 352px, with default rem at 16px)
 *
 * @public
 */
export declare const CallComposite: (props: CallCompositeProps) => JSX.Element;

/**
 * Icons that can be overridden for {@link CallComposite}.
 *
 * @public
 */
export declare type CallCompositeIcons = Partial<Pick<CompositeIcons, 'ControlButtonCameraOff' | 'ControlButtonCameraOn' | 'ControlButtonEndCall' | 'ControlButtonMicOff' | 'ControlButtonMicOn' | 'ControlButtonOptions' | 'ControlButtonParticipants' | 'ControlButtonScreenShareStart' | 'ControlButtonScreenShareStop' | 'ErrorBarCallCameraAccessDenied' | 'ErrorBarCallCameraAlreadyInUse' | 'ErrorBarCallLocalVideoFreeze' | 'ErrorBarCallMacOsCameraAccessDenied' | 'ErrorBarCallMacOsMicrophoneAccessDenied' | 'ErrorBarCallMicrophoneAccessDenied' | 'ErrorBarCallMicrophoneMutedBySystem' | 'ErrorBarCallNetworkQualityLow' | 'ErrorBarCallNoMicrophoneFound' | 'ErrorBarCallNoSpeakerFound' | 'HorizontalGalleryLeftButton' | 'HorizontalGalleryRightButton' | 'LobbyScreenConnectingToCall' | 'LobbyScreenWaitingToBeAdmitted' | 'LocalDeviceSettingsCamera' | 'LocalDeviceSettingsMic' | 'LocalDeviceSettingsSpeaker' | 'LocalPreviewPlaceholder' | 'Muted' | 'NetworkReconnectIcon' | 'NoticePageAccessDeniedTeamsMeeting' | 'NoticePageJoinCallFailedDueToNoNetwork' | 'NoticePageLeftCall' | 'NoticePageRemovedFromCall' | 'OptionsCamera' | 'OptionsMic' | 'OptionsSpeaker' | 'ParticipantItemMicOff' | 'ParticipantItemOptions' | 'ParticipantItemOptionsHovered' | 'ParticipantItemScreenShareStart' | 'VideoTileMicOff'>>;

/**
 * Optional features of the {@link CallComposite}.
 *
 * @public
 */
export declare type CallCompositeOptions = {
    /**
     * Surface Azure Communication Services backend errors in the UI with {@link @azure/communication-react#ErrorBar}.
     * Hide or show the error bar.
     * @defaultValue true
     */
    errorBar?: boolean;
    /**
     * Hide or Customize the control bar element.
     * Can be customized by providing an object of type {@link @azure/communication-react#CallControlOptions}.
     * @defaultValue true
     */
    callControls?: boolean | CallControlOptions;
};

/**
 * Major UI screens shown in the {@link CallComposite}.
 *
 * @public
 */
export declare type CallCompositePage = 'accessDeniedTeamsMeeting' | 'call' | 'configuration' | 'joinCallFailedDueToNoNetwork' | 'leftCall' | 'lobby' | 'removedFromCall';

/**
 * Props for {@link CallComposite}.
 *
 * @public
 */
export declare interface CallCompositeProps extends BaseCompositeProps<CallCompositeIcons> {
    /**
     * An adapter provides logic and data to the composite.
     * Composite can also be controlled using the adapter.
     */
    adapter: CallAdapter;
    /**
     * Optimizes the composite form factor for either desktop or mobile.
     * @remarks `mobile` is currently only optimized for Portrait mode on mobile devices and does not support landscape.
     * @defaultValue 'desktop'
     */
    formFactor?: 'desktop' | 'mobile';
    /**
     * URL to invite new participants to the current call. If this is supplied, a button appears in the Participants
     * Button flyout menu.
     */
    callInvitationUrl?: string;
    /**
     * Flags to enable/disable or customize UI elements of the {@link CallComposite}.
     */
    options?: CallCompositeOptions;
}

/**
 * Strings used by the {@link CallComposite} directly.
 *
 * This strings are in addition to those used by the components from the component library.
 *
 * @public
 */
export declare interface CallCompositeStrings {
    /**
     * Title of configuration page.
     */
    configurationPageTitle: string;
    /**
     * Optional 1-2 lines on the call details used on the configuration page.
     */
    configurationPageCallDetails?: string;
    /**
     * Text in button to start call in configuration page.
     */
    startCallButtonLabel: string;
    /**
     * Text in button to rejoin an ended call.
     */
    rejoinCallButtonLabel: string;
    /**
     * Placeholder text for local device settings dropdowns.
     */
    defaultPlaceHolder: string;
    /**
     * Label for camera dropdown.
     */
    cameraLabel: string;
    /**
     * Label for sound dropdown.
     */
    soundLabel: string;
    /**
     * Error shown when camera access is blocked by the browser.
     */
    cameraPermissionDenied: string;
    /**
     * Error shown when the camera is turned off.
     */
    cameraTurnedOff: string;
    /**
     * Error shown when microphone access is blocked by the browser.
     */
    microphonePermissionDenied: string;
    /**
     * Title text of the page shown to the user when joining a Teams meeting fails because meeting owner denied access.
     */
    failedToJoinTeamsMeetingReasonAccessDeniedTitle: string;
    /**
     * More details text of the page shown to the user when joining a Teams meeting fails because meeting owner denied access.
     */
    failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails?: string;
    /**
     * Title text of the page shown to the user when joining a call fails due to a network problem.
     */
    failedToJoinCallDueToNoNetworkTitle: string;
    /**
     * More details text of the page shown to the user when joining a call fails due to a network problem.
     */
    failedToJoinCallDueToNoNetworkMoreDetails?: string;
    /**
     * Title text of the page shown to the user when they leave a call in the call composite.
     */
    leftCallTitle: string;
    /**
     * More details text of the page shown to the user when they leave a call in the call composite.
     */
    leftCallMoreDetails?: string;
    /**
     * Title text of the page shown to the user when they are removed from a call in the call composite.
     */
    removedFromCallTitle: string;
    /**
     * More details text of the page shown to the user when they are removed from a call in the call composite.
     */
    removedFromCallMoreDetails?: string;
    /**
     * Text shown to the user on the lobby screen when connecting to a call.
     */
    lobbyScreenConnectingToCallTitle: string;
    /**
     * Optional addition details shown to the user on the lobby screen when connection to a call.
     */
    lobbyScreenConnectingToCallMoreDetails?: string;
    /**
     * Text shown to the user on the lobby screen when waiting to be admitted to a call.
     */
    lobbyScreenWaitingToBeAdmittedTitle: string;
    /**
     * Optional additional details shown to the user on the lobby screen when waiting to be admitted to a call.
     */
    lobbyScreenWaitingToBeAdmittedMoreDetails?: string;
    /**
     * Message shown to the user when they are speaking while muted.
     */
    mutedMessage: string;
    /**
     * Text for link to MS privacy policy in Compliance Banner.
     */
    privacyPolicy: string;
    /**
     * Text for link to learn more about a specific subject.
     */
    learnMore: string;
    /**
     * Message to let user know the meeting is only being recorded (no transcription) in ComplianceBanner.
     */
    complianceBannerNowOnlyRecording: string;
    /**
     * Message to let user know the meeting is only being transcripted (no recording) in ComplianceBanner.
     */
    complianceBannerNowOnlyTranscription: string;
    /**
     * Message to let user know recording and transcription of the meeting are saved in ComplianceBanner.
     */
    complianceBannerRecordingAndTranscriptionSaved: string;
    /**
     * Message to let user know recording and transcription of the meeting have started in ComplianceBanner.
     */
    complianceBannerRecordingAndTranscriptionStarted: string;
    /**
     * Message to let user know recording and transcription of the meeting have stopped in ComplianceBanner.
     */
    complianceBannerRecordingAndTranscriptionStopped: string;
    /**
     * Message to let user know recording of the meeting is being saved in ComplianceBanner.
     */
    complianceBannerRecordingSaving: string;
    /**
     * Message to let user know recording of the meeting has started in ComplianceBanner.
     */
    complianceBannerRecordingStarted: string;
    /**
     * Message to let user know recording of the meeting has stopped in ComplianceBanner.
     */
    complianceBannerRecordingStopped: string;
    /**
     * Message to let user know they are giving consent to meeting being transcripted in ComplianceBanner.
     */
    complianceBannerTranscriptionConsent: string;
    /**
     * Message to let user know transcription of the meeting is being saved in ComplianceBanner.
     */
    complianceBannerTranscriptionSaving: string;
    /**
     * Message to let user know transcription of the meeting has started in ComplianceBanner.
     */
    complianceBannerTranscriptionStarted: string;
    /**
     * Message to let user know the transcription of the meeting has stopped in ComplianceBanner.
     */
    complianceBannerTranscriptionStopped: string;
    /**
     * Text for close button.
     */
    close: string;
    /**
     * Title text of the page shown to the user when there is intermittent network failure during a call.
     */
    networkReconnectTitle: string;
    /**
     * More details text of the page shown to the user when there is intermittent network failure during a call.
     */
    networkReconnectMoreDetails: string;
    /**
     * Tooltip text used to inform a user that toggling microphone in lobby is not supported.
     */
    microphoneToggleInLobbyNotAllowed: string;
}

/**
 * Customization options for the control bar in calling experience.
 *
 * @public
 */
export declare type CallControlOptions = {
    /**
     * Options to change how the call controls are displayed.
     * `'compact'` display type will decreases the size of buttons and hide the labels.
     *
     * @remarks
     * If the composite `formFactor` is set to `'mobile'`, the control bar will always use compact view.
     *
     * @defaultValue 'default'
     */
    displayType?: 'default' | 'compact';
    /**
     * Show or Hide Camera Button during a call
     * @defaultValue true
     */
    cameraButton?: boolean;
    /**
     * Show or Hide EndCall button during a call.
     * @defaultValue true
     */
    endCallButton?: boolean;
    /**
     * Show or Hide Microphone button during a call.
     * @defaultValue true
     */
    microphoneButton?: boolean;
    /**
     * Show or Hide Devices button during a call.
     * @defaultValue true
     */
    devicesButton?: boolean;
    /**
     * Show, Hide or Disable participants button during a call.
     * @defaultValue true
     */
    participantsButton?: boolean | {
        disabled: boolean;
    };
    /**
     * Show, Hide or Disable the screen share button during a call.
     * @defaultValue true
     */
    screenShareButton?: boolean | {
        disabled: boolean;
    };
};

/**
 * Callback for {@link CallAdapterSubscribers} 'callEnded' event.
 *
 * @public
 */
export declare type CallEndedListener = (event: {
    callId: string;
}) => void;

/**
 * Error thrown from failed stateful API methods.
 *
 * @public
 */
export declare class CallError extends Error {
    /**
     * The API method target that failed.
     */
    target: CallErrorTarget;
    /**
     * Error thrown by the failed SDK method.
     */
    innerError: Error;
    /**
     * Timestamp added to the error by the stateful layer.
     */
    timestamp: Date;
    constructor(target: CallErrorTarget, innerError: Error, timestamp?: Date);
}

/**
 * Selector type for {@link ErrorBar} component.
 *
 * @public
 */
export declare type CallErrorBarSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    activeErrorMessages: ActiveErrorMessage[];
};

/**
 * Errors teed from API calls to the Calling SDK.
 *
 * Each property in the object stores the latest error for a particular SDK API method.
 *
 * Errors from this object can be cleared using the {@link newClearCallErrorsModifier}.
 * Additionally, errors are automatically cleared when:
 * - The state is cleared.
 * - Subsequent calls to related API methods succeed.
 * See documentation of individual stateful client methods for details on when errors may be automatically cleared.
 *
 * @public
 */
export declare type CallErrors = {
    [target in CallErrorTarget]: CallError;
};

/**
 * String literal type for all permissible keys in {@Link CallErrors}.
 *
 * @public
 */
export declare type CallErrorTarget = 'Call.addParticipant' | 'Call.feature' | 'Call.hangUp' | 'Call.hold' | 'Call.mute' | 'Call.off' | 'Call.on' | 'Call.removeParticipant' | 'Call.resume' | 'Call.sendDtmf' | 'Call.startScreenSharing' | 'Call.startVideo' | 'Call.stopScreenSharing' | 'Call.stopVideo' | 'Call.unmute' | 'CallAgent.dispose' | 'CallAgent.join' | 'CallAgent.off' | 'CallAgent.on' | 'CallAgent.startCall' | 'CallClient.createCallAgent' | 'CallClient.getDeviceManager' | 'DeviceManager.askDevicePermission' | 'DeviceManager.getCameras' | 'DeviceManager.getMicrophones' | 'DeviceManager.getSpeakers' | 'DeviceManager.off' | 'DeviceManager.on' | 'DeviceManager.selectMicrophone' | 'DeviceManager.selectSpeaker';

/**
 * Callback for {@link CallAdapterSubscribers} 'callIdChanged' event.
 *
 * @public
 */
export declare type CallIdChangedListener = (event: {
    callId: string;
}) => void;

/**
 * Common props used to reference calling declarative client state.
 *
 * @public
 */
export declare type CallingBaseSelectorProps = {
    callId: string;
};

/**
 * Object containing all the handlers required for calling components.
 *
 * Calling related components from this package are able to pick out relevant handlers from this object.
 * See {@link useHandlers} and {@link usePropsFor}.
 *
 * @public
 */
export declare type CallingHandlers = {
    onStartLocalVideo: () => Promise<void>;
    onToggleCamera: (options?: VideoStreamOptions) => Promise<void>;
    onStartCall: (participants: (CommunicationUserIdentifier | PhoneNumberIdentifier | UnknownIdentifier)[], options?: StartCallOptions) => Call | undefined;
    onSelectMicrophone: (device: AudioDeviceInfo) => Promise<void>;
    onSelectSpeaker: (device: AudioDeviceInfo) => Promise<void>;
    onSelectCamera: (device: VideoDeviceInfo, options?: VideoStreamOptions) => Promise<void>;
    onToggleMicrophone: () => Promise<void>;
    onStartScreenShare: () => Promise<void>;
    onStopScreenShare: () => Promise<void>;
    onToggleScreenShare: () => Promise<void>;
    onHangUp: () => Promise<void>;
    onCreateLocalStreamView: (options?: VideoStreamOptions) => Promise<void>;
    onCreateRemoteStreamView: (userId: string, options?: VideoStreamOptions) => Promise<void>;
    onRemoveParticipant: (userId: string) => Promise<void>;
    onDisposeRemoteStreamView: (userId: string) => Promise<void>;
    onDisposeLocalStreamView: () => Promise<void>;
};

/**
 * Helper type for {@link usePropsFor}.
 *
 * @public
 */
export declare type CallingReturnProps<Component extends (props: any) => JSX.Element> = GetCallingSelector<Component> extends (state: CallClientState, props: any) => any ? ReturnType<GetCallingSelector<Component>> & Common<CallingHandlers, Parameters<Component>[0]> : never;

/**
 * Custom Fluent theme pallete used by calling related components in this library.
 *
 * @public
 */
export declare interface CallingTheme {
    callingPalette: {
        callRed: string;
        callRedDark: string;
        callRedDarker: string;
        iconWhite: string;
    };
}

/**
 * Calling participant's state, as reflected in the UI components.
 *
 * @public
 */
export declare type CallParticipantListParticipant = ParticipantListParticipant & {
    /** State of calling participant */
    state: 'Idle' | 'Connecting' | 'Ringing' | 'Connected' | 'Hold' | 'InLobby' | 'EarlyMedia' | 'Disconnected';
    /** Whether calling participant is screen sharing */
    isScreenSharing?: boolean;
    /** Whether calling participant is muted */
    isMuted?: boolean;
    /** Whether calling participant is speaking */
    isSpeaking?: boolean;
};

/**
 * A {@link React.Context} that stores a {@link @azure/communication-calling#Call}.
 *
 * Calling components from this package must be wrapped with a {@link CallProvider}.
 *
 * @public
 */
export declare const CallProvider: (props: CallProviderProps) => JSX.Element;

/**
 * Arguments to initialize a {@link CallProvider}.
 *
 * @public
 */
export declare interface CallProviderProps {
    children: React_2.ReactNode;
    call?: Call;
}

/**
 * State only version of {@link @azure/communication-calling#Call}. {@link StatefulCallClient} will automatically
 * retrieve Call's state and add it to the state exposed by {@link StatefulCallClient}.
 *
 * @public
 */
export declare interface CallState {
    /**
     * Proxy of {@link @azure/communication-calling#Call.id}.
     */
    id: string;
    /**
     * Proxy of {@link @azure/communication-calling#Call.callerInfo}.
     */
    callerInfo: CallerInfo;
    /**
     * Proxy of {@link @azure/communication-calling#Call.state}.
     */
    state: CallState_2;
    /**
     * Proxy of {@link @azure/communication-calling#Call.callEndReason}.
     */
    callEndReason?: CallEndReason;
    /**
     * Proxy of {@link @azure/communication-calling#Call.direction}.
     */
    direction: CallDirection;
    /**
     * Proxy of {@link @azure/communication-calling#Call.isMuted}.
     */
    isMuted: boolean;
    /**
     * Proxy of {@link @azure/communication-calling#Call.isScreenSharingOn}.
     */
    isScreenSharingOn: boolean;
    /**
     * Proxy of {@link @azure/communication-calling#DominantSpeakersInfo }.
     */
    dominantSpeakers?: DominantSpeakersInfo;
    /**
     * Proxy of {@link @azure/communication-calling#Call.localVideoStreams}.
     */
    localVideoStreams: LocalVideoStreamState[];
    /**
     * Proxy of {@link @azure/communication-calling#Call.remoteParticipants}.
     * Object with {@link RemoteParticipant} fields keyed by flattened {@link RemoteParticipantState.identifier}.
     * To obtain a flattened {@link RemoteParticipantState.identifier}, use
     * {@link @azure/communication-react#toFlatCommunicationIdentifier}.
     */
    remoteParticipants: {
        [keys: string]: RemoteParticipantState;
    };
    /**
     * Stores remote participants that have left the call so that the callEndReason could be retrieved.
     * Object with {@link RemoteParticipant} fields keyed by flattened {@link RemoteParticipantState.identifier}.
     * To obtain a flattened {@link RemoteParticipantState.identifier}, use
     * {@link @azure/communication-react#toFlatCommunicationIdentifier}.
     */
    remoteParticipantsEnded: {
        [keys: string]: RemoteParticipantState;
    };
    /**
     * Proxy of {@link @azure/communication-calling#TranscriptionCallFeature}.
     */
    transcription: TranscriptionCallFeature;
    /**
     * Proxy of {@link @azure/communication-calling#RecordingCallFeature}.
     */
    recording: RecordingCallFeature;
    /**
     * Stores the currently active screenshare participant's key. If there is no screenshare active, then this will be
     * undefined. You can use this key to access the remoteParticipant data in {@link CallState.remoteParticipants} object.
     *
     * Note this only applies to ScreenShare in RemoteParticipant. A local ScreenShare being active will not affect this
     * property.
     *
     * This property is added by the stateful layer and is not a proxy of SDK state
     */
    screenShareRemoteParticipant?: string;
    /**
     * Stores the local date when the call started on the client. This property is added by the stateful layer and is not
     * a proxy of SDK state.
     */
    startTime: Date;
    /**
     * Stores the local date when the call ended on the client. This property is added by the stateful layer and is not
     * a proxy of SDK state.
     */
    endTime: Date | undefined;
    /**
     * Stores the latest call diagnostics.
     */
    diagnostics: DiagnosticsCallFeatureState;
}

/**
 * A button to turn camera on / off.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
export declare const CameraButton: (props: CameraButtonProps) => JSX.Element;

/**
 * Props for {@link CameraButton} component.
 *
 * @public
 */
export declare interface CameraButtonProps extends ControlBarButtonProps {
    /**
     * Utility property for using this component with `communication react eventHandlers`.
     * Maps directly to the `onClick` property.
     */
    onToggleCamera?: (options?: VideoStreamOptions) => Promise<void>;
    /**
     * Options for rendering local video view.
     */
    localVideoViewOptions?: VideoStreamOptions;
    /**
     * Optional strings to override in component
     */
    strings?: Partial<CameraButtonStrings>;
}

/**
 * Selector type for {@link CameraButton} component.
 *
 * @public
 */
export declare type CameraButtonSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    disabled: boolean;
    checked: boolean;
};

/**
 * Strings of CameraButton that can be overridden.
 *
 * @public
 */
export declare interface CameraButtonStrings {
    /** Label when button is on. */
    onLabel: string;
    /** Label when button is off. */
    offLabel: string;
    /** Tooltip content when the button is disabled. */
    tooltipDisabledContent?: string;
    /** Tooltip content when the button is on. */
    tooltipOnContent?: string;
    /** Tooltip content when the button is off. */
    tooltipOffContent?: string;
}

/**
 * {@link ChatComposite} Adapter interface.
 *
 * @public
 */
export declare interface ChatAdapter extends ChatAdapterThreadManagement, AdapterState<ChatAdapterState>, Disposable, ChatAdapterSubscribers {
}

/**
 * {@link ChatAdapter} state.
 *
 * @public
 */
export declare type ChatAdapterState = ChatAdapterUiState & ChatCompositeClientState;

/**
 * Chat composite events that can be subscribed to.
 *
 * @public
 */
export declare interface ChatAdapterSubscribers {
    /**
     * Subscribe function for 'messageReceived' event.
     */
    on(event: 'messageReceived', listener: MessageReceivedListener): void;
    /**
     * Subscribe function for 'messageSent' event.
     */
    on(event: 'messageSent', listener: MessageSentListener): void;
    /**
     * Subscribe function for 'messageRead' event.
     */
    on(event: 'messageRead', listener: MessageReadListener): void;
    /**
     * Subscribe function for 'participantsAdded' event.
     */
    on(event: 'participantsAdded', listener: ParticipantsAddedListener): void;
    /**
     * Subscribe function for 'participantsRemoved' event.
     */
    on(event: 'participantsRemoved', listener: ParticipantsRemovedListener): void;
    /**
     * Subscribe function for 'topicChanged' event.
     */
    on(event: 'topicChanged', listener: TopicChangedListener): void;
    /**
     * Subscribe function for 'error' event.
     */
    on(event: 'error', listener: (e: AdapterError) => void): void;
    /**
     * Unsubscribe function for 'messageReceived' event.
     */
    off(event: 'messageReceived', listener: MessageReceivedListener): void;
    /**
     * Unsubscribe function for 'messageSent' event.
     */
    off(event: 'messageSent', listener: MessageSentListener): void;
    /**
     * Unsubscribe function for 'messageRead' event.
     */
    off(event: 'messageRead', listener: MessageReadListener): void;
    /**
     * Unsubscribe function for 'participantsAdded' event.
     */
    off(event: 'participantsAdded', listener: ParticipantsAddedListener): void;
    /**
     * Unsubscribe function for 'participantsRemoved' event.
     */
    off(event: 'participantsRemoved', listener: ParticipantsRemovedListener): void;
    /**
     * Unsubscribe function for 'topicChanged' event.
     */
    off(event: 'topicChanged', listener: TopicChangedListener): void;
    /**
     * Unsubscribe function for 'error' event.
     */
    off(event: 'error', listener: (e: AdapterError) => void): void;
}

/**
 * Functionality for managing the current chat thread.
 *
 * @public
 */
export declare interface ChatAdapterThreadManagement {
    /**
     * Fetch initial state for the Chat adapter.
     *
     * Performs the minimal fetch necessary for ChatComposite and API methods.
     */
    fetchInitialData(): Promise<void>;
    /**
     * Send a message in the thread.
     */
    sendMessage(content: string): Promise<void>;
    /**
     * Send a read receipt for a message.
     */
    sendReadReceipt(chatMessageId: string): Promise<void>;
    /**
     * Send typing indicator in the thread.
     */
    sendTypingIndicator(): Promise<void>;
    /**
     * Remove a participant in the thread.
     */
    removeParticipant(userId: string): Promise<void>;
    /**
     * Set the topic for the thread.
     */
    setTopic(topicName: string): Promise<void>;
    /**
     * Update a message content.
     */
    updateMessage(messageId: string, content: string): Promise<void>;
    /**
     * Delete a message in the thread.
     */
    deleteMessage(messageId: string): Promise<void>;
    /**
     * Load more previous messages in the chat thread history.
     *
     * @remarks
     * This method is usually used to control incremental fetch/infinite scroll
     *
     */
    loadPreviousChatMessages(messagesToLoad: number): Promise<boolean>;
}

/**
 * {@link ChatAdapter} state for pure UI purposes.
 *
 * @public
 */
export declare type ChatAdapterUiState = {
    error?: Error;
};

/**
 * Common props for selectors for {@link ChatClientState}.
 *
 * @public
 */
export declare type ChatBaseSelectorProps = {
    threadId: string;
};

/**
 * A {@link React.Context} that stores a {@link StatefulChatClient}.
 *
 * Chat components from this package must be wrapped with a {@link ChatClientProvider}.
 *
 * @public
 */
export declare const ChatClientProvider: (props: ChatClientProviderProps) => JSX.Element;

/**
 * Arguments to initialize a {@link ChatClientProvider}.
 *
 * @public
 */
export declare type ChatClientProviderProps = {
    children: React_2.ReactNode;
    chatClient: StatefulChatClient;
};

/**
 * Centralized state for {@link @azure/communication-chat#ChatClient}.
 *
 * @public
 */
export declare type ChatClientState = {
    /**
     * Identifier of the current user.
     */
    userId: CommunicationIdentifierKind;
    /**
     * DisplayName of the current user.
     * The same value as what others see in {@link @azure/communication-chat#ChatParticipant.displayName}
     */
    displayName: string;
    /**
     * Chat threads joined by the current user.
     * Object with {@link ChatThreadClientState} fields, keyed by {@link ChatThreadClientState.threadId}.
     */
    threads: {
        [key: string]: ChatThreadClientState;
    };
    /**
     * Stores the latest error for each API method.
     *
     * See documentation of {@link ChatErrors} for details.
     */
    latestErrors: ChatErrors;
};

/**
 * A customizable UI composite for the chat experience.
 *
 * @remarks Chat composite min width and height are respectively 19.5rem and 20rem (312px and 320px, with default rem at 16px)
 *
 * @public
 */
export declare const ChatComposite: (props: ChatCompositeProps) => JSX.Element;

/**
 * {@link ChatAdapter} state inferred from Azure Communication Services backend.
 *
 * @public
 */
export declare type ChatCompositeClientState = {
    userId: CommunicationIdentifierKind;
    displayName: string;
    thread: ChatThreadClientState;
    /**
     * Latest error encountered for each operation performed via the adapter.
     */
    latestErrors: AdapterErrors;
};

/**
 * Icons that can be overridden for {@link ChatComposite}.
 *
 * @public
 */
export declare type ChatCompositeIcons = Partial<Pick<CompositeIcons, 'MessageDelivered' | 'MessageFailed' | 'MessageSeen' | 'MessageSending' | 'MessageEdit' | 'MessageRemove' | 'ParticipantItemOptions' | 'ParticipantItemOptionsHovered' | 'SendBoxSend' | 'SendBoxSendHovered' | 'EditBoxCancel' | 'EditBoxSubmit'>>;

/**
 * Optional features of the {@link ChatComposite}.
 *
 * @public
 */
export declare type ChatCompositeOptions = {
    /**
     * Surface Azure Communication Services backend errors in the UI with {@link @azure/communication-react#ErrorBar}.
     * Hide or show the error bar.
     * @defaultValue true
     */
    errorBar?: boolean;
    /**
     * Show or hide the topic at the top of the chat. Hidden if set to `false`
     * @defaultValue true
     */
    topic?: boolean;
};

/**
 * Props for {@link ChatComposite}.
 *
 * @public
 */
export declare interface ChatCompositeProps extends BaseCompositeProps<ChatCompositeIcons> {
    /**
     * An adapter provides logic and data to the composite.
     * Composite can also be controlled using the adapter.
     */
    adapter: ChatAdapter;
    /**
     * `(messageProps: MessageProps, defaultOnRender?: MessageRenderer) => JSX.Element`
     * A callback for customizing the message renderer.
     */
    onRenderMessage?: (messageProps: MessageProps, defaultOnRender?: MessageRenderer) => JSX.Element;
    /**
     * `(typingUsers: CommunicationParticipant[]) => JSX.Element`
     * A callback for customizing the typing indicator renderer.
     */
    onRenderTypingIndicator?: (typingUsers: CommunicationParticipant[]) => JSX.Element;
    /**
     * Flags to enable/disable visual elements of the {@link ChatComposite}.
     */
    options?: ChatCompositeOptions;
}

/**
 * Strings used by the {@link ChatComposite} directly.
 *
 * This strings are in addition to those used by the components from the component library.
 *
 * @public
 */
export declare interface ChatCompositeStrings {
    /**
     * Chat list header text
     */
    chatListHeader: string;
}

/**
 * Error thrown from failed {@link StatefulChatClient} methods.
 *
 * @public
 */
export declare class ChatError extends Error {
    /**
     * The API method target that failed.
     */
    target: ChatErrorTarget;
    /**
     * Error thrown by the failed SDK method.
     */
    innerError: Error;
    /**
     * Timestamp added to the error by the stateful layer.
     */
    timestamp: Date;
    constructor(target: ChatErrorTarget, innerError: Error, timestamp?: Date);
}

/**
 * Selector type for {@link ErrorBar} component.
 *
 * @public
 */
export declare type ChatErrorBarSelector = (state: ChatClientState, props: ChatBaseSelectorProps) => {
    activeErrorMessages: ActiveErrorMessage[];
};

/**
 * Errors teed from API calls to the Chat SDK.
 *
 * Each property in the object stores the latest error for a particular SDK API method.
 *
 * @public
 */
export declare type ChatErrors = {
    [target in ChatErrorTarget]: ChatError;
};

/**
 * String literal type for all permissible keys in {@link ChatErrors}.
 *
 * @public
 */
export declare type ChatErrorTarget = 'ChatClient.createChatThread' | 'ChatClient.deleteChatThread' | 'ChatClient.getChatThreadClient' | 'ChatClient.listChatThreads' | 'ChatClient.off' | 'ChatClient.on' | 'ChatClient.startRealtimeNotifications' | 'ChatClient.stopRealtimeNotifications' | 'ChatThreadClient.addParticipants' | 'ChatThreadClient.deleteMessage' | 'ChatThreadClient.getMessage' | 'ChatThreadClient.getProperties' | 'ChatThreadClient.listMessages' | 'ChatThreadClient.listParticipants' | 'ChatThreadClient.listReadReceipts' | 'ChatThreadClient.removeParticipant' | 'ChatThreadClient.sendMessage' | 'ChatThreadClient.sendReadReceipt' | 'ChatThreadClient.sendTypingNotification' | 'ChatThreadClient.updateMessage' | 'ChatThreadClient.updateTopic';

/**
 * Object containing all the handlers required for chat components.
 *
 * Chat related components from this package are able to pick out relevant handlers from this object.
 * See {@link useHandlers} and {@link usePropsFor}.
 *
 * @public
 */
export declare type ChatHandlers = {
    onSendMessage: (content: string) => Promise<void>;
    onMessageSeen: (chatMessageId: string) => Promise<void>;
    onTyping: () => Promise<void>;
    onRemoveParticipant: (userId: string) => Promise<void>;
    updateThreadTopicName: (topicName: string) => Promise<void>;
    onLoadPreviousChatMessages: (messagesToLoad: number) => Promise<boolean>;
    onUpdateMessage: (messageId: string, content: string) => Promise<void>;
    onDeleteMessage: (messageId: string) => Promise<void>;
};

/**
 * A chat message.
 *
 * @public
 */
export declare interface ChatMessage extends MessageCommon {
    messageType: 'chat';
    content?: string;
    editedOn?: Date;
    deletedOn?: Date;
    senderId?: string;
    senderDisplayName?: string;
    status?: MessageStatus;
    attached?: MessageAttachedStatus;
    mine?: boolean;
    clientMessageId?: string;
    contentType: MessageContentType;
}

/**
 * An extension to {@link @azure/communication-chat#ChatMessage} that stores
 * client-side only metadata for chat messages.
 *
 * TODO: The name has bitrotted. Rename me.
 *
 * @public
 */
export declare type ChatMessageWithStatus = ChatMessage_2 & {
    clientMessageId?: string;
    status: MessageStatus;
};

/**
 * Selector type for {@link ParticipantList} component.
 *
 * @public
 */
export declare type ChatParticipantListSelector = (state: ChatClientState, props: ChatBaseSelectorProps) => {
    myUserId: string;
    participants: ParticipantListParticipant[];
};

/**
 * Helper type for {@link usePropsFor}.
 *
 * @public
 */
export declare type ChatReturnProps<Component extends (props: any) => JSX.Element> = GetChatSelector<Component> extends (state: ChatClientState, props: any) => any ? ReturnType<GetChatSelector<Component>> & Common<ChatHandlers, Parameters<Component>[0]> : never;

/**
 * A {@link React.Context} that stores a {@link @azure/communication-chat#ChatThreadClient}.
 *
 * Chat components from this package must be wrapped with a {@link ChatThreadClientProvider}.
 *
 * @public
 */
export declare const ChatThreadClientProvider: (props: ChatThreadClientProviderProps) => JSX.Element;

/**
 * Arguments to initialize a {@link ChatThreadClientProvider}.
 *
 * @public
 */
export declare type ChatThreadClientProviderProps = {
    children: React_2.ReactNode;
    chatThreadClient: ChatThreadClient;
};

/**
 * Centralized state for {@link @azure/communication-chat#ChatThreadClient}.
 *
 * @public
 */
export declare type ChatThreadClientState = {
    /**
     * Messages in this thread.
     * Object with {@link ChatMessageWithStatus} entries
     * Local messages are keyed by keyed by {@link ChatMessageWithStatus.clientMessageId}.
     * Remote messages are keyed by {@link @azure/communication-chat#ChatMessage.id}.
     */
    chatMessages: {
        [key: string]: ChatMessageWithStatus;
    };
    /**
     * Participants of this chat thread.
     *
     * Object with {@link @azure/communication-chat#ChatParticipant} fields,
     * keyed by {@link @azure/communication-chat#ChatParticipant.id}.
     */
    participants: {
        [key: string]: ChatParticipant;
    };
    /**
     * Id of this chat thread. Returned from {@link @azure/communication-chat#ChatThreadClient.threadId}
     */
    threadId: string;
    /**
     * An object containing properties of this chat thread.
     */
    properties?: ChatThreadProperties;
    /**
     * An array of ReadReceipts of this chat thread. Returned from {@link @azure/communication-chat#ChatThreadClient.listReadReceipts}
     */
    readReceipts: ChatMessageReadReceipt[];
    /**
     * An array of typingIndicators of this chat thread. Captured from event listener of {@link @azure/communication-chat#ChatClient}
     * Stateful client only stores recent 8000ms real-time typing indicators data.
     */
    typingIndicators: TypingIndicatorReceivedEvent[];
    /**
     * Latest timestamp when other users read messages sent by current user.
     */
    latestReadTime: Date;
};

/**
 * Properties of a chat thread.
 *
 * \@azure/communication-chat exports two interfaces for this concept,
 * and \@azure/communication-signaling exports another.
 *
 * We define a minimal one that helps us hide the different types used by underlying API.
 *
 * @public
 */
export declare type ChatThreadProperties = {
    topic?: string;
};

/**
 * Centralized state for {@link @azure/communication-calling#CallClient} or {@link @azure/communication-chat#ChatClient}.
 *
 * See also: {@link CallClientState}, {@link ChatClientState}.
 * @public
 */
export declare type ClientState = CallClientState & ChatClientState;

/**
 * Return intersect type of 2 types
 *
 * @public
 */
export declare type Common<A, B> = Pick<A, CommonProperties<A, B>>;

/**
 * Return intersect properties of 2 types
 *
 * @public
 */
export declare type CommonProperties<A, B> = {
    [P in keyof A & keyof B]: A[P] extends B[P] ? P : never;
}[keyof A & keyof B];

/**
 * A Chat or Calling participant's state, as reflected in the UI.
 *
 * @public
 */
export declare type CommunicationParticipant = {
    /** User ID of participant */
    userId: string;
    /** Display name of participant */
    displayName?: string;
};

/**
 * Locale for  German (Germany).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_DE_DE: ComponentLocale;

/**
 * Locale for English (GB).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_EN_GB: ComponentLocale;

/**
 * Locale for English (US).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_EN_US: ComponentLocale;

/**
 * Locale for Spanish (Spain).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_ES_ES: ComponentLocale;

/**
 * Locale for French (France).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_FR_FR: ComponentLocale;

/**
 * Locale for Italian (Italy).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_IT_IT: ComponentLocale;

/**
 * Locale for Japanese (Japan).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_JA_JP: ComponentLocale;

/**
 * Locale for Korean (South Korea).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_KO_KR: ComponentLocale;

/**
 * Locale for Dutch (Netherlands).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_NL_NL: ComponentLocale;

/**
 * Locale for Portuguese (Brazil).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_PT_BR: ComponentLocale;

/**
 * Locale for Russian (Russia).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_RU_RU: ComponentLocale;

/**
 * Locale for Turkish (Turkey).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_TR_TR: ComponentLocale;

/**
 * Locale for Chinese (Mainland China).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_ZH_CN: ComponentLocale;

/**
 * Locale for Chinese (Taiwan).
 *
 * @public
 */
export declare const COMPONENT_LOCALE_ZH_TW: ComponentLocale;

/**
 * Icons used by the React components exported from this library.
 *
 * @remark See {@link CompositeIcons} for icons used by composites only.
 *
 * @public
 */
export declare type ComponentIcons = Record<keyof typeof DEFAULT_COMPONENT_ICONS, JSX.Element>;

/**
 * Locale information for all components exported from this library.
 *
 * @public
 */
export declare interface ComponentLocale {
    /** Strings for components */
    strings: ComponentStrings;
}

/**
 * Helper type for {@link usePropsFor}.
 *
 * @public
 */
export declare type ComponentProps<Component extends (props: any) => JSX.Element> = ChatReturnProps<Component> extends never ? CallingReturnProps<Component> extends never ? undefined : CallingReturnProps<Component> : ChatReturnProps<Component>;

/**
 * Strings used by all components exported from this library.
 *
 * @public
 */
export declare interface ComponentStrings {
    /** Strings for MessageThread */
    messageThread: MessageThreadStrings;
    /** Strings for ParticipantItem */
    participantItem: ParticipantItemStrings;
    /** Strings for CameraButton */
    cameraButton: CameraButtonStrings;
    /** Strings for MicrophoneButton */
    microphoneButton: MicrophoneButtonStrings;
    /** Strings for EndCallButton */
    endCallButton: EndCallButtonStrings;
    /** Strings for DevicesButton */
    devicesButton: DevicesButtonStrings;
    /** Strings for ParticipantsButton */
    participantsButton: ParticipantsButtonStrings;
    /** Strings for ScreenShareButton */
    screenShareButton: ScreenShareButtonStrings;
    /** Strings for TypingIndicator */
    typingIndicator: TypingIndicatorStrings;
    /** Strings for SendBox */
    sendBox: SendBoxStrings;
    /** Strings for MessageStatusIndicator */
    messageStatusIndicator: MessageStatusIndicatorStrings;
    /** Strings for ErroBar */
    errorBar: ErrorBarStrings;
    /** Strings for VideoGallery */
    videoGallery: VideoGalleryStrings;
}

/**
 * Locale for German (Germany)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_DE_DE: CompositeLocale;

/**
 * Locale for English (British)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_EN_GB: CompositeLocale;

/**
 * Locale for English (US)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_EN_US: CompositeLocale;

/**
 * Locale for Spanish (Spain)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_ES_ES: CompositeLocale;

/**
 * Locale for French (France)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_FR_FR: CompositeLocale;

/**
 * Locale for Italian (Italy)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_IT_IT: CompositeLocale;

/**
 * Locale for Japanese (Japan)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_JA_JP: CompositeLocale;

/**
 * Locale for Korean (South Korea)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_KO_KR: CompositeLocale;

/**
 * Locale for Dutch (Netherlands)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_NL_NL: CompositeLocale;

/**
 * Locale for Portuguese (Brazil)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_PT_BR: CompositeLocale;

/**
 * Locale for Russian (Russia)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_RU_RU: CompositeLocale;

/**
 * Locale for Turkish (Turkey)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_TR_TR: CompositeLocale;

/**
 * Locale for Chinese (Mainland China)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_ZH_CN: CompositeLocale;

/**
 * Locale for Chinese (Taiwan)
 *
 * @public
 */
export declare const COMPOSITE_LOCALE_ZH_TW: CompositeLocale;

/**
 * The default set of icons used by the composites directly (i.e. not via the components defined in this library).
 *
 * @public
 */
export declare const COMPOSITE_ONLY_ICONS: {
    LobbyScreenConnectingToCall: JSX.Element;
    LobbyScreenWaitingToBeAdmitted: JSX.Element;
    LocalDeviceSettingsCamera: JSX.Element;
    LocalDeviceSettingsMic: JSX.Element;
    LocalDeviceSettingsSpeaker: JSX.Element;
    LocalPreviewPlaceholder: JSX.Element;
    Muted: JSX.Element;
    NetworkReconnectIcon: JSX.Element;
    NoticePageAccessDeniedTeamsMeeting: JSX.Element;
    NoticePageJoinCallFailedDueToNoNetwork: JSX.Element;
    NoticePageLeftCall: JSX.Element;
    NoticePageRemovedFromCall: JSX.Element;
};

/**
 * Icons that can be overridden in one of the composites exported by this library.
 *
 * See {@link ChatCompositeIcons} and {@link CallCompositeIcons} for more targeted types.
 *
 * @public
 */
export declare type CompositeIcons = ComponentIcons & Record<keyof typeof COMPOSITE_ONLY_ICONS, JSX.Element>;

/**
 * Locale information for all composites exported from this library.
 *
 * @public
 */
export declare interface CompositeLocale {
    /** Strings used in composites directly
     *
     * Contrast with {@link CompositeLocale.component}, which contains strings used via the component library.
     */
    strings: CompositeStrings;
    /** Locale information for the pure Components used by Composites. See {@link communication-react#ComponentLocale}. */
    component: ComponentLocale;
}

/**
 * Strings used in the composites directly.
 *
 * These strings are used by the composites directly, instead of by the contained components.
 *
 * @public
 */
export declare interface CompositeStrings {
    /**
     * Strings used by {@link CallComposite}.
     */
    call: CallCompositeStrings;
    /**
     * Strings used by {@link ChatComposite}.
     */
    chat: ChatCompositeStrings;
}

/**
 * A system message with arbitary content.
 *
 * @public
 */
export declare interface ContentSystemMessage extends SystemMessageCommon {
    systemMessageType: 'content';
    content: string;
}

/**
 * A container for various buttons for call controls.
 *
 * Use with various call control buttons in this library, e.g., {@link CameraButton}, or your own instances of
 * {@link ControlBarButton} directly.
 *
 * @public
 */
export declare const ControlBar: (props: ControlBarProps) => JSX.Element;

/**
 * Default button styled for the {@link ControlBar}.
 *
 * Use this component create custom buttons that are styled the same as other buttons provided by the UI Library.
 *
 * @public
 */
export declare const ControlBarButton: (props: ControlBarButtonProps) => JSX.Element;

/**
 * Props for {@link ControlBarButton}.
 *
 * @public
 */
export declare interface ControlBarButtonProps extends IButtonProps {
    /**
     * Whether the label is displayed or not.
     *
     * @defaultValue `false`
     */
    showLabel?: boolean;
    /**
     * Key to use for the Label component
     */
    labelKey?: string;
    /**
     * Id to use for the tooltip host.
     *
     * @defaultValue This uses the labelKey and appends -tooltip by default
     */
    tooltipId?: string;
    /**
     * Optional strings to override in component.
     */
    strings?: ControlBarButtonStrings;
    /**
     * Icon to render when the button is checked.
     */
    onRenderOnIcon?: IRenderFunction<IButtonProps>;
    /**
     * Icon to render when the button is not checked.
     */
    onRenderOffIcon?: IRenderFunction<IButtonProps>;
    /**
     * Fluent styles, including extensions common to all {@link ControlBarButton}s.
     */
    styles?: ControlBarButtonStyles;
}

/**
 * Strings of {@link ControlBarButton} that can be overridden.
 *
 * @public
 */
export declare interface ControlBarButtonStrings {
    /**
     * Label of the button. This supersedes onLabel or offLabel if used.
     */
    label?: string;
    /**
     * Label of the button shown when the button is checked.
     */
    onLabel?: string;
    /**
     * Label of the button shown when the button is not checked.
     */
    offLabel?: string;
    /**
     * Tooltip content of the button. This supersedes tooltipDisabledContent, tooltipOnContent and tooltipOffContent if used.
     */
    tooltipContent?: string;
    /**
     * Tooltip content when the button is disabled.
     */
    tooltipDisabledContent?: string;
    /**
     * Tooltip content when the button is in the checked state.
     */
    tooltipOnContent?: string;
    /**
     * Tooltip content when the button is in the unchecked state.
     */
    tooltipOffContent?: string;
}

/**
 * Styles for all {@link ControlBarButton} implementations.
 *
 * @public
 */
export declare type ControlBarButtonStyles = IButtonStyles;

/**
 * Present layouts for the {@link ControlBar}.
 *
 * @public
 */
export declare type ControlBarLayout = 'horizontal' | 'vertical' | 'dockedTop' | 'dockedBottom' | 'dockedLeft' | 'dockedRight' | 'floatingTop' | 'floatingBottom' | 'floatingLeft' | 'floatingRight';

/**
 * Props for {@link ControlBar}.
 *
 * @public
 */
export declare interface ControlBarProps {
    /** React Child components. */
    children?: React_2.ReactNode;
    /**
     * Allows users to pass an object containing custom CSS styles.
     * @Example
     * ```
     * <ControlBar styles={{ root: { background: 'blue' } }} />
     * ```
     */
    styles?: BaseCustomStyles;
    /**
     * Changes the layout of the control bar.
     * Available layouts are `horizontal`, `vertical`, `dockedTop`, `dockedBottom`,
     * `dockedLeft`, `dockedRight`, `floatingTop`, `floatingBottom`, `floatingLeft`,
     * `floatingRight`
     * Defaults to a `horizontal` layout.
     */
    layout?: ControlBarLayout;
}

/**
 * Create a {@link CallAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link CallAdapter} provided by this library.
 *
 * Note: `displayName` can be a maximum of 256 characters.
 *
 * @public
 */
export declare const createAzureCommunicationCallAdapter: ({ userId, displayName, credential, locator }: AzureCommunicationCallAdapterArgs) => Promise<CallAdapter>;

/**
 * Create a {@link CallAdapter} using the provided {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulCallClient}.
 * Consider using {@link createAzureCommunicationCallAdapter} for a simpler API.
 *
 * @public
 */
export declare const createAzureCommunicationCallAdapterFromClient: (callClient: StatefulCallClient, callAgent: CallAgent, locator: TeamsMeetingLinkLocator | GroupCallLocator) => Promise<CallAdapter>;

/**
 * Create a {@link ChatAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link ChatAdapter} provided by this library.
 *
 * @public
 */
export declare const createAzureCommunicationChatAdapter: ({ endpoint: endpointUrl, userId, displayName, credential, threadId }: AzureCommunicationChatAdapterArgs) => Promise<ChatAdapter>;

/**
 * Create a {@link ChatAdapter} using the provided {@link StatefulChatClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulChatClient}.
 * Consider using {@link createAzureCommunicationChatAdapter} for a simpler API.
 *
 * @public
 */
export declare const createAzureCommunicationChatAdapterFromClient: (chatClient: StatefulChatClient, chatThreadClient: ChatThreadClient) => Promise<ChatAdapter>;

/**
 * Create the default implementation of {@link CallingHandlers}.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
export declare const createDefaultCallingHandlers: (callClient: StatefulCallClient, callAgent: CallAgent | undefined, deviceManager: StatefulDeviceManager | undefined, call: Call | undefined) => CallingHandlers;

/**
 * Create the default implementation of {@link ChatHandlers}.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * Returned object is memoized to avoid rerenders when used as props for React Components.
 *
 * @public
 */
export declare const createDefaultChatHandlers: (chatClient: StatefulChatClient, chatThreadClient: ChatThreadClient) => ChatHandlers;

/**
 * Creates a StatefulCallClient {@link StatefulCallClient} by proxying CallClient
 * {@link @azure/communication-calling#CallClient} with ProxyCallClient {@link ProxyCallClient} which then allows access
 * to state in a declarative way.
 *
 * It is important to use the {@link @azure/communication-calling#DeviceManager} and
 * {@link @azure/communication-calling#CallAgent} and {@link @azure/communication-calling#Call} (and etc.) that are
 * obtained from the StatefulCallClient in order for their state changes to be proxied properly.
 *
 * @param args - {@link StatefulCallClientArgs}
 * @param options - {@link StatefulCallClientOptions}
 *
 * @public
 */
export declare const createStatefulCallClient: (args: StatefulCallClientArgs, options?: StatefulCallClientOptions | undefined) => StatefulCallClient;

/**
 * Creates a stateful ChatClient {@link StatefulChatClient} by proxying ChatClient
 * {@link @azure/communication-chat#ChatClient} with ProxyChatClient {@link ProxyChatClient} which then allows access
 * to state in a declarative way.
 *
 * @public
 */
export declare const createStatefulChatClient: (args: StatefulChatClientArgs, options?: StatefulChatClientOptions | undefined) => StatefulChatClient;

/**
 * Options that can be injected into the `onRender` function for customizing an
 * Avatar (`Persona`) component.
 *
 * @public
 */
export declare type CustomAvatarOptions = {
    /** Persona coin size in pixels  */
    coinSize?: number;
    /** Only show Coin and Initials  */
    hidePersonaDetails?: boolean;
    /** Text color of initials inside the coin  */
    initialsTextColor?: string;
    /** Optional property to set the aria label of the video tile if there is no available stream. */
    noVideoAvailableAriaLabel?: string;
    /** User status  */
    presence?: PersonaPresence;
    /** Preset Persona Size number  */
    size?: PersonaSize;
    /** Custom style for the Avatar  */
    styles?: IStyleFunctionOrObject<IPersonaStyleProps, IPersonaStyles>;
    /** Display name to be used in Persona  */
    text?: string;
};

/**
 * A custom message type.
 *
 * Custom messages are not rendered by default, but applications can provide custom renderers for them.
 *
 * @public
 */
export declare interface CustomMessage extends MessageCommon {
    messageType: 'custom';
    content: string;
}

/**
 * Preset dark theme for components exported from this library.
 *
 * @public
 */
export declare const darkTheme: PartialTheme & CallingTheme;

/**
 * The default set of icons that are available to use in the UI components.
 *
 * @remark Icons used only in the composites are available in {@link DEFAULT_COMPOSITE_ICONS}.
 *
 * @public
 */
export declare const DEFAULT_COMPONENT_ICONS: {
    ControlButtonCameraOff: JSX.Element;
    ControlButtonCameraOn: JSX.Element;
    ControlButtonEndCall: JSX.Element;
    ControlButtonMicOff: JSX.Element;
    ControlButtonMicOn: JSX.Element;
    ControlButtonOptions: JSX.Element;
    ControlButtonParticipants: JSX.Element;
    ControlButtonScreenShareStart: JSX.Element;
    ControlButtonScreenShareStop: JSX.Element;
    EditBoxCancel: JSX.Element;
    EditBoxSubmit: JSX.Element;
    ErrorBarCallCameraAccessDenied: JSX.Element;
    ErrorBarCallCameraAlreadyInUse: JSX.Element;
    ErrorBarCallLocalVideoFreeze: JSX.Element;
    ErrorBarCallMacOsCameraAccessDenied: JSX.Element;
    ErrorBarCallMacOsMicrophoneAccessDenied: JSX.Element;
    ErrorBarCallMicrophoneAccessDenied: JSX.Element;
    ErrorBarCallMicrophoneMutedBySystem: JSX.Element;
    ErrorBarCallNetworkQualityLow: JSX.Element;
    ErrorBarCallNoMicrophoneFound: JSX.Element;
    ErrorBarCallNoSpeakerFound: JSX.Element;
    HorizontalGalleryLeftButton: JSX.Element;
    HorizontalGalleryRightButton: JSX.Element;
    MessageDelivered: JSX.Element;
    MessageEdit: JSX.Element;
    MessageFailed: JSX.Element;
    MessageRemove: JSX.Element;
    MessageSeen: JSX.Element;
    MessageSending: JSX.Element;
    OptionsCamera: JSX.Element;
    OptionsMic: JSX.Element;
    OptionsSpeaker: JSX.Element;
    ParticipantItemMicOff: JSX.Element;
    ParticipantItemOptions: JSX.Element;
    ParticipantItemOptionsHovered: JSX.Element;
    ParticipantItemScreenShareStart: JSX.Element;
    SendBoxSend: JSX.Element;
    SendBoxSendHovered: JSX.Element;
    VideoTileMicOff: JSX.Element;
};

/**
 * The default set of icons that are available to used in the Composites.
 *
 * @public
 */
export declare const DEFAULT_COMPOSITE_ICONS: {
    LobbyScreenConnectingToCall: JSX.Element;
    LobbyScreenWaitingToBeAdmitted: JSX.Element;
    LocalDeviceSettingsCamera: JSX.Element;
    LocalDeviceSettingsMic: JSX.Element;
    LocalDeviceSettingsSpeaker: JSX.Element;
    LocalPreviewPlaceholder: JSX.Element;
    Muted: JSX.Element;
    NetworkReconnectIcon: JSX.Element;
    NoticePageAccessDeniedTeamsMeeting: JSX.Element;
    NoticePageJoinCallFailedDueToNoNetwork: JSX.Element;
    NoticePageLeftCall: JSX.Element;
    NoticePageRemovedFromCall: JSX.Element;
    ControlButtonCameraOff: JSX.Element;
    ControlButtonCameraOn: JSX.Element;
    ControlButtonEndCall: JSX.Element;
    ControlButtonMicOff: JSX.Element;
    ControlButtonMicOn: JSX.Element;
    ControlButtonOptions: JSX.Element;
    ControlButtonParticipants: JSX.Element;
    ControlButtonScreenShareStart: JSX.Element;
    ControlButtonScreenShareStop: JSX.Element;
    EditBoxCancel: JSX.Element;
    EditBoxSubmit: JSX.Element;
    ErrorBarCallCameraAccessDenied: JSX.Element;
    ErrorBarCallCameraAlreadyInUse: JSX.Element;
    ErrorBarCallLocalVideoFreeze: JSX.Element;
    ErrorBarCallMacOsCameraAccessDenied: JSX.Element;
    ErrorBarCallMacOsMicrophoneAccessDenied: JSX.Element;
    ErrorBarCallMicrophoneAccessDenied: JSX.Element;
    ErrorBarCallMicrophoneMutedBySystem: JSX.Element;
    ErrorBarCallNetworkQualityLow: JSX.Element;
    ErrorBarCallNoMicrophoneFound: JSX.Element;
    ErrorBarCallNoSpeakerFound: JSX.Element;
    HorizontalGalleryLeftButton: JSX.Element;
    HorizontalGalleryRightButton: JSX.Element;
    MessageDelivered: JSX.Element;
    MessageEdit: JSX.Element;
    MessageFailed: JSX.Element;
    MessageRemove: JSX.Element;
    MessageSeen: JSX.Element;
    MessageSending: JSX.Element;
    OptionsCamera: JSX.Element;
    OptionsMic: JSX.Element;
    OptionsSpeaker: JSX.Element;
    ParticipantItemMicOff: JSX.Element;
    ParticipantItemOptions: JSX.Element;
    ParticipantItemOptionsHovered: JSX.Element;
    ParticipantItemScreenShareStart: JSX.Element;
    SendBoxSend: JSX.Element;
    SendBoxSendHovered: JSX.Element;
    VideoTileMicOff: JSX.Element;
};

/**
 * This type is meant to encapsulate all the state inside {@link @azure/communication-calling#DeviceManager}. For
 * optional parameters they may not be available until permission is granted by the user. The cameras, microphones,
 * speakers, and deviceAccess states will be empty until the corresponding
 * {@link @azure/communication-calling#DeviceManager}'s getCameras, getMicrophones, getSpeakers, and askDevicePermission
 * APIs are called and completed.
 *
 * @public
 */
export declare type DeviceManagerState = {
    /**
     * Proxy of {@link @azure/communication-calling#DeviceManager.isSpeakerSelectionAvailable}.
     */
    isSpeakerSelectionAvailable: boolean;
    /**
     * Proxy of {@link @azure/communication-calling#DeviceManager.selectedMicrophone}.
     */
    selectedMicrophone?: AudioDeviceInfo;
    /**
     * Proxy of {@link @azure/communication-calling#DeviceManager.selectedSpeaker}.
     */
    selectedSpeaker?: AudioDeviceInfo;
    /**
     * Stores the selected camera device info. This is added by the stateful layer and does not exist in the Calling SDK.
     * It is meant as a convenience to the developer. It must be explicitly set before it has any value and does not
     * persist across instances of the {@link StatefulCallClient}. The developer controls entirely what this value holds
     * at any time.
     */
    selectedCamera?: VideoDeviceInfo;
    /**
     * Stores any cameras data returned from {@link @azure/communication-calling#DeviceManager.getCameras}.
     */
    cameras: VideoDeviceInfo[];
    /**
     * Stores any microphones data returned from {@link @azure/communication-calling#DeviceManager.getMicrophones}.
     */
    microphones: AudioDeviceInfo[];
    /**
     * Stores any speakers data returned from {@link @azure/communication-calling#DeviceManager.getSpeakers}.
     */
    speakers: AudioDeviceInfo[];
    /**
     * Stores deviceAccess data returned from {@link @azure/communication-calling#DeviceManager.askDevicePermission}.
     */
    deviceAccess?: DeviceAccess;
    /**
     * Stores created views that are not associated with any CallState (when {@link StatefulCallClient.createView} is
     * called with undefined callId, undefined participantId, and defined LocalVideoStream).
     *
     * The values in this array are generated internally when {@link StatefulCallClient.createView} is called and are
     * considered immutable.
     */
    unparentedViews: LocalVideoStreamState[];
};

/**
 * A button to open a menu that controls device options.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
export declare const DevicesButton: (props: DevicesButtonProps) => JSX.Element;

/**
 * Styles for the {@link DevicesButton} menu.
 *
 * @public
 */
export declare interface DevicesButtonContextualMenuStyles extends IContextualMenuStyles {
    /**
     * Styles for the items inside the {@link DevicesButton} button menu.
     */
    menuItemStyles?: IContextualMenuItemStyles;
}

/**
 * Props for {@link DevicesButton}.
 *
 * @public
 */
export declare interface DevicesButtonProps extends ControlBarButtonProps {
    /**
     * Available microphones for selection
     */
    microphones?: OptionsDevice[];
    /**
     * Available speakers for selection
     */
    speakers?: OptionsDevice[];
    /**
     * Available cameras for selection
     */
    cameras?: OptionsDevice[];
    /**
     * Microphone that is shown as currently selected
     */
    selectedMicrophone?: OptionsDevice;
    /**
     * Speaker that is shown as currently selected
     */
    selectedSpeaker?: OptionsDevice;
    /**
     * Camera that is shown as currently selected
     */
    selectedCamera?: OptionsDevice;
    /**
     * Callback when a camera is selected
     */
    onSelectCamera?: (device: OptionsDevice) => Promise<void>;
    /**
     * Callback when a microphone is selected
     */
    onSelectMicrophone?: (device: OptionsDevice) => Promise<void>;
    /**
     * Speaker when a speaker is selected
     */
    onSelectSpeaker?: (device: OptionsDevice) => Promise<void>;
    /**
     * Optional strings to override in component
     */
    strings?: Partial<DevicesButtonStrings>;
    /**
     * Option to increase the touch targets of the button flyout menu items from 36px to 48px.
     * Recommended for mobile devices.
     */
    styles?: DevicesButtonStyles;
}

/**
 * Selector type for {@link DevicesButton} component.
 *
 * @public
 */
export declare type DevicesButtonSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    microphones: AudioDeviceInfo[];
    speakers: AudioDeviceInfo[];
    cameras: VideoDeviceInfo[];
    selectedMicrophone?: AudioDeviceInfo;
    selectedSpeaker?: AudioDeviceInfo;
    selectedCamera?: VideoDeviceInfo;
};

/**
 * Strings of {@link DevicesButton} that can be overridden.
 *
 * @public
 */
export declare interface DevicesButtonStrings {
    /**
     * Label of button
     */
    label: string;
    /**
     * Button tooltip content.
     */
    tooltipContent?: string;
    /**
     * Title of camera menu
     */
    cameraMenuTitle: string;
    /**
     * Title of microphone menu
     */
    microphoneMenuTitle: string;
    /**
     * Title of speaker menu
     */
    speakerMenuTitle: string;
    /**
     * Tooltip of camera menu
     */
    cameraMenuTooltip: string;
    /**
     * Tooltip of microphone menu
     */
    microphoneMenuTooltip: string;
    /**
     * Tooltip of speaker menu
     */
    speakerMenuTooltip: string;
}

/**
 * Styles for the Devices button menu items.
 *
 * @public
 */
export declare interface DevicesButtonStyles extends ControlBarButtonStyles {
    /**
     * Styles for the {@link DevicesButton} menu.
     */
    menuStyles?: Partial<DevicesButtonContextualMenuStyles>;
}

/**
 * Callback for {@link CallAdapterSubscribers} 'diagnosticChanged' event.
 *
 * @public
 */
export declare type DiagnosticChangedEventListner = (event: MediaDiagnosticChangedEvent | NetworkDiagnosticChangedEvent) => void;

/**
 * State only proxy for {@link @azure/communication-calling#DiagnosticsCallFeature}.
 *
 * @public
 */
export declare interface DiagnosticsCallFeatureState {
    /**
     * Stores diagnostics related to network conditions.
     */
    network: NetworkDiagnosticsState;
    /**
     * Stores diagnostics related to media quality.
     */
    media: MediaDiagnosticsState;
}

/**
 * Callback for {@link CallAdapterSubscribers} 'displayNameChanged' event.
 *
 * @public
 */
export declare type DisplayNameChangedListener = (event: {
    participantId: CommunicationIdentifierKind;
    displayName: string;
}) => void;

/**
 * Functionality for correctly disposing a Composite.
 *
 * @public
 */
export declare interface Disposable {
    /** Dispose of the Composite */
    dispose(): void;
}

/**
 * A type for trivial selectors that return no data.
 *
 * Used as a default return value if {@link usePropsFor} is called for a component that requires no data.
 *
 * @public
 */
export declare type EmptySelector = () => Record<string, never>;

/**
 * A button to end an ongoing call.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
export declare const EndCallButton: (props: EndCallButtonProps) => JSX.Element;

/**
 * Props for {@link EndCallButton}.
 *
 * @public
 */
export declare interface EndCallButtonProps extends ControlBarButtonProps {
    /**
     * Utility property for using this component with `communication react eventHandlers`.
     * Maps directly to the `onClick` property.
     */
    onHangUp?: () => Promise<void>;
    /**
     * Optional strings to override in component
     */
    strings?: EndCallButtonStrings;
}

/**
 * Strings of {@link EndCallButton} that can be overridden.
 *
 * @public
 */
export declare interface EndCallButtonStrings {
    /**
     * Label of button
     */
    label: string;
    /** Tooltip content. */
    tooltipContent?: string;
}

/**
 * A component to show error messages on the UI.
 * All strings that can be shown are accepted as the {@link ErrorBarProps.strings} so that they can be localized.
 * Active errors are selected by {@link ErrorBarProps.activeErrorMessages}.
 *
 * This component internally tracks dismissed by the user.
 *   * Errors that have an associated timestamp: The error is shown on the UI again if it occurs after being dismissed.
 *   * Errors that do not have a timestamp: The error is dismissed until it disappears from the props.
 *         If the error recurs, it is shown in the UI.
 *
 * Uses {@link @fluentui/react#MessageBar} UI element.
 *
 * @public
 */
export declare const ErrorBar: (props: ErrorBarProps) => JSX.Element;

/**
 * Props for {@link ErrorBar}.
 *
 * In addition to the following, {@link ErrorBar} forwards all
 * {@link @fluentui/react#IMessageBarProps} to the underlying {@link @fluentui/react#MessageBar}.
 *
 * @public
 */
export declare interface ErrorBarProps extends IMessageBarProps {
    /**
     * Strings shown on the UI on errors.
     */
    strings?: ErrorBarStrings;
    /**
     * Currently active errors.
     */
    activeErrorMessages: ActiveErrorMessage[];
}

/**
 * All strings that may be shown on the UI in the {@link ErrorBar}.
 *
 * @public
 */
export declare interface ErrorBarStrings {
    /**
     * Unable to reach Chat service.
     *
     * This can mean:
     *   - Incorrect Azure Communication Services endpoint was provided.
     *   - User's network connection is down.
     */
    unableToReachChatService: string;
    /**
     * User does not have access to the Chat service.
     * This usually means that either the Azure Communication Services endpiont or the token provided are incorrect.
     */
    accessDenied: string;
    /**
     * User is no longer on the thread.
     *
     * See also: {@link ErrorBarStrings.sendMessageNotInChatThread} for a more specific error.
     */
    userNotInChatThread: string;
    /**
     * Sending message failed because user is no longer on the thread.
     */
    sendMessageNotInChatThread: string;
    /**
     * A generic message when sending message fails.
     * Prefer more specific error strings when possible.
     */
    sendMessageGeneric: string;
    /**
     * A generic message when starting video fails.
     */
    startVideoGeneric: string;
    /**
     * A generic message when starting video fails.
     */
    stopVideoGeneric: string;
    /**
     * A generic message when muting microphone fails.
     */
    muteGeneric: string;
    /**
     * A generic message when unmuting microphone fails.
     */
    unmuteGeneric: string;
    /**
     * A generic message when starting screenshare fails.
     */
    startScreenShareGeneric: string;
    /**
     * A generic message when stopping screenshare fails.
     */
    stopScreenShareGeneric: string;
    /**
     * Message shown when poor network quality is detected during a call.
     */
    callNetworkQualityLow: string;
    /**
     * Message shown on failure to detect audio output devices.
     */
    callNoSpeakerFound: string;
    /**
     * Message shown on failure to detect audio input devices.
     */
    callNoMicrophoneFound: string;
    /**
     * Message shown when microphone can be enumerated but access is blocked by the system.
     */
    callMicrophoneAccessDenied: string;
    /**
     * Message shown when microphone is muted by the system (not by local or remote participants)
     */
    callMicrophoneMutedBySystem: string;
    /**
     * Mac OS specific message shown when microphone can be enumerated but access is
     * blocked by the system.
     */
    callMacOsMicrophoneAccessDenied: string;
    /**
     * Message shown when poor network causes local video stream to be frozen.
     */
    callLocalVideoFreeze: string;
    /**
     * Message shown when camera can be enumerated but access is blocked by the system.
     */
    callCameraAccessDenied: string;
    /**
     * Message shown when local video fails to start because camera is already in use by
     * another applciation.
     */
    callCameraAlreadyInUse: string;
    /**
     * Mac OS specific message shown when system denies access to camera.
     */
    callMacOsCameraAccessDenied: string;
    /**
     * Mac OS specific message shown when system denies sharing local screen on a call.
     */
    callMacOsScreenShareAccessDenied: string;
}

/**
 * All errors that can be shown in the {@link ErrorBar}.
 *
 * @public
 */
export declare type ErrorType = keyof ErrorBarStrings;

/**
 * Provider to apply a Fluent theme across this library's react components.
 *
 * @remarks Components in this library are composed primarily from [Fluent UI](https://developer.microsoft.com/fluentui#/controls/web),
 * controls, and also from [Fluent React Northstar](https://fluentsite.z22.web.core.windows.net/0.53.0) controls.
 * This provider handles applying any theme provided to both the underlying Fluent UI controls, as well as the Fluent React Northstar controls.
 *
 * @public
 */
export declare const FluentThemeProvider: (props: FluentThemeProviderProps) => JSX.Element;

/**
 * Props for {@link FluentThemeProvider}.
 *
 * @public
 */
export declare interface FluentThemeProviderProps {
    /** Children to be themed. */
    children: React_2.ReactNode;
    /** Theme for components. Defaults to a light theme if not provided. */
    fluentTheme?: PartialTheme | Theme;
    /**
     * Whether components are displayed right-to-left
     * @defaultValue `false`
     */
    rtl?: boolean;
}

/**
 * Reverse operation of {@link toFlatCommunicationIdentifier}.
 *
 * @public
 */
export declare const fromFlatCommunicationIdentifier: (id: string) => CommunicationIdentifier;

/**
 * Specific type of the selector applicable to a given Component.
 *
 * @public
 */
export declare type GetCallingSelector<Component extends (props: any) => JSX.Element | undefined> = AreEqual<Component, typeof VideoGallery> extends true ? VideoGallerySelector : AreEqual<Component, typeof DevicesButton> extends true ? DevicesButtonSelector : AreEqual<Component, typeof MicrophoneButton> extends true ? MicrophoneButtonSelector : AreEqual<Component, typeof CameraButton> extends true ? CameraButtonSelector : AreEqual<Component, typeof ScreenShareButton> extends true ? ScreenShareButtonSelector : AreEqual<Component, typeof ParticipantList> extends true ? ParticipantListSelector : AreEqual<Component, typeof ParticipantsButton> extends true ? ParticipantsButtonSelector : AreEqual<Component, typeof EndCallButton> extends true ? EmptySelector : AreEqual<Component, typeof ErrorBar> extends true ? CallErrorBarSelector : undefined;

/**
 * Get the selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
export declare const getCallingSelector: <Component extends (props: any) => JSX.Element | undefined>(component: Component) => GetCallingSelector<Component>;

/**
 * Specific type of the selector applicable to a given Component.
 *
 * @public
 */
export declare type GetChatSelector<Component extends (props: any) => JSX.Element | undefined> = AreEqual<Component, typeof SendBox> extends true ? SendBoxSelector : AreEqual<Component, typeof MessageThread> extends true ? MessageThreadSelector : AreEqual<Component, typeof TypingIndicator> extends true ? TypingIndicatorSelector : AreEqual<Component, typeof ParticipantList> extends true ? ChatParticipantListSelector : AreEqual<Component, typeof ErrorBar> extends true ? ChatErrorBarSelector : undefined;

/**
 * Get the selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
export declare const getChatSelector: <Component extends (props: any) => JSX.Element | undefined>(component: Component) => GetChatSelector<Component>;

/**
 * A component to lay out audio / video participants tiles in a call.
 *
 * @public
 */
export declare const GridLayout: (props: GridLayoutProps) => JSX.Element;

/**
 * Props for {@link GridLayout}.
 *
 * @public
 */
export declare interface GridLayoutProps {
    children: React_2.ReactNode;
    /**
     * Allows users to pass in an object contains custom CSS styles.
     * @Example
     * ```
     * <GridLayout styles={{ root: { background: 'blue' } }} />
     * ```
     */
    styles?: BaseCustomStyles;
}

/**
 * {@link GridLayout} Component Styles.
 * @public
 */
export declare interface GridLayoutStyles extends BaseCustomStyles {
    /** Styles for each child of {@link GridLayout} */
    children?: IStyle;
}

/**
 * {@link HorizontalGallery} Component Styles.
 * @public
 */
export declare interface HorizontalGalleryStyles extends BaseCustomStyles {
    /** Styles for each child of {@link HorizontalGallery} */
    children?: IStyle;
    /** Styles for navigation button to go to previous page */
    previousButton?: IStyle;
    /** Styles for navigation button to go to next page */
    nextButton?: IStyle;
}

/**
 * React Context provider for {@link _Identifiers}.
 *
 * @experimental
 *
 * See documentation for {@link _Identifiers}.
 *
 * @internal
 */
export declare const _IdentifierProvider: (props: _IdentifierProviderProps) => JSX.Element;

/**
 * Arguments to Context Provider for {@link _Identifiers}.
 *
 * @experimental
 *
 * See documentation for {@link _Identifiers}.
 *
 * @internal
 */
export declare interface _IdentifierProviderProps {
    identifiers?: _Identifiers;
    children: React_2.ReactNode;
}

/**
 * Identifiers that can be used to target specific components in a composite.
 *
 * @experimental
 *
 * These identifiers are assigned as `data-ui-id` HTML attribute of the root element of the targeted component.
 *
 * This API is intended for end to end test automation. As such, they are not covered by the API
 * guarantee of the public API. This will remain perenially experimental and compatibility breaking changes
 * may be made at any point.
 *
 * @internal
 */
export declare interface _Identifiers {
    /** `data-ui-id` value for `SendBox` Component */
    sendboxTextField: string;
    /** `data-ui-id` value for `ParticipantButton` Component's People menu item */
    participantButtonPeopleMenuItem: string;
    /** `data-ui-id` value for `ParticipantItem` Component's Menu button */
    participantItemMenuButton: string;
    /** `data-ui-id` value for `ParticipantList` Component */
    participantList: string;
    /** `data-ui-id` value for `ParticipantList` Component's People Button */
    participantListPeopleButton: string;
    /** `data-ui-id` value for `ParticipantList` Component's Remove Participant Button */
    participantListRemoveParticipantButton: string;
    /** `data-ui-id` value for `MessageThread` components message content */
    messageContent: string;
    /** `data-ui-id` value for `MessageThread` components message timestamp */
    messageTimestamp: string;
    /** `data-ui-id` value for `TypingIndicator` Component */
    typingIndicator: string;
    /** `data-ui-id` value for `VideoGallery` Component */
    videoGallery: string;
    /** `data-ui-id` value for `VideoTile` Component */
    videoTile: string;
}

/**
 * State only version of {@link @azure/communication-calling#IncomingCall}. {@link StatefulCallClient} will
 * automatically detect incoming calls and add their state to the state exposed by {@link StatefulCallClient}.
 *
 * @public
 */
export declare interface IncomingCallState {
    /**
     * Proxy of {@link @azure/communication-calling#IncomingCall.id}.
     */
    id: string;
    /**
     * Proxy of {@link @azure/communication-calling#IncomingCall.callerInfo}.
     */
    callerInfo: CallerInfo;
    /**
     * Set to the state returned by 'callEnded' event on {@link @azure/communication-calling#IncomingCall} when received.
     * This property is added by the stateful layer and is not a proxy of SDK state.
     */
    callEndReason?: CallEndReason;
    /**
     * Stores the local date when the call started on the client. This property is added by the stateful layer and is not
     * a proxy of SDK state.
     */
    startTime: Date;
    /**
     * Stores the local date when the call ended on the client. This property is added by the stateful layer and is not a
     * proxy of SDK state. It is undefined if the call is not ended yet.
     */
    endTime?: Date;
}

/**
 * Callback for {@link CallAdapterSubscribers} 'isLocalScreenSharingActiveChanged' event.
 *
 * @public
 */
export declare type IsLocalScreenSharingActiveChangedListener = (event: {
    isScreenSharingOn: boolean;
}) => void;

/**
 * Callback for {@link CallAdapterSubscribers} 'isMuted' event.
 *
 * @public
 */
export declare type IsMutedChangedListener = (event: {
    identifier: CommunicationIdentifierKind;
    isMuted: boolean;
}) => void;

/**
 * Callback for {@link CallAdapterSubscribers} 'isSpeakingChanged' event.
 *
 * @public
 */
export declare type IsSpeakingChangedListener = (event: {
    identifier: CommunicationIdentifierKind;
    isSpeaking: boolean;
}) => void;

/**
 * Arguments for {@link MessageThreadProps.onRenderJumpToNewMessageButton}.
 *
 * @public
 */
export declare interface JumpToNewMessageButtonProps {
    /** String for button text */
    text: string;
    /** Callback for when button is clicked */
    onClick: () => void;
}

/**
 * Preset light theme for components exported from this library.
 *
 * @public
 */
export declare const lightTheme: PartialTheme & CallingTheme;

/**
 * Provider to provide localized strings for this library's react components.
 *
 * @remarks Components will be provided localized strings in English (US) by default if this
 * provider is not used.
 *
 * @public
 */
export declare const LocalizationProvider: (props: LocalizationProviderProps) => JSX.Element;

/**
 * Props for {@link LocalizationProvider}.
 *
 * @public
 */
export declare type LocalizationProviderProps = {
    /** Locale context to provide components */
    locale: ComponentLocale;
    /** Children to provide locale context. */
    children: React_2.ReactNode;
};

/**
 * State only version of {@link @azure/communication-calling#LocalVideoStream}.
 *
 * @public
 */
export declare interface LocalVideoStreamState {
    /**
     * Proxy of {@link @azure/communication-calling#LocalVideoStream.source}.
     */
    source: VideoDeviceInfo;
    /**
     * Proxy of {@link @azure/communication-calling#LocalVideoStream.mediaStreamType}.
     */
    mediaStreamType: MediaStreamType;
    /**
     * {@link VideoStreamRendererView} that is managed by createView/disposeView in {@link StatefulCallClient}
     * API. This can be undefined if the stream has not yet been rendered and defined after createView creates the view.
     */
    view?: VideoStreamRendererViewState;
}

/**
 * Payload for {@link DiagnosticChangedEventListner} where there is a change in a media diagnostic.
 *
 * @public
 */
export declare type MediaDiagnosticChangedEvent = MediaDiagnosticChangedEventArgs & {
    type: 'media';
};

/**
 * State only proxy for {@link @azure/communication-calling#MediaDiagnostics}.
 *
 * @public
 */
export declare interface MediaDiagnosticsState {
    latest: LatestMediaDiagnostics;
}

/**
 * Discriminated union of all messages.
 *
 * The `messageType` field specializes into union variants.
 *
 * @public
 */
export declare type Message = ChatMessage | SystemMessage | CustomMessage;

/**
 * Indicate whether a chat message should be displayed merged with the message before / after it.
 *
 * Useful to merge many messages from the same sender into a single message bubble.
 *
 * @public
 */
export declare type MessageAttachedStatus = 'bottom' | 'top' | boolean;

/**
 * Common properties of all message types.
 *
 * @public
 */
export declare interface MessageCommon {
    messageId: string;
    createdOn: Date;
}

/**
 * Supported types of chat message content.
 *
 * @public
 */
export declare type MessageContentType = 'text' | 'html' | 'richtext/html' | 'unknown';

/**
 * Props to render a single message.
 *
 * See {@link MessageRenderer}.
 *
 * @public
 */
export declare type MessageProps = {
    /**
     * Message to render. It can type `ChatMessage` or `SystemMessage` or `CustomMessage`.
     */
    message: Message;
    /**
     * Strings from parent MessageThread component
     */
    strings: MessageThreadStrings;
    /**
     * Custom CSS styles for chat message container.
     */
    messageContainerStyle?: ComponentSlotStyle;
    /**
     * Whether the date of a message is displayed or not.
     *
     * @defaultValue `false`
     */
    showDate?: boolean;
    /**
     * Disable editing messages.
     *
     * @remarks This removes the action menu on messages.
     *
     * @defaultValue `false`
     */
    disableEditing?: boolean;
    /**
     * Optional callback to edit a message.
     *
     * @param messageId - message id from chatClient
     * @param content - new content of the message
     *
     */
    onUpdateMessage?: (messageId: string, content: string) => Promise<void>;
    /**
     * Optional callback to delete a message.
     *
     * @param messageId - message id from chatClient
     *
     */
    onDeleteMessage?: (messageId: string) => Promise<void>;
};

/**
 * Callback for {@link ChatAdapterSubscribers} 'messageRead' event.
 *
 * @public
 */
export declare type MessageReadListener = (event: {
    message: ChatMessage_2;
    readBy: CommunicationUserKind;
}) => void;

/**
 * Callback for {@link ChatAdapterSubscribers} 'messageReceived' event.
 *
 * @public
 */
export declare type MessageReceivedListener = (event: {
    message: ChatMessage_2;
}) => void;

/**
 * A component to render a single message.
 *
 * @public
 */
export declare type MessageRenderer = (props: MessageProps) => JSX.Element;

/**
 * Callback for {@link ChatAdapterSubscribers} 'messageSent' event.
 *
 * @public
 */
export declare type MessageSentListener = MessageReceivedListener;

/**
 * Client-side state of a sent message.
 *
 * Includes transitional states that occur before message delivery is confirmed from the backend.
 *
 * @public
 */
export declare type MessageStatus = 'delivered' | 'sending' | 'seen' | 'failed';

/**
 * Component to display the status of a sent message.
 *
 * Adds an icon and tooltip corresponding to the message status.
 *
 * @public
 */
export declare const MessageStatusIndicator: (props: MessageStatusIndicatorProps) => JSX.Element;

/**
 * Props for {@link MessageStatusIndicator}.
 *
 * @public
 */
export declare interface MessageStatusIndicatorProps {
    /** Message status that determines the icon to display. */
    status?: MessageStatus;
    /**
     * Allows users to pass an object containing custom CSS styles.
     * @Example
     * ```
     * <MessageStatus styles={{ root: { background: 'blue' } }} />
     * ```
     */
    styles?: BaseCustomStyles;
    /**
     * Optional strings to override in component
     */
    strings?: MessageStatusIndicatorStrings;
}

/**
 * Strings of {@link MessageStatusIndicator} that can be overridden.
 *
 * @public
 */
export declare interface MessageStatusIndicatorStrings {
    /** Text to display in the delivered message icon tooltip. */
    deliveredTooltipText: string;
    /** Text to display in the seen message icon tooltip. */
    seenTooltipText: string;
    /** Text to display in the sending message icon tooltip. */
    sendingTooltipText: string;
    /** Text to display in the failed message icon tooltip. */
    failedToSendTooltipText: string;
}

/**
 * `MessageThread` allows you to easily create a component for rendering chat messages, handling scrolling behavior of new/old messages and customizing icons & controls inside the chat thread.
 * @param props - of type MessageThreadProps
 *
 * Users will need to provide at least chat messages and userId to render the `MessageThread` component.
 * Users can also customize `MessageThread` by passing in their own Avatar, `MessageStatusIndicator` icon, `JumpToNewMessageButton`, `LoadPreviousMessagesButton` and the behavior of these controls.
 *
 * `MessageThread` internally uses the `Chat` & `Chat.Message` component from `@fluentui/react-northstar`. You can checkout the details about these [two components](https://fluentsite.z22.web.core.windows.net/0.53.0/components/chat/props).
 *
 * @public
 */
export declare const MessageThread: (props: MessageThreadProps) => JSX.Element;

/**
 * Props for {@link MessageThread}.
 *
 * @public
 */
export declare type MessageThreadProps = {
    /**
     * UserId of the current user.
     */
    userId: string;
    /**
     * Messages to render in message thread. A message can be of type `ChatMessage`, `SystemMessage` or `CustomMessage`.
     */
    messages: (ChatMessage | SystemMessage | CustomMessage)[];
    /**
     * Allows users to pass an object containing custom CSS styles.
     * @Example
     * ```
     * <MessageThread styles={{ root: { background: 'blue' } }} />
     * ```
     */
    styles?: MessageThreadStyles;
    /**
     * Whether the new message button is disabled or not.
     *
     * @defaultValue `false`
     */
    disableJumpToNewMessageButton?: boolean;
    /**
     * Whether the date of each message is displayed or not.
     *
     * @defaultValue `false`
     */
    showMessageDate?: boolean;
    /**
     * Whether the status indicator for each message is displayed or not.
     *
     * @defaultValue `false`
     */
    showMessageStatus?: boolean;
    /**
     * Number of chat messages to reload each time onLoadPreviousChatMessages is called.
     *
     * @defaultValue 0
     */
    numberOfChatMessagesToReload?: number;
    /**
     * Optional callback to override actions on message being seen.
     *
     * @param messageId - message Id
     */
    onMessageSeen?: (messageId: string) => Promise<void>;
    /**
     * Optional callback to override render of the message status indicator.
     *
     * @param messageStatusIndicatorProps - props of type MessageStatusIndicatorProps
     */
    onRenderMessageStatus?: (messageStatusIndicatorProps: MessageStatusIndicatorProps) => JSX.Element | null;
    /**
     * Optional callback to override render of the avatar.
     *
     * @param userId - user Id
     */
    onRenderAvatar?: OnRenderAvatarCallback;
    /**
     * Optional callback to override render of the button for jumping to the new message.
     *
     * @param newMessageButtonProps - button props of type JumpToNewMessageButtonProps
     */
    onRenderJumpToNewMessageButton?: (newMessageButtonProps: JumpToNewMessageButtonProps) => JSX.Element;
    /**
     * Optional callback to override loading of previous messages.
     * It accepts the number of history chat messages that we want to load and return a boolean Promise indicating if we have got all the history messages.
     * If the promise resolves to `true`, we have load all chat messages into the message thread and `loadPreviousMessagesButton` will not be rendered anymore.
     */
    onLoadPreviousChatMessages?: (messagesToLoad: number) => Promise<boolean>;
    /**
     * Optional callback to override render of a message.
     *
     * @param messageProps - props of type {@link communication-react#MessageProps}
     * @param defaultOnRender - default render of type {@link communication-react#MessageRenderer}
     *
     * @remarks
     * `messageRenderer` is not provided for `CustomMessage` and thus only available for `ChatMessage` and `SystemMessage`.
     */
    onRenderMessage?: (messageProps: MessageProps, messageRenderer?: MessageRenderer) => JSX.Element;
    /**
     * Optional callback to edit a message.
     *
     * @param messageId - message id from chatClient
     * @param content - new content of the message
     *
     */
    onUpdateMessage?: (messageId: string, content: string) => Promise<void>;
    /**
     * Optional callback to delete a message.
     *
     * @param messageId - message id from chatClient
     *
     */
    onDeleteMessage?: (messageId: string) => Promise<void>;
    /**
     /**
     * Disable editing messages.
     *
     * @remarks This removes the action menu on messages.
     *
     * @defaultValue `false`
     */
    disableEditing?: boolean;
    /**
     * Optional strings to override in component
     */
    strings?: Partial<MessageThreadStrings>;
};

/**
 * Selector type for {@link MessageThread} component.
 *
 * @public
 */
export declare type MessageThreadSelector = (state: ChatClientState, props: ChatBaseSelectorProps) => {
    userId: string;
    showMessageStatus: boolean;
    messages: Message[];
};

/**
 * Strings of {@link MessageThread} that can be overridden.
 *
 * @public
 */
export declare interface MessageThreadStrings {
    /** String for Sunday */
    sunday: string;
    /** String for Monday */
    monday: string;
    /** String for Tuesday */
    tuesday: string;
    /** String for Wednesday */
    wednesday: string;
    /** String for Thursday */
    thursday: string;
    /** String for Friday */
    friday: string;
    /** String for Saturday */
    saturday: string;
    /** String for Yesterday */
    yesterday: string;
    /** String for participants joined */
    participantJoined: string;
    /** String for participants left */
    participantLeft: string;
    /** Tag shown on a message that has been edited */
    editedTag: string;
    /** String for editing message in floating menu */
    editMessage: string;
    /** String for removing message in floating menu */
    removeMessage: string;
    /** String for LiveMessage introduction for the Chat Message */
    liveAuthorIntro: string;
    /** String for warning on text limit exceeded in EditBox*/
    editBoxTextLimit: string;
    /** String for placeholder text in EditBox when there is no user input*/
    editBoxPlaceholderText: string;
    /** String for new messages indicator*/
    newMessagesIndicator: string;
    /** String for replacing display name when there is none*/
    noDisplayNameSub: string;
    /** String for Cancel button in EditBox*/
    editBoxCancelButton: string;
    /** String for Submit in EditBox when there is no user input*/
    editBoxSubmitButton: string;
}

/**
 * Fluent styles for {@link MessageThread}.
 *
 * @public
 */
export declare interface MessageThreadStyles extends BaseCustomStyles {
    /** Styles for load previous messages container. */
    loadPreviousMessagesButtonContainer?: IStyle;
    /** Styles for new message container. */
    newMessageButtonContainer?: IStyle;
    /** Styles for chat container. */
    chatContainer?: ComponentSlotStyle;
    /** styles for my chat items.  */
    myChatItemMessageContainer?: ComponentSlotStyle;
    /** styles for chat items.  */
    chatItemMessageContainer?: ComponentSlotStyle;
    /** Styles for my chat message container. */
    myChatMessageContainer?: ComponentSlotStyle;
    /** Styles for chat message container. */
    chatMessageContainer?: ComponentSlotStyle;
    /** Styles for system message container. */
    systemMessageContainer?: ComponentSlotStyle;
    /** Styles for message status indicator container. */
    messageStatusContainer?: (mine: boolean) => IStyle;
}

/**
 * A button to turn microphone on / off.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
export declare const MicrophoneButton: (props: MicrophoneButtonProps) => JSX.Element;

/**
 * Props for {@link MicrophoneButton}.
 *
 * @public
 */
export declare interface MicrophoneButtonProps extends ControlBarButtonProps {
    /**
     * Utility property for using this component with `communication react eventHandlers`.
     * Maps directly to the `onClick` property.
     */
    onToggleMicrophone?: () => Promise<void>;
    /**
     * Optional strings to override in component
     */
    strings?: Partial<MicrophoneButtonStrings>;
}

/**
 * Selector type for {@link MicrophoneButton} component.
 *
 * @public
 */
export declare type MicrophoneButtonSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    disabled: boolean;
    checked: boolean;
};

/**
 * Strings of {@link MicrophoneButton} that can be overridden.
 *
 * @public
 */
export declare interface MicrophoneButtonStrings {
    /** Label when button is on. */
    onLabel: string;
    /** Label when button is off. */
    offLabel: string;
    /** * Tooltip content when the button is disabled. */
    tooltipDisabledContent?: string;
    /** Tooltip content when the button is on. */
    tooltipOnContent?: string;
    /** Tooltip content when the button is off. */
    tooltipOffContent?: string;
}

/**
 * Payload for {@link DiagnosticChangedEventListner} where there is a change in a network diagnostic.
 *
 * @public
 */
export declare type NetworkDiagnosticChangedEvent = NetworkDiagnosticChangedEventArgs & {
    type: 'network';
};

/**
 * State only proxy for {@link @azure/communication-calling#NetworkDiagnostics}.
 *
 * @public
 */
export declare interface NetworkDiagnosticsState {
    latest: LatestNetworkDiagnostics;
}

/**
 * A custom rendered callback that allows users to customize the rendering of a Persona Component.
 *
 * @public
 */
export declare type OnRenderAvatarCallback = (
/**
 * An Communication user ID.
 */
userId?: string, options?: CustomAvatarOptions, 
/**
 * A default `onRender` component that can be used to render the default avatar.
 * Pass the `options` to the `onRender` component for default rendering.
 */
defaultOnRender?: (props: CustomAvatarOptions) => JSX.Element) => JSX.Element;

/**
 * A device, e.g. camera, microphone, or speaker, in the {@link DevicesButton} flyout.
 *
 * @public
 */
export declare interface OptionsDevice {
    /**
     * Device unique identifier
     */
    id: string;
    /**
     * Device name
     */
    name: string;
}

/**
 * A system message notifying that a participant was added to the chat thread.
 *
 * @public
 */
export declare interface ParticipantAddedSystemMessage extends SystemMessageCommon {
    systemMessageType: 'participantAdded';
    participants: CommunicationParticipant[];
}

/**
 * Component to render a calling or chat participant.
 *
 * Displays the participant's avatar, displayName and status as well as optional icons and context menu.
 *
 * @public
 */
export declare const ParticipantItem: (props: ParticipantItemProps) => JSX.Element;

/**
 * Props for {@link ParticipantItem}.
 *
 * @public
 */
export declare interface ParticipantItemProps {
    /** Unique User ID of the participant. This `userId` is available in the `onRenderAvatar` callback function */
    userId?: string;
    /** Name of participant. */
    displayName: string;
    /** Optional indicator to show participant is the user. */
    me?: boolean;
    /** Optional callback returning a JSX element to override avatar. */
    onRenderAvatar?: OnRenderAvatarCallback;
    /** Optional array of IContextualMenuItem for contextual menu. */
    menuItems?: IContextualMenuItem[];
    /** Optional callback returning a JSX element rendered on the right portion of the ParticipantItem. Intended for adding icons. */
    onRenderIcon?: (props?: ParticipantItemProps) => JSX.Element | null;
    /** Optional PersonaPresence to show participant presence. This will not have an effect if property avatar is assigned. */
    presence?: PersonaPresence;
    /**
     * Allows users to pass in an object contains custom CSS styles.
     * @Example
     * ```
     * <ParticipantItem styles={{ root: { background: 'blue' } }} />
     * ```
     */
    styles?: ParticipantItemStyles;
    /**
     * Optional strings to override in component
     */
    strings?: Partial<ParticipantItemStrings>;
}

/**
 * Strings of {@link ParticipantItem} that can be overridden.
 *
 * @public
 */
export declare interface ParticipantItemStrings {
    /** String shown when participant is me */
    isMeText: string;
    /** String shown when hovering over menu button */
    menuTitle: string;
    /** Label for the remove button in participant menu  */
    removeButtonLabel: string;
    /** Label for the sharing icon in participant state stack  */
    sharingIconLabel: string;
    /** Label for the muted icon in participant state stack  */
    mutedIconLabel: string;
}

/**
 * Fluent styles for {@link ParticipantItem}.
 *
 * @public
 */
export declare interface ParticipantItemStyles extends BaseCustomStyles {
    /** Styles for the avatar. */
    avatar?: IStyle;
    /** Styles for the (You) string. */
    me?: IStyle;
    /** Styles for the container of the icon. */
    iconContainer?: IStyle;
    /** Styles for the menu. */
    menu?: IStyle;
}

/**
 * Component to render all calling or chat participants.
 *
 * By default, each participant is rendered with {@link ParticipantItem}. See {@link ParticipantListProps.onRenderParticipant} to override.
 *
 * @public
 */
export declare const ParticipantList: (props: ParticipantListProps) => JSX.Element;

/**
 * Styles for the {@link ParticipantList} {@link ParticipantItem}.
 *
 * @public
 */
export declare interface ParticipantListItemStyles extends ParticipantItemStyles {
    /** Styles applied to the sub-menu of the {@link ParticipantList} {@link ParticipantItem}. */
    participantSubMenuItemsStyles?: IContextualMenuItemStyles;
}

/**
 * Participants displayed in a {@link ParticipantList}.
 *
 * @public
 */
export declare type ParticipantListParticipant = CommunicationParticipant & {
    /**
     * If true, local participant can remove this participant from the roster.
     */
    isRemovable: boolean;
};

/**
 * Props for {@link ParticipantList}.
 *
 * @public
 */
export declare type ParticipantListProps = {
    /** Participants in user call or chat */
    participants: ParticipantListParticipant[];
    /** User ID of user */
    myUserId?: string;
    /**
     * If set to `true`, excludes the local participant from the participant list with use of `myUserId` props (required in this case).
     *
     * @defaultValue `false`
     */
    excludeMe?: boolean;
    /** Optional callback to render each participant. If no callback is provided, each participant will be rendered with `ParticipantItem`  */
    onRenderParticipant?: (participant: ParticipantListParticipant) => JSX.Element | null;
    /** Optional callback to render the avatar for each participant. This property will have no effect if `onRenderParticipant` is assigned.  */
    onRenderAvatar?: OnRenderAvatarCallback;
    /** Optional callback to render the context menu for each participant  */
    onRemoveParticipant?: (userId: string) => void;
    /** Optional callback to render custom menu items for each participant. */
    onFetchParticipantMenuItems?: ParticipantMenuItemsCallback;
    /** Styles for the {@link ParticipantList} */
    styles?: ParticipantListStyles;
};

/**
 * Selector type for {@link ParticipantList} component.
 *
 * @public
 */
export declare type ParticipantListSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    participants: CallParticipantListParticipant[];
    myUserId: string;
};

/**
 * Styles for the {@link ParticipantList}.
 *
 * @public
 */
export declare interface ParticipantListStyles extends BaseCustomStyles {
    /** Styles for the {@link ParticipantList} {@link ParticipantItem}. */
    participantItemStyles?: ParticipantListItemStyles;
}

/**
 * A callback for providing custom menu items for each participant in {@link ParticipantList}.
 *
 * @public
 */
export declare type ParticipantMenuItemsCallback = (participantUserId: string, userId?: string, defaultMenuItems?: IContextualMenuItem[]) => IContextualMenuItem[];

/**
 * A system message notifying that a participant was removed from the chat thread.
 *
 * @public
 */
export declare interface ParticipantRemovedSystemMessage extends SystemMessageCommon {
    systemMessageType: 'participantRemoved';
    participants: CommunicationParticipant[];
}

/**
 * Callback for {@link ChatAdapterSubscribers} 'participantsAdded' event.
 *
 * @public
 */
export declare type ParticipantsAddedListener = (event: {
    participantsAdded: ChatParticipant[];
    addedBy: ChatParticipant;
}) => void;

/**
 * A button to show a menu with calling or chat participants.
 *
 * Can be used with {@link ControlBar}.
 *
 * This button contains dropdown menu items defined through its property `menuProps`. By default, it can display the number of remote participants with the full list
 * as sub-menu and an option to mute all participants, as well as a copy-to-clipboard button to copy the call invitation URL.
 * This `menuProps` can be fully redefined and its property is of type [IContextualMenuProps](https://developer.microsoft.com/fluentui#/controls/web/contextualmenu#IContextualMenuProps).
 *
 * @public
 */
export declare const ParticipantsButton: (props: ParticipantsButtonProps) => JSX.Element;

/**
 * Styles for the {@link ParticipantsButton} menu.
 *
 * @public
 */
export declare interface ParticipantsButtonContextualMenuStyles extends IContextualMenuStyles {
    /** Styles for the {@link ParticipantsButton} menu items. */
    menuItemStyles?: IContextualMenuItemStyles;
    /** Styles for the {@link ParticipantList} menu item inside the {@link ParticipantsButton} menu. */
    participantListStyles?: ParticipantListStyles;
}

/**
 * Props for {@link ParticipantsButton}.
 *
 * @public
 */
export declare interface ParticipantsButtonProps extends ControlBarButtonProps {
    /**
     * Participants in user call or chat
     */
    participants: ParticipantListParticipant[];
    /**
     * User ID of user
     */
    myUserId?: string;
    /**
     * If set to `true`, excludes the local participant from the participant list with use of `myUserId` props (required in this case).
     *
     * @defaultValue `false`
     */
    excludeMe?: boolean;
    /**
     * Callback to render each participant. If no callback is provided, each participant will be rendered with `ParticipantItem`
     */
    onRenderParticipant?: (participant: CommunicationParticipant) => JSX.Element | null;
    /**
     * Callback to render the avatar for each participant. This property will have no effect if `onRenderParticipant` is assigned.
     */
    onRenderAvatar?: OnRenderAvatarCallback;
    /**
     * Callback to render the context menu for each participant
     */
    onRemoveParticipant?: (userId: string) => void;
    /**
     * Callback to render custom menu items for each participant.
     */
    onFetchParticipantMenuItems?: ParticipantMenuItemsCallback;
    /**
     * Optional callback to render a custom participant list.
     */
    onRenderParticipantList?: (props: ParticipantListProps) => JSX.Element | null;
    /**
     * Allows users to pass an object containing custom CSS styles.
     * @Example
     * ```
     * <ParticipantsButton styles={{ root: { background: 'blue' } }} />
     * ```
     */
    styles?: ParticipantsButtonStyles;
    /**
     * URL to invite new participants to the current call
     */
    callInvitationURL?: string;
    /**
     * CallBack to mute all remote participants
     */
    onMuteAll?: () => void;
    /**
     * Optional strings to override in component
     */
    strings?: Partial<ParticipantsButtonStrings>;
}

/**
 * Selector type for {@link ParticipantsButton} component.
 *
 * @public
 */
export declare type ParticipantsButtonSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    participants: CallParticipantListParticipant[];
    myUserId: string;
};

/**
 * Strings of {@link ParticipantsButton} that can be overridden.
 *
 * @public
 */
export declare interface ParticipantsButtonStrings {
    /**
     * Label of button
     */
    label: string;
    /**
     * Button tooltip content.
     */
    tooltipContent?: string;
    /**
     * Header of menu pop up
     */
    menuHeader: string;
    /**
     * Label of menu button to show list of participants. Placeholders: [numParticipants]
     */
    participantsListButtonLabel: string;
    /**
     * Label of menu button to copy invite link
     */
    copyInviteLinkButtonLabel: string;
    /**
     * Label of menu button to mute all participants
     */
    muteAllButtonLabel: string;
}

/**
 * Styles Props for {@link ParticipantsButton}.
 *
 * @public
 */
export declare interface ParticipantsButtonStyles extends ControlBarButtonStyles {
    /** Styles of the {@link ParticipantsButton} menu flyout */
    menuStyles?: Partial<ParticipantsButtonContextualMenuStyles>;
}

/**
 * Callback for {@link CallAdapterSubscribers} 'participantsJoined' event.
 *
 * @public
 */
export declare type ParticipantsJoinedListener = (event: {
    joined: RemoteParticipant[];
}) => void;

/**
 * Callback for {@link CallAdapterSubscribers} 'participantsLeft' event.
 *
 * @public
 */
export declare type ParticipantsLeftListener = (event: {
    removed: RemoteParticipant[];
}) => void;

/**
 * Callback for {@link ChatAdapterSubscribers} 'participantsRemoved' event.
 *
 * @public
 */
export declare type ParticipantsRemovedListener = (event: {
    participantsRemoved: ChatParticipant[];
    removedBy: ChatParticipant;
}) => void;

/**
 * State only version of {@link @azure/communication-calling#RecordingCallFeature}. {@link StatefulCallClient} will
 * automatically listen for recording state of the call and update the state exposed by {@link StatefulCallClient} accordingly.
 *
 * @public
 */
export declare interface RecordingCallFeature {
    /**
     * Proxy of {@link @azure/communication-calling#RecordingCallFeature.isRecordingActive}.
     */
    isRecordingActive: boolean;
}

/**
 * State only version of {@link @azure/communication-calling#RemoteParticipant}. {@link StatefulCallClient} will
 * automatically retrieve RemoteParticipants and add their state to the state exposed by {@link StatefulCallClient}.
 *
 * @public
 */
export declare interface RemoteParticipantState {
    /**
     * Proxy of {@link @azure/communication-calling#RemoteParticipant.identifier}.
     */
    identifier: CommunicationUserKind | PhoneNumberKind | MicrosoftTeamsUserKind | UnknownIdentifierKind;
    /**
     * Proxy of {@link @azure/communication-calling#RemoteParticipant.displayName}.
     */
    displayName?: string;
    /**
     * Proxy of {@link @azure/communication-calling#RemoteParticipant.state}.
     */
    state: RemoteParticipantState_2;
    /**
     * Proxy of {@link @azure/communication-calling#RemoteParticipant.callEndReason}.
     */
    callEndReason?: CallEndReason;
    /**
     * Proxy of {@link @azure/communication-calling#RemoteParticipant.videoStreams} as an object with
     * {@link RemoteVideoStream} fields keyed by {@link @azure/communication-calling#RemoteVideoStream.id}.
     */
    videoStreams: {
        [key: number]: RemoteVideoStreamState;
    };
    /**
     * Proxy of {@link @azure/communication-calling#RemoteParticipant.isMuted}.
     */
    isMuted: boolean;
    /**
     * Proxy of {@link @azure/communication-calling#RemoteParticipant.isSpeaking}.
     */
    isSpeaking: boolean;
}

/**
 * State only version of {@link @azure/communication-calling#RemoteVideoStream}.
 *
 * @public
 */
export declare interface RemoteVideoStreamState {
    /**
     * Proxy of {@link @azure/communication-calling#RemoteVideoStream.id}.
     */
    id: number;
    /**
     * Proxy of {@link @azure/communication-calling#RemoteVideoStream.mediaStreamType}.
     */
    mediaStreamType: MediaStreamType;
    /**
     * Proxy of {@link @azure/communication-calling#RemoteVideoStream.isAvailable}.
     */
    isAvailable: boolean;
    /**
     * {@link VideoStreamRendererView} that is managed by createView/disposeView in {@link StatefulCallClient}
     * API. This can be undefined if the stream has not yet been rendered and defined after createView creates the view.
     */
    view?: VideoStreamRendererViewState;
}

/**
 * A button to start / stop screen sharing.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
export declare const ScreenShareButton: (props: ScreenShareButtonProps) => JSX.Element;

/**
 * Props for {@link ScreenShareButton}.
 *
 * @public
 */
export declare interface ScreenShareButtonProps extends ControlBarButtonProps {
    /**
     * Utility property for using this component with `communication react eventHandlers`.
     * Maps directly to the `onClick` property.
     */
    onToggleScreenShare?: () => Promise<void>;
    /**
     * Optional strings to override in component
     */
    strings?: Partial<ScreenShareButtonStrings>;
}

/**
 * Selector type for {@link ScreenShareButton} component.
 *
 * @public
 */
export declare type ScreenShareButtonSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    checked?: boolean;
};

/**
 * Strings of {@link ScreenShareButton} that can be overridden.
 *
 * @public
 */
export declare interface ScreenShareButtonStrings {
    /** Label when button is on. */
    onLabel: string;
    /** Label when button is off. */
    offLabel: string;
    /** * Tooltip content when the button is disabled. */
    tooltipDisabledContent?: string;
    /** Tooltip content when the button is on. */
    tooltipOnContent?: string;
    /** Tooltip content when the button is off. */
    tooltipOffContent?: string;
}

/**
 * An optimized selector that refines {@link ClientState} updates into props for React Components in this library.
 *
 * @public
 */
export declare type Selector = (state: ClientState, props: any) => any;

/**
 * Component for typing and sending messages.
 *
 * Supports sending typing notification when user starts entering text.
 * Supports an optional message below the text input field.
 *
 * @public
 */
export declare const SendBox: (props: SendBoxProps) => JSX.Element;

/**
 * Props for {@link SendBox}.
 *
 * @public
 */
export declare interface SendBoxProps {
    /**
     * Optional boolean to disable text box
     * @defaultValue false
     */
    disabled?: boolean;
    /**
     * Optional text for system message below text box
     */
    systemMessage?: string;
    /**
     * Optional callback called when message is sent
     */
    onSendMessage?: (content: string) => Promise<void>;
    /**
     * Optional callback called when user is typing
     */
    onTyping?: () => Promise<void>;
    /**
     * Optional callback to render system message below the SendBox.
     * @defaultValue MessageBar
     */
    onRenderSystemMessage?: (systemMessage: string | undefined) => React_2.ReactElement;
    /**
     * Optional boolean to support new line in SendBox.
     * @defaultValue false
     */
    supportNewline?: boolean;
    /**
     * Optional callback to render send button icon to the right of the SendBox.
     * @defaultValue SendBoxSendHovered icon when mouse over icon and SendBoxSend icon otherwise
     */
    onRenderIcon?: (isHover: boolean) => JSX.Element;
    /**
     * Allows users to pass in an object contains custom CSS styles.
     * @Example
     * ```
     * <SendBox styles={{ root: { background: 'blue' } }} />
     * ```
     */
    styles?: SendBoxStylesProps;
    /**
     * Optional strings to override in component
     */
    strings?: Partial<SendBoxStrings>;
}

/**
 * Selector type for {@link SendBox} component.
 *
 * @public
 */
export declare type SendBoxSelector = (state: ChatClientState, props: ChatBaseSelectorProps) => {
    displayName: string;
    userId: string;
};

/**
 * Strings of {@link SendBox} that can be overridden.
 *
 * @public
 */
export declare interface SendBoxStrings {
    /**
     * Placeholder text in SendBox when there is no user input
     */
    placeholderText: string;
    /**
     * The warning message when send box text length is more than max limit
     */
    textTooLong: string;
}

/**
 * Fluent styles for {@link Sendbox}.
 *
 * @public
 */
export declare interface SendBoxStylesProps extends BaseCustomStyles {
    /** Styles for the text field. */
    textField?: IStyle;
    /** styles for the text field container */
    textFieldContainer?: IStyle;
    /** Styles for the container of the send message icon. */
    sendMessageIconContainer?: IStyle;
    /** Styles for the send message icon; These styles will be ignored when a custom send message icon is provided. */
    sendMessageIcon?: IStyle;
    /** Styles for the system message; These styles will be ignored when a custom system message component is provided. */
    systemMessage?: IStyle;
}

/**
 * Defines the methods that allow CallClient {@link @azure/communication-calling#CallClient} to be used statefully.
 * The interface provides access to proxied state and also allows registering a handler for state change events. For
 * state definition see {@link CallClientState}.
 *
 * State change events are driven by:
 * - Returned data from {@link @azure/communication-calling#DeviceManager} APIs.
 * - Returned data from {@link @azure/communication-calling#CallAgent} APIs.
 * - Listeners automatically attached to various azure communication-calling objects:
 *   - CallAgent 'incomingCall'
 *   - CallAgent 'callsUpdated'
 *   - DeviceManager 'videoDevicesUpdated'
 *   - DeviceManager 'audioDevicesUpdated
 *   - DeviceManager 'selectedMicrophoneChanged'
 *   - DeviceManager 'selectedSpeakerChanged'
 *   - Call 'stateChanged'
 *   - Call 'idChanged'
 *   - Call 'isMutedChanged'
 *   - Call 'isScreenSharingOnChanged'
 *   - Call 'remoteParticipantsUpdated'
 *   - Call 'localVideoStreamsUpdated'
 *   - IncomingCall 'callEnded'
 *   - RemoteParticipant 'stateChanged'
 *   - RemoteParticipant 'isMutedChanged'
 *   - RemoteParticipant 'displayNameChanged'
 *   - RemoteParticipant 'isSpeakingChanged'
 *   - RemoteParticipant 'videoStreamsUpdated'
 *   - RemoteVideoStream 'isAvailableChanged'
 *   - TranscriptionCallFeature 'isTranscriptionActiveChanged'
 *   - RecordingCallFeature 'isRecordingActiveChanged'
 *
 * @public
 */
export declare interface StatefulCallClient extends CallClient {
    /**
     * Holds all the state that we could proxy from CallClient {@link @azure/communication-calling#CallClient} as
     * CallClientState {@link CallClientState}.
     */
    getState(): CallClientState;
    /**
     * Allows a handler to be registered for 'stateChanged' events.
     *
     * @param handler - Callback to receive the state.
     */
    onStateChange(handler: (state: CallClientState) => void): void;
    /**
     * Allows unregistering for 'stateChanged' events.
     *
     * @param handler - Original callback to be unsubscribed.
     */
    offStateChange(handler: (state: CallClientState) => void): void;
    /**
     * Renders a {@link RemoteVideoStreamState} or {@link LocalVideoStreamState} and stores the resulting
     * {@link VideoStreamRendererViewState} under the relevant {@link RemoteVideoStreamState} or
     * {@link LocalVideoStreamState} or as unparented view in the state. Under the hood calls
     * {@link @azure/communication-calling#VideoStreamRenderer.createView}.
     *
     * Scenario 1: Render RemoteVideoStreamState
     * - CallId is required, participantId is required, and stream of type RemoteVideoStreamState is required
     * - Resulting {@link VideoStreamRendererViewState} is stored in the given callId and participantId in
     * {@link CallClientState}
     *
     * Scenario 2: Render LocalVideoStreamState for a call
     * - CallId is required, participantId must be undefined, and stream of type LocalVideoStreamState is required.
     * - The {@link @azure/communication-calling#Call.localVideoStreams} must already be started using
     *   {@link @azure/communication-calling#Call.startVideo}.
     * - Resulting {@link VideoStreamRendererViewState} is stored in the given callId {@link CallState.localVideoStreams}
     *   in {@link CallClientState}.
     *
     * - Scenario 2: Render LocalVideoStreamState not part of a call (example rendering camera for local preview)
     * - CallId must be undefined, participantId must be undefined, and stream of type LocalVideoStreamState is required.
     * - Resulting {@link VideoStreamRendererViewState} is stored in under the given LocalVideoStreamState in
     *   {@link CallClientState.deviceManager.unparentedViews}
     *
     * @param callId - CallId for the given stream. Can be undefined if the stream is not part of any call.
     * @param participantId - {@link RemoteParticipant.identifier} associated with the given RemoteVideoStreamState. Could
     *   be undefined if rendering LocalVideoStreamState.
     * @param stream - The LocalVideoStreamState or RemoteVideoStreamState to start rendering.
     * @param options - Options that are passed to the {@link @azure/communication-calling#VideoStreamRenderer}.
     */
    createView(callId: string | undefined, participantId: CommunicationIdentifier | undefined, stream: LocalVideoStreamState | RemoteVideoStreamState, options?: CreateViewOptions): Promise<void>;
    /**
     * Stops rendering a {@link RemoteVideoStreamState} or {@link LocalVideoStreamState} and removes the
     * {@link VideoStreamRendererView} from the relevant {@link RemoteVideoStreamState} in {@link CallClientState} or
     * {@link LocalVideoStream} in {@link CallClientState} or appropriate
     * {@link CallClientState.deviceManager.unparentedViews} Under the hood calls
     * {@link @azure/communication-calling#VideoStreamRenderer.dispose}.
     *
     * Its important to disposeView to clean up resources properly.
     *
     * Scenario 1: Dispose RemoteVideoStreamState
     * - CallId is required, participantId is required, and stream of type RemoteVideoStreamState is required
     *
     * Scenario 2: Dispose LocalVideoStreamState for a call
     * - CallId is required, participantId must be undefined, and stream of type LocalVideoStreamState is required.
     *
     * - Scenario 2: Dispose LocalVideoStreamState not part of a call
     * - CallId must be undefined, participantId must be undefined, and stream of type LocalVideoStreamState is required.
     * - LocalVideoStreamState must be the original one passed to createView.
     *
     * @param callId - CallId for the given stream. Can be undefined if the stream is not part of any call.
     * @param participantId - {@link RemoteParticipant.identifier} associated with the given RemoteVideoStreamState. Could
     *   be undefined if disposing LocalVideoStreamState.
     * @param stream - The LocalVideoStreamState or RemoteVideoStreamState to dispose.
     */
    disposeView(callId: string | undefined, participantId: CommunicationIdentifier | undefined, stream: LocalVideoStreamState | RemoteVideoStreamState): void;
}

/**
 * Arguments to construct the StatefulCallClient.
 *
 * @public
 */
export declare type StatefulCallClientArgs = {
    /**
     * UserId from SDK. This is provided for developer convenience to easily access the userId from the
     * state. It is not used by StatefulCallClient.
     */
    userId: CommunicationUserIdentifier;
};

/**
 * Options to construct the StatefulCallClient with.
 *
 * @public
 */
export declare type StatefulCallClientOptions = {
    /**
     * Options to construct the {@link @axure/communication-calling#CallClient} with.
     */
    callClientOptions: CallClientOptions;
    /**
     * Sets the max listeners limit of the 'stateChange' event. Defaults to the node.js EventEmitter.defaultMaxListeners
     * if not specified.
     */
    maxStateChangeListeners?: number;
};

/**
 * Defines the methods that allow {@Link @azure/communication-chat#ChatClient} to be used with a centralized generated state.
 *
 * The interface provides access to proxied state and also allows registering a handler for state change events.
 *
 * @public
 */
export declare interface StatefulChatClient extends ChatClient {
    /**
     * Holds all the state that we could proxy from ChatClient {@Link @azure/communication-chat#ChatClient} as
     * ChatClientState {@Link ChatClientState}.
     */
    getState(): ChatClientState;
    /**
     * Allows a handler to be registered for 'stateChanged' events.
     *
     * @param handler - Callback to receive the state.
     */
    onStateChange(handler: (state: ChatClientState) => void): void;
    /**
     * Allows unregistering for 'stateChanged' events.
     *
     * @param handler - Original callback to be unsubscribed.
     */
    offStateChange(handler: (state: ChatClientState) => void): void;
}

/**
 * Arguments to construct the {@link StatefulChatClient}.
 *
 * @public
 */
export declare type StatefulChatClientArgs = {
    userId: CommunicationUserIdentifier;
    displayName: string;
    endpoint: string;
    credential: CommunicationTokenCredential;
};

/**
 * Options to construct the {@link StatefulChatClient}.
 *
 * @public
 */
export declare type StatefulChatClientOptions = {
    /**
     * Options to construct the {@link @azure/communication-chat#ChatClient} with.
     */
    chatClientOptions: ChatClientOptions;
    /**
     * Sets the max listeners limit of the 'stateChange' event. Defaults to the node.js EventEmitter.defaultMaxListeners
     * if not specified.
     */
    maxStateChangeListeners?: number;
};

/**
 * Defines the additional methods added by the stateful on top of {@link @azure/communication-calling#DeviceManager}.
 *
 * @public
 */
export declare interface StatefulDeviceManager extends DeviceManager {
    /**
     * Sets the selectedCamera in the {@link DeviceManagerState}. This is completely developer driven and is not tied in
     * any way to {@link @azure/communication-calling#DeviceManager}. It is entirely contained in
     * {@link StatefulDeviceManager}. See also {@link DeviceManagerState.selectedCamera}.
     */
    selectCamera: (VideoDeviceInfo: any) => void;
}

/**
 * Utility component to convert an HTMLElement with a video stream into a JSX element.
 *
 * Use to convert an HTMLElement returned by headless calling API into a component that can be rendered as a {@link VideoTile}.
 *
 * @public
 */
export declare const StreamMedia: (props: StreamMediaProps) => JSX.Element;

/**
 * Props for {@link StreamMedia}.
 *
 * @public
 */
export declare interface StreamMediaProps {
    /** Video stream element to render. */
    videoStreamElement: HTMLElement | null;
    /** Decides whether to mirror the video or not. */
    isMirrored?: boolean;
    /**
     * Allows users to pass in an object contains custom CSS styles.
     * @Example
     * ```
     * <StreamMedia styles={{ root: { background: 'blue' } }} />
     * ```
     */
    styles?: BaseCustomStyles;
}

/**
 * Discriminated union of all system messages.
 *
 * The `systemMessageType` field specializes into union variants.
 *
 * @public
 */
export declare type SystemMessage = ParticipantAddedSystemMessage | ParticipantRemovedSystemMessage | TopicUpdatedSystemMessage | ContentSystemMessage;

/**
 * Common properties of all system messages.
 *
 * @public
 */
export declare interface SystemMessageCommon extends MessageCommon {
    messageType: 'system';
    iconName: string;
}

/**
 * A string representation of a {@link @azure/communication-common#CommunicationIdentifier}.
 *
 * This string representation of CommunicationIdentifier is guaranteed to be stable for
 * a unique Communication user. Thus,
 * - it can be used to persist a user's identity in external databases.
 * - it can be used as keys into a Map to store data for the user.
 *
 * @public
 */
export declare const toFlatCommunicationIdentifier: (identifier: CommunicationIdentifier) => string;

/**
 * Callback for {@link ChatAdapterSubscribers} 'topicChanged' event.
 *
 * @public
 */
export declare type TopicChangedListener = (event: {
    topic: string;
}) => void;

/**
 * A system message notifying that the chat thread topic was updated.
 *
 * @public
 */
export declare interface TopicUpdatedSystemMessage extends SystemMessageCommon {
    systemMessageType: 'topicUpdated';
    topic: string;
}

/**
 * State only version of {@link @azure/communication-calling#TranscriptionCallFeature}. {@link StatefulCallClient} will
 * automatically listen for transcription state of the call and update the state exposed by {@link StatefulCallClient}
 * accordingly.
 *
 * @public
 */
export declare interface TranscriptionCallFeature {
    /**
     * Proxy of {@link @azure/communication-calling#TranscriptionCallFeature.isTranscriptionActive}.
     */
    isTranscriptionActive: boolean;
}

/**
 * Component to notify local user when one or more participants in the chat thread are typing.
 *
 * @public
 */
export declare const TypingIndicator: (props: TypingIndicatorProps) => JSX.Element;

/**
 * Props for {@link TypingIndicator}.
 *
 * @public
 */
export declare interface TypingIndicatorProps {
    /** List of the typing users. */
    typingUsers: CommunicationParticipant[];
    /** Callback to render typing users */
    onRenderUser?: (users: CommunicationParticipant) => JSX.Element;
    /**
     * Allows users to pass in an object contains custom CSS styles.
     * @Example
     * ```
     * <TypingIndicator styles={{ root: { background: 'blue' } }} />
     * ```
     */
    styles?: TypingIndicatorStylesProps;
    /**
     * Optional strings to override in component
     */
    strings?: Partial<TypingIndicatorStrings>;
}

/**
 * Selector type for {@link TypingIndicator} component.
 *
 * @public
 */
export declare type TypingIndicatorSelector = (state: ChatClientState, props: ChatBaseSelectorProps) => {
    typingUsers: CommunicationParticipant[];
};

/**
 * Strings of {@link TypingIndicator} that can be overridden.
 *
 * @public
 */
export declare interface TypingIndicatorStrings {
    /**
     * String template to use when one user is typing. Placeholders: [user].
     * @example
     * ```
     * <TypingIndicator
     *  strings={{ multipleUsersAbbreviateOne: '{users} is typing...' }}
     *  typingUsers={[{ userId: 'user1', displayName: 'Claire' }]}
     * />
     * ```
     * would be 'Claire is typing...'
     **/
    singleUser: string;
    /**
     * String template to use when multiple users are typing. Placeholders: [users].
     * @example
     * ```
     * <TypingIndicator
     *  strings={{ multipleUsers: '{users} are typing...' }}
     *  typingUsers={[
     *    { userId: 'user1', displayName: 'Claire' },
     *    { userId: 'user2', displayName: 'Chris' }
     *  ]}
     * />
     * ```
     * would be 'Claire, Chris are typing...'
     **/
    multipleUsers: string;
    /**
     * String template to use when multiple users are typing with one other user abbreviated. Placeholders: [users].
     * @example
     * ```typescript
     * <TypingIndicator
     * strings={{ multipleUsersAbbreviateOne: '{users} and 1 other are typing...' }}
     * typingUsers={[
     * { userId: 'user1', displayName: 'Claire Romanov' },
     * { userId: 'user2', displayName: 'Chris Rutherford' }
     * ]}
     * />
     * ```
     * would be 'Claire Romanov and 1 other are typing...'
     **/
    multipleUsersAbbreviateOne: string;
    /**
     * String template to use when multiple users are typing with one other user abbreviated. Placeholders: [users, numOthers].
     * @example
     * ```
     * <TypingIndicator
     *  strings={{ multipleUsersAbbreviateMany: '{users} and {numOthers} others are typing...' }}
     *  typingUsers={[
     *    { userId: 'user1', displayName: 'Claire Romanov' },
     *    { userId: 'user2', displayName: 'Chris Rutherford' },
     *    { userId: 'user3', displayName: 'Jill Vernblom' }
     *  ]}
     * />
     * ```
     * would be 'Claire Romanov and 2 others are typing...'
     **/
    multipleUsersAbbreviateMany: string;
    /**
     * String to use as delimiter to separate multiple users.
     * @example
     * ```
     * <TypingIndicator
     *  strings={{ delimiter: ' + ' }}
     *  typingUsers={[
     *    { userId: 'user1', displayName: 'Claire' },
     *    { userId: 'user2', displayName: 'Chris' },
     *    { userId: 'user3', displayName: 'Jill' }
     *  ]}
     * />
     * ```
     * would be 'Claire + Chris + Jill are typing...'
     **/
    delimiter: string;
}

/**
 * Fluent styles for {@link TypingIndicator}.
 *
 * @public
 */
export declare interface TypingIndicatorStylesProps extends BaseCustomStyles {
    /** Styles for each typing user's displayName. */
    typingUserDisplayName?: IStyle;
    /** Styles for the typing string. */
    typingString?: IStyle;
}

/**
 * Hook to obtain {@link @azure/communication-calling#Call} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
export declare const useCall: () => Call | undefined;

/**
 * Hook to obtain {@link @azure/communication-calling#CallAgent} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
export declare const useCallAgent: () => CallAgent | undefined;

/**
 * Hook to obtain {@link StatefulCallClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
export declare const useCallClient: () => StatefulCallClient;

/**
 * Hook to obtain {@link StatefulChatClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
export declare const useChatClient: () => StatefulChatClient;

/**
 * Hook to obtain {@link @azure/communication-chat#ChatThreadClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
export declare const useChatThreadClient: () => ChatThreadClient;

/**
 * Hook to obtain {@link StatefulDeviceManager} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
export declare const useDeviceManager: () => StatefulDeviceManager | undefined;

/**
 * Primary hook to get all hooks necessary for a React Component from this library..
 *
 * Most straightforward usage of a components looks like:
 *
 * @example
 * ```
 *     import { ParticipantList, usePropsFor } from '@azure/communication-react';
 *
 *     const App = (): JSX.Element => {
 *         // ... code to setup Providers ...
 *
 *         return <ParticipantList {...usePropsFor(ParticipantList)}/>
 *     }
 * ```
 *
 * @public
 */
export declare const usePropsFor: <Component extends (props: any) => JSX.Element>(component: Component, type?: "chat" | "calling" | undefined) => ComponentProps<Component>;

/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
export declare const useSelector: <ParamT extends Selector | undefined>(selector: ParamT, selectorProps?: (ParamT extends Selector ? Parameters<ParamT>[1] : undefined) | undefined, type?: "chat" | "calling" | undefined) => ParamT extends Selector ? ReturnType<ParamT> : undefined;

/**
 * React hook to access theme
 *
 * @public
 */
export declare const useTheme: () => Theme;

/**
 * VideoGallery represents a layout of video tiles for a specific call.
 * It displays a {@link VideoTile} for the local user as well as for each remote participant who has joined the call.
 *
 * @public
 */
export declare const VideoGallery: (props: VideoGalleryProps) => JSX.Element;

/**
 * The state of the local participant in the {@link VideoGallery}.
 *
 * @public
 */
export declare type VideoGalleryLocalParticipant = VideoGalleryParticipant;

/**
 * The state of a participant in the {@link VideoGallery}.
 *
 * @public
 */
export declare type VideoGalleryParticipant = {
    /** User ID of participant */
    userId: string;
    /** Whether participant is muted */
    isMuted?: boolean;
    /** Display name of participant */
    displayName?: string;
    /** Video stream of participant */
    videoStream?: VideoGalleryStream;
    /** Whether participant is screen sharing or not */
    isScreenSharingOn?: boolean;
};

/**
 * Props for {@link VideoGallery}.
 *
 * @public
 */
export declare interface VideoGalleryProps {
    /**
     * Allows users to pass an object containing custom CSS styles for the gallery container.
     *
     * @Example
     * ```
     * <VideoGallery styles={{ root: { border: 'solid 1px red' } }} />
     * ```
     */
    styles?: VideoGalleryStyles;
    /** Layout of the video tiles. */
    layout?: 'default' | 'floatingLocalVideo';
    /** Local video particpant */
    localParticipant: VideoGalleryLocalParticipant;
    /** List of remote video particpants */
    remoteParticipants?: VideoGalleryRemoteParticipant[];
    /** List of dominant speaker userIds in the order of their dominance. 0th index is the most dominant. */
    dominantSpeakers?: string[];
    /** Local video view options */
    localVideoViewOptions?: VideoStreamOptions;
    /** Remote videos view options */
    remoteVideoViewOptions?: VideoStreamOptions;
    /** Callback to create the local video stream view */
    onCreateLocalStreamView?: (options?: VideoStreamOptions) => Promise<void>;
    /** Callback to dispose of the local video stream view */
    onDisposeLocalStreamView?: () => void;
    /** Callback to render the local video tile*/
    onRenderLocalVideoTile?: (localParticipant: VideoGalleryLocalParticipant) => JSX.Element;
    /** Callback to create a remote video stream view */
    onCreateRemoteStreamView?: (userId: string, options?: VideoStreamOptions) => Promise<void>;
    /** Callback to render a remote video tile */
    onRenderRemoteVideoTile?: (remoteParticipant: VideoGalleryRemoteParticipant) => JSX.Element;
    /** Callback to dispose a remote video stream view */
    onDisposeRemoteStreamView?: (userId: string) => Promise<void>;
    /** Callback to render a particpant avatar */
    onRenderAvatar?: OnRenderAvatarCallback;
    /**
     * Whether to display a mute icon beside the user's display name.
     * @defaultValue `true`
     */
    showMuteIndicator?: boolean;
    /** Optional strings to override in component  */
    strings?: Partial<VideoGalleryStrings>;
    /**
     * Maximum number of participant remote video streams that is rendered.
     * @defaultValue 4
     */
    maxRemoteVideoStreams?: number;
}

/**
 * The state of a remote participant in the {@link VideoGallery}.
 *
 * @public
 */
export declare interface VideoGalleryRemoteParticipant extends VideoGalleryParticipant {
    /** Whether participant is speaking or not */
    isSpeaking?: boolean;
    /** Video stream of shared screen */
    screenShareStream?: VideoGalleryStream;
}

/**
 * Selector type for {@link VideoGallery} component.
 *
 * @public
 */
export declare type VideoGallerySelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    screenShareParticipant: VideoGalleryRemoteParticipant | undefined;
    localParticipant: VideoGalleryLocalParticipant;
    remoteParticipants: VideoGalleryRemoteParticipant[];
    dominantSpeakers?: string[];
};

/**
 * Video stream of a participant in {@link VideoGallery}.
 *
 * @public
 */
export declare interface VideoGalleryStream {
    /** ID of the video stream */
    id?: number;
    /** Whether the video stream is available or not */
    isAvailable?: boolean;
    /** Whether the video stream is mirrored or not */
    isMirrored?: boolean;
    /** Render element of the video stream */
    renderElement?: HTMLElement;
}

/**
 * All strings that may be shown on the UI in the {@link VideoGallery}.
 *
 * @public
 */
export declare interface VideoGalleryStrings {
    /** String to notify that local user is sharing their screen */
    screenIsBeingSharedMessage: string;
    /** String to show when remote screen share stream is loading */
    screenShareLoadingMessage: string;
    /** String for local video label. Default is "You" */
    localVideoLabel: string;
}

/**
 * {@link VideoGallery} Component Styles.
 * @public
 */
export declare interface VideoGalleryStyles extends BaseCustomStyles {
    /** Styles for the grid layout */
    gridLayout?: GridLayoutStyles;
    /** Styles for the horizontal gallery  */
    horizontalGallery?: HorizontalGalleryStyles;
    /** Styles for the local video  */
    localVideo?: IStyle;
}

/**
 * Options to control how video streams are rendered.
 *
 * @public
 */
export declare interface VideoStreamOptions {
    /** Whether the video stream is mirrored or not */
    isMirrored?: boolean;
    /** Scaling mode. It can be `Stretch`, `Crop` or `Fit` */
    scalingMode?: 'Stretch' | 'Crop' | 'Fit';
}

/**
 * State only version of {@link @azure/communication-calling#VideoStreamRendererView}. Currently no API is provided to
 * modify scalingMode after the stream as been rendered by {@link StatefulCallClient}. In order to change scalingMode
 * stop rendering the stream and re-start it using the desired scalingMode. This property is added to the state exposed
 * by {@link StatefulCallClient} by {@link StatefulCallClient.createView} and removed by
 * {@link StatefulCallClient.disposeView}.
 *
 * @public
 */
export declare interface VideoStreamRendererViewState {
    /**
     * Proxy of {@link @azure/communication-calling#VideoStreamRendererView.scalingMode}.
     */
    scalingMode: ScalingMode;
    /**
     * Proxy of {@link @azure/communication-calling#VideoStreamRendererView.isMirrored}.
     */
    isMirrored: boolean;
    /**
     * Proxy of {@link @azure/communication-calling#VideoStreamRendererView.target}.
     */
    target: HTMLElement;
}

/**
 * A component to render the video stream for a single call participant.
 *
 * Use with {@link GridLayout} in a {@link VideoGallery}.
 *
 * @public
 */
export declare const VideoTile: (props: VideoTileProps) => JSX.Element;

/**
 * Props for {@link VideoTile}.
 *
 * @public
 */
export declare interface VideoTileProps {
    /** React Child components. Child Components will show as overlay component in the VideoTile. */
    children?: React_2.ReactNode;
    /**
     * Allows users to pass in an object contains custom CSS styles.
     * @Example
     * ```
     * <VideoTile styles={{ root: { background: 'blue' } }} />
     * ```
     */
    styles?: VideoTileStylesProps;
    /** user id for the VideoTile placeholder. */
    userId?: string;
    /** Component with the video stream. */
    renderElement?: JSX.Element | null;
    /** Determines if the video is mirrored or not. */
    isMirrored?: boolean;
    /** Custom render Component function for no video is available. Render a Persona Icon if undefined. */
    onRenderPlaceholder?: OnRenderAvatarCallback;
    /**
     * Show label on the VideoTile
     * @defaultValue true
     */
    showLabel?: boolean;
    /**
     * Whether to display a mute icon beside the user's display name.
     * @defaultValue true
     */
    showMuteIndicator?: boolean;
    /**
     * Whether the video is muted or not.
     */
    isMuted?: boolean;
    /**
     * Display Name of the Participant to be shown in the label.
     * @remarks `displayName` is used to generate avatar initials if `initialsName` is not provided.
     */
    displayName?: string;
    /** Name of the participant used to generate initials. For example, a name `John Doe` will display `JD` as initials.
     * @remarks `displayName` is used if this property is not specified.
     */
    initialsName?: string;
    /** Optional property to set the aria label of the video tile if there is no available stream. */
    noVideoAvailableAriaLabel?: string;
    /** Whether the participant in the videoTile is speaking. Shows a speaking indicator (border). */
    isSpeaking?: boolean;
}

/**
 * Fluent styles for {@link VideoTile}.
 *
 * @public
 */
export declare interface VideoTileStylesProps extends BaseCustomStyles {
    /** Styles for video container. */
    videoContainer?: IStyle;
    /** Styles for container overlayed on the video container. */
    overlayContainer?: IStyle;
    /** Styles for displayName on the video container. */
    displayNameContainer?: IStyle;
}

export { }
